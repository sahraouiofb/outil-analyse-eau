<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyse Avanc√©e des √âcoulements - OFB</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.11.0/dist/proj4.js"></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script> <!-- For ML -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script> <!-- For GeoJSON handling -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .chart-container {
            height: 400px;
            width: 100%;
        }
        .trend-up { color: #22c55e; font-size: 1.5em; }
        .trend-down { color: #ef4444; font-size: 1.5em; }
        .trend-stable { color: #6b7280; font-size: 1.5em; }
        .trend-down-row {
            background-color: #fee2e2;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #005566;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        [data-tooltip] {
            position: relative;
        }
        [data-tooltip]:hover:after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #005566;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 10;
        }
        .low-flow-flag {
            background-color: #fef3c7;
            color: #b45309;
            font-weight: bold;
        }
        .stat-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }
        .table-header {
            background: linear-gradient(to right, #005566, #00a3a6);
            color: white;
        }
        .legend-container {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-top: 1rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        #map-container {
            height: 400px;
            width: 100%;
        }
        .projection-high { color: #ef4444; }
        .projection-medium { color: #f59e0b; }
        .projection-low { color: #22c55e; }
        #forecastModal {
            display: none;
            position: fixed;
            z-index: 50;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        #forecastModal .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
        }
        #forecastChart {
            height: 300px;
        }
        /* Styles for the new explicative modal */
        #explicativeModal {
            display: none;
            position: fixed;
            z-index: 50;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        #explicativeModal .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 1000px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #explicativeModal .modal-content h1, #explicativeModal .modal-content h2, #explicativeModal .modal-content h3 {
            color: #005566;
        }
        #explicativeModal .modal-content pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 6px;
            overflow-x: auto;
        }
        #explicativeModal .modal-content code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 min-h-screen font-sans transition-colors duration-300">
    <p class="text-red-500 italic text-sm absolute top-0 right-0 m-2">by SD40 2025</p>
    <header class="bg-gradient-to-r from-[#005566] to-[#00a3a6] shadow-md py-4">
        <div class="container mx-auto px-6 flex items-center justify-between">
            <img src="t√©l√©chargement.png" alt="Logo OFB" class="h-16">
            <h1 class="text-3xl font-bold text-white">
                Analyse Avanc√©e des √âcoulements - Office Fran√ßais de la Biodiversit√©
            </h1>
        </div>
    </header>
    <div class="container mx-auto p-6 max-w-7xl">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl mb-8">
            <div class="flex flex-wrap gap-4 mb-6">
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Charger fichier Excel</label>
                    <input type="file" id="excelFile" accept=".xlsx" class="hidden">
                    <button onclick="document.getElementById('excelFile').click()" class="w-full bg-gradient-to-r from-[#005566] to-[#00a3a6] text-white px-4 py-2 rounded-lg hover:from-[#004a55] hover:to-[#008c8f] transition-all" data-tooltip="Chargez un fichier Excel avec les colonnes 'Station d'√©coulement', 'Modalit√© d'ecoulement', 'Date de la campagne', 'Latitude', 'Longitude'">üìÅ Charger</button>
                </div>
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Stations/Groupes</label>
                    <input type="text" id="stationSearch" placeholder="Rechercher stations/groupes" class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6] mb-2">
                    <select id="stationSelect" multiple class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6]">
                        <option value="">S√©lectionner</option>
                    </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Ann√©es</label>
                    <select id="yearSelect" multiple class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6]">
                        <option value="">S√©lectionner</option>
                    </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Modalit√©</label>
                    <select id="modalitySelect" multiple class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6]">
                        <option value="">Toutes</option>
                    </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Nom du groupe</label>
                    <input type="text" id="groupName" placeholder="Nom du groupe" class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6]">
                </div>
                <div class="flex items-end gap-2">
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="comparePreviousYear" class="h-5 w-5 text-[#00a3a6] rounded focus:ring-[#00a3a6]">
                        <label for="comparePreviousYear" class="text-sm font-medium text-gray-700 dark:text-gray-300">Comparer avec l'ann√©e pr√©c√©dente</label>
                    </div>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="includeWeather" class="h-5 w-5 text-[#00a3a6] rounded focus:ring-[#00a3a6]" checked>
                        <label for="includeWeather" class="text-sm font-medium text-gray-700 dark:text-gray-300">Inclure Pr√©visions M√©t√©o</label>
                    </div>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="includeHubEau" class="h-5 w-5 text-[#00a3a6] rounded focus:ring-[#00a3a6]" checked>
                        <label for="includeHubEau" class="text-sm font-medium text-gray-700 dark:text-gray-300">Inclure D√©bits Hub'Eau</label>
                    </div>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="includeExtended" class="h-5 w-5 text-[#00a3a6] rounded focus:ring-[#00a3a6]" checked>
                        <label for="includeExtended" class="text-sm font-medium text-gray-700 dark:text-gray-300">Inclure Nappes/Pr√©l√®vements/Masses/Bassins</label>
                    </div>
                    <button onclick="createStationGroup()" class="bg-gradient-to-r from-[#005566] to-[#00a3a6] text-white px-4 py-2 rounded-lg hover:from-[#004a55] hover:to-[#008c8f] transition-all" data-tooltip="Cr√©er un groupe de stations">‚ûï Groupe</button>
                    <button onclick="resetFilters()" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition-all" data-tooltip="R√©initialiser les filtres">üîÑ R√©initialiser</button>
                    <button onclick="exportToWordRisk()" class="bg-[#ef4444] text-white px-4 py-2 rounded-lg hover:bg-[#dc2626] transition-all" data-tooltip="Exporter Rapport Analyse D√©taill√©e en HTML (ouvrable dans Word)">üìù Rapport Analyse D√©taill√©e</button>
                    <button id="openExplicativeModal" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-all" data-tooltip="Ouvrir la note explicative">üìñ Aide</button>
                    <button onclick="exportToPDF()" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 transition-all" data-tooltip="Exporter en PDF">üìÑ Export PDF</button>
                    <button id="predictML" class="bg-purple-500 text-white px-4 py-2 rounded-lg">Pr√©dire Vuln√©rabilit√© ML</button>
                </div>
            </div>
            <div id="groupList" class="hidden bg-[#e6f2f3] dark:bg-gray-700 p-4 rounded-lg mb-4"></div>
            <div class="bg-[#e6f2f3] dark:bg-[#1c3e44] p-4 rounded-lg text-sm text-[#005566] dark:text-[#b3d6d8]">
                <strong>üí° Comment utiliser :</strong>
                <ul class="list-disc pl-5">
                    <li>Chargez un fichier Excel (.xlsx) avec les colonnes : Station d'√©coulement, Modalit√© d'√©coulement, Date de la campagne, Latitude, Longitude.</li>
                    <li>Cr√©ez des groupes en s√©lectionnant plusieurs stations et en saisissant un nom.</li>
                    <li>Filtrez par stations, ann√©es ou modalit√©s pour analyser les tendances sur les deux derniers relev√©s ou comparer avec l'ann√©e pr√©c√©dente.</li>
                    <li>La carte montre les stations avec couleurs pour le dernier relev√© et fl√®che pour la tendance.</li>
                    <li>Les projections m√©t√©o (via Open-Meteo) fournissent des pr√©visions sur 7 jours pour estimer les risques de d√©gradation (bas√©es sur pluie et temp√©rature).</li>
                    <li>Exportez les r√©sultats en HTML pour des rapports (ouvre dans Word).</li>
                    <li>Nouveau : Activez "Inclure D√©bits Hub'Eau" pour int√©grer des donn√©es de d√©bit en temps r√©el et historiques de l'API Hub'Eau.</li>
                    <li>√âtendu : Nappes, Pr√©l√®vements, Masses d'eau, Bassins via Hub'Eau, corr√©l√©s par GPS (bbox).</li>
                    <li>ML : Pr√©dictions de vuln√©rabilit√© via TensorFlow.js.</li>
                </ul>
                <p><strong>Note : Si vous rencontrez des erreurs CORS lors du chargement des donn√©es Hub'Eau, ex√©cutez ce fichier HTML sur un serveur local (par exemple, avec Python : python -m http.server) au lieu de l'ouvrir directement dans le navigateur. Proxy mis √† jour pour compression.</strong></p>
            </div>
            <div id="status" class="hidden p-4 rounded-lg mt-4"></div>
        </div>

        <div id="loading" class="hidden text-center py-10">
            <div class="spinner mx-auto"></div>
            <p class="text-gray-600 dark:text-gray-300">Chargement...</p>
        </div>

        <div id="dashboard" class="hidden">
            <div class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-200 mb-4">R√©sum√© de l'Analyse</h2>
                <p class="text-gray-600 dark:text-gray-300 mb-6">Cette section pr√©sente une vue d'ensemble des donn√©es d'ecoulement, incluant le nombre total d'observations, les stations actives, et la r√©partition des modalit√©s. Utilisez les filtres pour affiner l'analyse.</p>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6" id="summaryStats"></div>
            </div>
            <div class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-200 mb-4">Classements</h2>
                <p class="text-gray-600 dark:text-gray-300 mb-6">Classement des 10 stations avec les variations de tendance les plus importantes et des stations les plus souvent d√©grad√©es (Assec, √âcoulement faible, etc.) selon les ann√©es s√©lectionn√©es.</p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Top 10 Stations avec Variations Importantes</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Stations avec les plus grandes variations de modalit√©s sur les ann√©es s√©lectionn√©es.</p>
                        <div class="overflow-x-auto">
                            <table id="variationTable" class="w-full text-sm text-gray-800 dark:text-gray-200 border-collapse">
                                <thead>
                                    <tr class="table-header">
                                        <th class="p-3 border">Station</th>
                                        <th class="p-3 border">Variation Moyenne (%)</th>
                                        <th class="p-3 border">Modalit√©s Observ√©es</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Stations les Plus D√©grad√©es</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Stations avec la plus forte proportion de modalit√©s d√©grad√©es (Assec, √âcoulement faible, Critique).</p>
                        <div class="overflow-x-auto">
                            <table id="degradedTable" class="w-full text-sm text-gray-800 dark:text-gray-200 border-collapse">
                                <thead>
                                    <tr class="table-header">
                                        <th class="p-3 border">Station</th>
                                        <th class="p-3 border">% D√©grad√©</th>
                                        <th class="p-3 border">Modalit√©s D√©grad√©es</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
            <div class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-200 mb-4">Visualisations D√©taill√©es</h2>
                <p class="text-gray-600 dark:text-gray-300 mb-6">Les graphiques ci-dessous illustrent la r√©partition des √©coulements par station, les tendances annuelles, les √©volutions par station ou groupe. Les donn√©es sont bas√©es sur les deux derniers relev√©s pour les tendances.</p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">R√©partition par Station</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Pourcentage des modalit√©s d'ecoulement par station s√©lectionn√©e.</p>
                        <div class="chart-container" id="stationChart"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Modalit√©s d'√âcoulement</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">R√©partition globale des modalit√©s d'ecoulement.</p>
                        <div class="chart-container" id="modalityChart"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">√âvolution Annuelle</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">√âvolution des modalit√©s d'ecoulement par ann√©e.</p>
                        <div class="chart-container" id="yearlyTrendChart"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Tendances par Station/Groupe</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Tendances des √©coulements pour les stations ou groupes s√©lectionn√©s.</p>
                        <div class="chart-container" id="stationTrendChart"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6] lg:col-span-2">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Carte des Stations</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Localisation des stations avec code couleur pour le dernier relev√©, fl√®che pour la tendance, et bordure pour projection m√©t√©o. Couches pour nappes, pr√©l√®vements, etc.</p>
                        <button id="toggleSensitive" class="bg-blue-500 text-white px-4 py-2 rounded-lg mb-4 hover:bg-blue-600">Afficher Stations Sensibles</button>
                        <div id="map-legend" class="mb-4 text-sm text-gray-700 dark:text-gray-300"></div>
                        <div id="map-container"></div>
                    </div>
                </div>
            </div>
            <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl">
                <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Analyse des Tendances</h3>
                <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Tableau r√©capitulatif des tendances bas√© sur les deux derniers relev√©s ou la comparaison avec l'ann√©e pr√©c√©dente. Les stations √† faible √©coulement r√©current sont mises en √©vidence. Projections bas√©es sur pr√©visions m√©t√©o Open-Meteo (7 jours).</p>
                <div class="legend-container">
                    <div class="legend-item"><span class="trend-up">‚Üó</span> Am√©lioration</div>
                    <div class="legend-item"><span class="trend-down">‚Üò</span> D√©gradation</div>
                    <div class="legend-item"><span class="trend-stable">‚Üî</span> Stable</div>
                </div>
                <div class="overflow-x-auto mt-4">
                    <table id="trendTable" class="w-full text-sm text-gray-800 dark:text-gray-200 border-collapse">
                        <thead>
                            <tr class="table-header">
                                <th class="p-3 border">Station/Groupe</th>
                                <th class="p-3 border">Total Obs.</th>
                                <th class="p-3 border">Dates des relev√©s</th>
                                <th class="p-3 border">Modalit√©s des relev√©s</th>
                                <th class="p-3 border">Tendance</th>
                                <th class="p-3 border">Donn√©es M√©t√©o (7j)</th>
                                <th class="p-3 border">Projection √©volution d'ecoulement</th>
                                <th class="p-3 border">Recommandation</th>
                                <th class="p-3 border">D√©bit Moyen (m¬≥/s)</th>
                                <th class="p-3 border">Niveau Nappe (m)</th>
                                <th class="p-3 border">Pr√©l√®vement Vol. (m¬≥)</th>
                                <th class="p-3 border">√âtat Masse d'Eau</th>
                                <th class="p-3 border">Bassin Versant</th>
                                <th class="p-3 border">Score Vuln√©rabilit√©</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div id="forecastModal">
            <div class="modal-content dark:bg-gray-800 dark:text-gray-200">
                <span onclick="document.getElementById('forecastModal').style.display='none'" class="cursor-pointer float-right text-2xl">√ó</span>
                <h3 class="text-xl font-semibold mb-4">Pr√©visions M√©t√©o Journali√®res</h3>
                <div id="forecastChart" class="chart-container"></div>
            </div>
        </div>

        <div id="explicativeModal">
            <div class="modal-content dark:bg-gray-800 dark:text-gray-200">
                <span onclick="document.getElementById('explicativeModal').style.display='none'" class="cursor-pointer float-right text-2xl">√ó</span>
                <h1>Note d'Utilisation et Explication des Fonctionnalit√©s de l'Outil d'Analyse Avanc√©e des √âcoulements - Office Fran√ßais de la Biodiversit√© (OFB)</h1>

                <h2>Introduction</h2>
                <p>Cet outil web est con√ßu pour analyser les donn√©es d'ecoulements hydrologiques de mani√®re avanc√©e et intuitive. Il permet de charger des fichiers Excel contenant des observations de stations d'ecoulement, de filtrer ces donn√©es, de visualiser les tendances, de g√©n√©rer des projections bas√©es sur des pr√©visions m√©t√©o, et d'exporter des rapports d√©taill√©s. L'interface est simple, responsive (adapt√©e aux mobiles et ordinateurs), et supporte un mode sombre automatique. D√©velopp√© en HTML, CSS et JavaScript avec des biblioth√®ques comme ECharts (graphiques), Leaflet (cartographie) et XLSX (import Excel), il est marqu√© "by SD40 2025" pour indiquer sa version.</p>
                <p>Si vous √™tes nouveau, cette note vous guide pas √† pas. L'objectif est d'aider √† identifier les tendances de d√©gradation ou d'am√©lioration des √©coulements, en se concentrant sur des modalit√©s comme "assec" (s√©cheresse), "√©coulement non visible", "√©coulement visible faible" ou "acceptable". L'outil int√®gre des donn√©es m√©t√©o via l'API Open-Meteo et utilise des calculs statistiques pour des analyses fiables. Aucune installation n'est requise : ouvrez simplement le fichier HTML dans un navigateur (Chrome recommand√©).</p>

                <h2>Fonctionnalit√©s Principales</h2>
                <p>L'outil est divis√© en sections pour une utilisation fluide. Voici un aper√ßu des fonctionnalit√©s cl√©s :</p>
                <ol>
                    <li><strong>Importation de Donn√©es</strong> :
                        <ul>
                            <li>Chargez un fichier Excel (.xlsx) via le bouton "üìÅ Charger".</li>
                            <li>Colonnes requises : "Station d'ecoulement", "Modalit√© d'ecoulement", "Date de la campagne".</li>
                            <li>Colonnes optionnelles : "Latitude" et "Longitude" (pour la carte, en coordonn√©es EPSG:2154 converties automatiquement en WGS84).</li>
                            <li>L'outil ignore les lignes avec modalit√©s vides, "inconnu" ou "non observable".</li>
                        </ul>
                    </li>
                    <li><strong>Filtres et Groupes</strong> :
                        <ul>
                            <li>S√©lection multiple de stations, ann√©es ou modalit√©s via les menus d√©roulants.</li>
                            <li>Cr√©ez des groupes : S√©lectionnez des stations, saisissez un nom dans "Nom du groupe", et cliquez sur "‚ûï Groupe" (utile pour analyser des r√©gions).</li>
                            <li>Options : "Comparer avec l'ann√©e pr√©c√©dente" pour inclure les donn√©es de N-1 ; "Inclure Pr√©visions M√©t√©o" pour des projections.</li>
                            <li>Recherche : Tapez dans "Rechercher stations/groupes" pour filtrer rapidement.</li>
                            <li>R√©initialisez tout avec "üîÑ R√©initialiser".</li>
                        </ul>
                    </li>
                    <li><strong>R√©sum√© Statistique</strong> :
                        <ul>
                            <li>Affiche des cartes avec le total d'observations, le nombre de stations actives, et les pourcentages par modalit√© (ex. : % assec).</li>
                            <li>Utile pour un aper√ßu rapide des donn√©es filtr√©es.</li>
                        </ul>
                    </li>
                    <li><strong>Classements</strong> :
                        <ul>
                            <li>"Top 10 Stations avec Variations Importantes" : Liste les stations avec les plus grands changements de modalit√©s (bas√© sur un score de variation).</li>
                            <li>"Stations les Plus D√©grad√©es" : Liste les stations avec la plus haute proportion de modalit√©s d√©grad√©es (assec, non visible, faible).</li>
                        </ul>
                    </li>
                    <li><strong>Visualisations</strong> :
                        <ul>
                            <li>Graphiques interactifs : r√©partition par station (barres empil√©es), modalit√©s globales (pie chart), √©volution annuelle (lignes avec aires), tendances par station/groupe (lignes ou barres).</li>
                            <li>Carte interactive : Localise les stations avec couleurs (modalit√©s), fl√®ches (tendances), et bordures (projections m√©t√©o). Activez "Afficher Stations Sensibles" pour highlighter les risques.</li>
                            <li>Outils de zoom et t√©l√©chargement d'images pour chaque graphique (ic√¥nes modernes pour une meilleure UX).</li>
                        </ul>
                    </li>
                    <li><strong>Analyse des Tendances</strong> :
                        <ul>
                            <li>Tableau r√©capitulatif : Pour chaque station/groupe, affiche le total d'observations, dates/modalit√©s des relev√©s, tendance (‚Üó/‚Üò/‚Üî), donn√©es m√©t√©o, projection d'√©volution, et recommandations.</li>
                            <li>Cliquez sur une ligne pour voir les pr√©visions m√©t√©o d√©taill√©es (graphique dans une modale).</li>
                            <li>L√©gende : ‚Üó Am√©lioration, ‚Üò D√©gradation, ‚Üî Stable.</li>
                        </ul>
                    </li>
                    <li><strong>Exportation</strong> :
                        <ul>
                            <li>Cliquez sur "üìù Rapport Analyse D√©taill√©e" pour g√©n√©rer un fichier HTML (ouvrable dans Word) avec r√©sum√©s, tableaux, graphiques captur√©s, et analyses (variance inter-annuelle, corr√©lation Spearman).</li>
                        </ul>
                    </li>
                    <li><strong>Autres</strong> :
                        <ul>
                            <li>Mode sombre automatique.</li>
                            <li>Messages : Spinner pendant le chargement, alertes pour erreurs (ex. : fichier invalide).</li>
                            <li>Cache : Les pr√©visions m√©t√©o sont mises en cache 1 heure pour acc√©l√©rer les analyses.</li>
                        </ul>
                    </li>
                </ol>

                <h2>Comment Utiliser l'Outil √âtape par √âtape</h2>
                <ol>
                    <li><strong>Ouverture</strong> : Ouvrez le fichier HTML dans votre navigateur.</li>
                    <li><strong>Chargement des Donn√©es</strong> : Cliquez sur "üìÅ Charger" et s√©lectionnez votre Excel. Attendez le message de succ√®s (ex. : "X observations charg√©es !").</li>
                    <li><strong>Filtrage</strong> :
                        <ul>
                            <li>Choisissez des stations/ann√©es/modalit√©s.</li>
                            <li>Pour un groupe : S√©lectionnez stations, entrez nom, cliquez "‚ûï Groupe".</li>
                            <li>Activez options (comparaison, m√©t√©o) si besoin.</li>
                        </ul>
                    </li>
                    <li><strong>Exploration</strong> :
                        <ul>
                            <li>Consultez le "R√©sum√©" pour les stats globales.</li>
                            <li>V√©rifiez les "Classements" pour les tops.</li>
                            <li>Explorez les "Visualisations" : Zoomez, t√©l√©chargez.</li>
                            <li>Analysez les "Tendances" : Lisez recommandations, cliquez pour m√©t√©o.</li>
                        </ul>
                    </li>
                    <li><strong>Export</strong> : G√©n√©rez le rapport HTML et ouvrez-le dans Word pour √©dition/impression.</li>
                    <li><strong>Astuces</strong> : Si la carte n'appara√Æt pas, v√©rifiez les coordonn√©es dans l'Excel. Pour des erreurs, rechargez la page.</li>
                </ol>

                <h2>Formules et M√©thodologies Utilis√©es</h2>
                <p>L'outil utilise des calculs simples mais robustes pour analyser les donn√©es. Voici une explication accessible, sans maths complexes. Les seuils (ex. : 0.5 pour tendances) sont configurables dans le code si vous √™tes d√©veloppeur.</p>

                <h3>Pond√©ration des Modalit√©s</h3>
                <p>Chaque type d'√©coulement a un "poids" refl√©tant sa gravit√© :</p>
                <ul>
                    <li>Assec : 4 (tr√®s d√©grad√©)</li>
                    <li>√âcoulement non visible : 3</li>
                    <li>√âcoulement visible faible : 2</li>
                    <li>√âcoulement visible acceptable : 1 (bon)</li>
                    <li>Autres : 1.5</li>
                </ul>
                <p>Formule du poids moyen pour un groupe de relev√©s :</p>
                <pre><code>Poids moyen = (Somme des poids de chaque relev√©) / Nombre de relev√©s</code></pre>
                <p>Cela permet de quantifier si l'√©coulement est "mauvais" (poids √©lev√©) ou "bon" (poids bas).</p>

                <h3>Calcul de la Tendance</h3>
                <p>Compare le poids moyen entre deux p√©riodes (derniers relev√©s ou ann√©es) :</p>
                <pre><code>Diff√©rence = Poids courant - Poids pr√©c√©dent</code></pre>
                <ul>
                    <li>Si > 0.5 : D√©gradation (‚Üò, situation empire)</li>
                    <li>Si < -0.5 : Am√©lioration (‚Üó, situation s'am√©liore)</li>
                    <li>Sinon : Stable (‚Üî)</li>
                </ul>
                <p>Pourcentages par modalit√© (pour d√©tails) :</p>
                <pre><code>% Modalit√© = (Nombre de cette modalit√© / Total relev√©s) √ó 100</code></pre>

                <h3>Projection d'√âvolution (M√©t√©o)</h3>
                <p>Bas√©e sur la derni√®re modalit√© et pr√©visions (pluie cumul√©e, temp√©rature moyenne sur 7 jours via Open-Meteo) :</p>
                <pre><code>Risque (%) = (Poids dernier √ó 50) + ((10 - Pluie) √ó 5) + ((Temp√©rature - 15) √ó 2)</code></pre>
                <ul>
                    <li>Risque limit√© √† 0-100.</li>
                    <li>>70% : D√©gradation probable (rouge, alerte)</li>
                    <li>30-70% : Stable avec vigilance (orange)</li>
                    <li><30% : Am√©lioration possible (vert)</li>
                </ul>

                <h3>Score de Variation (Changements Importants)</h3>
                <p>Mesure combien les % de modalit√©s changent d'une ann√©e √† l'autre :</p>
                <p>Pour deux ann√©es :</p>
                <pre><code>Variation = Somme des |% courant - % pr√©c√©dent| / Nombre de modalit√©s</code></pre>
                <p>Moyenne globale :</p>
                <pre><code>VariationMoyenne = Somme des variations / Nombre de paires d'ann√©es</code></pre>
                <p>Utilis√© pour le top 10 des stations variables.</p>

                <h3>Pourcentage D√©grad√©</h3>
                <pre><code>% D√©grad√© = (Nombre de modalit√©s d√©grad√©es / Total observations) √ó 100</code></pre>
                <p>D√©grad√©es : assec, non visible, faible.</p>

                <h3>Corr√©lation Spearman</h3>
                <p>Mesure si les stations avec beaucoup de variations sont souvent d√©grad√©es (valeur entre -1 et 1) :</p>
                <pre><code>œÅ = 1 - (6 √ó Somme des (diff√©rences de rangs)^2) / (n √ó (n¬≤ - 1))</code></pre>
                <p>o√π n = nombre de stations, rangs bas√©s sur scores. Si proche de 1 : Forte lien (utilis√© dans le score de sensibilit√©).</p>

                <h3>Score de Sensibilit√© (Stations Sensibles)</h3>
                <pre><code>Sensibilit√© (%) = (% D√©grad√© √ó 0.4) + (Variation √ó 0.3) + (Si r√©current : +30) + (Si corr√©lation >0.5 : corr√©lation √ó 30)</code></pre>
                <p>Limit√© √† 0-100. Couleurs sur carte : rouge (>70%), orange (40-70%), vert (<40%).</p>

                <h3>√âcoulement Faible R√©current</h3>
                <p>Si ‚â•50% des ann√©es ont ‚â•50% de modalit√©s d√©grad√©es (et au moins 2 ann√©es) : Station r√©currente (flag dans tableau).</p>

                <p>Ces formules rendent l'analyse objective. Pour plus de d√©tails, regardez le code JavaScript (section "trendConfig" pour ajuster). Si vous avez des questions, testez avec un Excel exemple ou contactez un d√©veloppeur.</p>
            </div>
        </div>
    <script>
        let data = [];
        let allStations = [];
        let allYears = [];
        let allModalities = [];
        let stationGroups = {};
        let charts = {};
        let comparePreviousYear = false;
        let includeWeather = true;
        let includeHubEau = true;
        let includeExtended = true; // New for extended data
        let stationCoordinates = {};
        let map = null;
        let projections = [];
        let heatLayer;
        let sensitiveMode = false;
        let hubEauDebits = {};
        let stationHubCodes = {};
        let piezoData = {}; // New for nappes
        let prelevData = {}; // New for pr√©l√®vements
        let massesData = {}; // New for masses d'eau
        let bassinsData = {}; // New for bassins

        const trendConfig = {
            criticalThreshold: 40,
            lowThreshold: 30,
            stableThreshold: 60,
            minObservations: 2,
            modalityWeights: {
                'assec': 4,
                'ecoulement non visible': 3,
                'ecoulement visible faible': 2,
                'ecoulement visible acceptable': 1
            },
            lowFlowThreshold: 50,
            degradedModalities: ['assec', 'ecoulement non visible', 'ecoulement visible faible'],
            debitThreshold: 0.1,
            nappeThreshold: 5, // New: Low nappe level threshold
            prelevThreshold: 1000 // New: High prelev volume threshold
        };

        const modalityColors = {
            'assec': 'red',
            'ecoulement non visible': '#ff4500',
            'ecoulement visible faible': 'orange',
            'ecoulement visible acceptable': 'green',
            'non observable': 'gray'
        };

        async function fetchViaProxy(url) {
            try {
                const response = await fetch(`/proxy?url=${encodeURIComponent(url)}`, {
                    headers: {
                        'Accept-Encoding': 'identity' // Force no compression
                    }
                });
                if (!response.ok) throw new Error(`Erreur proxy ${response.status} pour ${url}`);
                return await response.json();
            } catch (error) {
                console.error(`√âchec de fetchViaProxy:`, error);
                showStatus('Erreur lors de la r√©cup√©ration des donn√©es API : ' + error.message, 'error');
                return null;
            }
        }

        function generateDynamicColors(modalities) {
            return modalities.reduce((acc, modality, index) => {
                acc[modality.toLowerCase()] = modalityColors[modality.toLowerCase()] || `hsl(${index * 60}, 70%, 50%)`;
                return acc;
            }, {});
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `p-4 rounded-lg ${type === 'success' ? 'bg-[#e6f2f3] text-[#005566]' : 'bg-red-100 text-red-800'}`;
            status.style.display = 'block';
            if (type === 'success') setTimeout(() => status.style.display = 'none', 3000);
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('dashboard').style.display = show ? 'none' : 'block';
        }

        function loadDataFromFile(input) {
            const file = input.files[0];
            if (!file) return showStatus('Aucun fichier s√©lectionn√©.', 'error');
            showLoading(true);

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    const workbook = XLSX.read(arrayBuffer, { type: 'array', cellDates: true, dateNF: 'yyyy-mm-dd' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, header: 1 });

                    data = parseExcelData(jsonData);
                    if (data.length === 0) throw new Error('Aucune donn√©e valide trouv√©e (toutes les modalit√©s sont vides ou inconnues).');
                    updateStationSelect();
                    updateYearSelect();
                    updateModalitySelect();
                    updateDashboard();
                    showStatus(`${data.length} observations charg√©es !`, 'success');
                    showLoading(false);
                } catch (error) {
                    showStatus('Erreur : ' + error.message, 'error');
                    showLoading(false);
                }
            };
            reader.onerror = () => {
                showStatus('Erreur lors de la lecture du fichier.', 'error');
                showLoading(false);
            };
            reader.readAsArrayBuffer(file);
        }

        function parseExcelData(jsonData) {
            const parsedData = [];
            const findColumn = (searchTerms, headers) => headers.findIndex(header =>
                searchTerms.some(term => header?.toLowerCase().replace(/\s+/g, '').includes(term.toLowerCase().replace(/\s+/g, '')))
            );

            if (!jsonData.length || !Array.isArray(jsonData[0])) throw new Error('Fichier Excel vide ou mal format√©.');
            const headers = jsonData[0].map(h => h ? h.toString().trim() : '');
            const stationCol = findColumn(['station√©coulement', 'station'], headers);
            const modalityCol = findColumn(['modalit√© d\'√©coulement', 'modalit√©'], headers);
            const dateCol = findColumn(['date de l\'observation', 'date'], headers);
            const latCol = findColumn(['latitude'], headers);
            const lonCol = findColumn(['longitude'], headers);
            const codeStationCol = findColumn(['code station', 'code_station', 'code station (hydro)', 'codestation(hydro)', 'codestationhydro'], headers);

            if (stationCol === -1 || modalityCol === -1 || dateCol === -1) {
                throw new Error('Colonnes requises manquantes : Station, Modalit√©, Date.');
            }

            proj4.defs('EPSG:2154', '+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');

            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                const station = row[stationCol]?.toString().trim();
                const modality = row[modalityCol]?.toString().trim().toLowerCase();

                if (!station || !modality || modality === 'inconnu' || modality === 'non observable') continue; // Ignore vide, "Inconnu", or "non observable"

                let date = row[dateCol];
                if (date instanceof Date) {
                    date = date.toISOString().split('T')[0];
                } else if (date && typeof date === 'string') {
                    const parsedDate = new Date(date);
                    if (!isNaN(parsedDate.getTime())) {
                        date = parsedDate.toISOString().split('T')[0];
                    } else if (/^\d+(\.\d+)?$/.test(date)) {
                        const excelEpoch = new Date(1900, 0, 1);
                        const parsedDate = new Date(excelEpoch.getTime() + (parseFloat(date) - 2) * 24 * 60 * 60 * 1000);
                        date = parsedDate.toISOString().split('T')[0];
                    } else {
                        date = new Date().toISOString().split('T')[0];
                    }
                } else {
                    date = new Date().toISOString().split('T')[0];
                }

                parsedData.push({
                    'Station d\'√©coulement': station,
                    'Modalit√© d\'√©coulement': modality,
                    'Date de la campagne': date
                });

                // Stockage des coordonn√©es (uniques par station)
                if (latCol !== -1 && lonCol !== -1) {
                    const x = parseFloat(row[lonCol]);
                    const y = parseFloat(row[latCol]);
                    if (!isNaN(x) && !isNaN(y)) {
                        const [lon, lat] = proj4('EPSG:2154', 'EPSG:4326', [x, y]);
                        stationCoordinates[station] = { lat, lon };
                    }
                }

                // New: Stockage du code station si pr√©sent
                if (codeStationCol !== -1) {
                    const codeStation = row[codeStationCol]?.toString().trim();
                    if (codeStation) {
                        stationHubCodes[station] = codeStation;
                    }
                }
            }

            allModalities = [...new Set(parsedData.map(d => d['Modalit√© d\'√©coulement']))].sort();
            return parsedData;
        }

        function updateStationSelect() {
            const select = document.getElementById('stationSelect');
            allStations = [...new Set(data.map(d => d['Station d\'√©coulement']))].sort();
            select.innerHTML = '<option value="">S√©lectionner</option>';
            allStations.forEach(station => {
                const option = document.createElement('option');
                option.value = station;
                option.textContent = station;
                select.appendChild(option);
            });
            updateGroupList();
            initStationSearch();
        }

        function updateYearSelect() {
            const select = document.getElementById('yearSelect');
            allYears = [...new Set(data.map(d => new Date(d['Date de la campagne']).getFullYear()))].sort();
            select.innerHTML = '<option value="">S√©lectionner</option>';
            allYears.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                select.appendChild(option);
            });
        }

        function initStationSearch() {
            const searchInput = document.getElementById('stationSearch');
            const select = document.getElementById('stationSelect');
            searchInput.addEventListener('input', () => {
                const filter = searchInput.value.toLowerCase();
                Array.from(select.options).forEach(opt => {
                    if (opt.value === '') return;
                    opt.style.display = opt.text.toLowerCase().includes(filter) ? 'block' : 'none';
                });
            });
        }

        function updateModalitySelect() {
            const select = document.getElementById('modalitySelect');
            select.innerHTML = '<option value="">Toutes</option>';
            allModalities.forEach(modality => {
                const option = document.createElement('option');
                option.value = modality;
                option.textContent = modality;
                select.appendChild(option);
            });
        }

        function createStationGroup() {
            const groupName = document.getElementById('groupName').value.trim();
            const selectedStations = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);

            if (!groupName || selectedStations.length === 0 || selectedStations[0] === '') {
                return showStatus('Nom de groupe ou stations non sp√©cifi√©s.', 'error');
            }

            if (stationGroups[groupName]) {
                return showStatus(`Le groupe "${groupName}" existe d√©j√†.`, 'error');
            }

            stationGroups[groupName] = selectedStations;
            document.getElementById('groupName').value = '';
            updateGroupList();
            updateStationSelectWithGroups();
            showStatus(`Groupe "${groupName}" cr√©√© !`, 'success');
        }

        function updateGroupList() {
            const groupList = document.getElementById('groupList');
            groupList.innerHTML = '';
            if (Object.keys(stationGroups).length > 0) {
                groupList.style.display = 'block';
                Object.keys(stationGroups).forEach(group => {
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center p-2 border-b border-[#b3d6d8] dark:border-gray-600';
                    div.innerHTML = `
                        <span class="text-gray-800 dark:text-gray-200"><strong>${group}</strong>: ${stationGroups[group].join(', ')}</span>
                        <button onclick="deleteGroup('${group}')" class="bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600">Supprimer</button>
                    `;
                    groupList.appendChild(div);
                });
            } else {
                groupList.style.display = 'none';
            }
            updateStationSelectWithGroups();
        }

        function updateStationSelectWithGroups() {
            const select = document.getElementById('stationSelect');
            select.innerHTML = '<option value="">S√©lectionner</option>';
            allStations.forEach(station => {
                const option = document.createElement('option');
                option.value = station;
                option.textContent = station;
                select.appendChild(option);
            });
            Object.keys(stationGroups).forEach(group => {
                const option = document.createElement('option');
                option.value = `group:${group}`;
                option.textContent = `Groupe: ${group}`;
                select.appendChild(option);
            });
        }

        function deleteGroup(groupName) {
            delete stationGroups[groupName];
            updateGroupList();
            updateDashboard();
            showStatus(`Groupe "${groupName}" supprim√©.`, 'success');
        }

        function getFilteredData() {
            const selections = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);
            const modalities = Array.from(document.getElementById('modalitySelect').selectedOptions).map(opt => opt.value);
            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => parseInt(opt.value));

            let filteredData = [...data];
            let stations = [];

            selections.forEach(selection => {
                if (selection.startsWith('group:')) {
                    const groupName = selection.replace('group:', '');
                    if (stationGroups[groupName]) stations.push(...stationGroups[groupName]);
                } else {
                    stations.push(selection);
                }
            });

            if (stations.length > 0 && stations[0] !== '') {
                filteredData = filteredData.filter(d => stations.includes(d['Station d\'√©coulement']));
            }
            if (modalities.length > 0 && modalities[0] !== '') {
                filteredData = filteredData.filter(d => modalities.includes(d['Modalit√© d\'√©coulement']));
            }
            if (years.length > 0 && years[0] !== NaN) {
                filteredData = filteredData.filter(d => years.includes(new Date(d['Date de la campagne']).getFullYear()));
            }

            // Si la comparaison avec l'ann√©e pr√©c√©dente est activ√©e, inclure l'ann√©e pr√©c√©dente
            if (comparePreviousYear) {
                const currentYears = [...new Set(filteredData.map(d => new Date(d['Date de la campagne']).getFullYear()))];
                const previousYears = currentYears.map(year => year - 1);
                filteredData = [...data].filter(d => {
                    const year = new Date(d['Date de la campagne']).getFullYear();
                    return currentYears.includes(year) || previousYears.includes(year);
                });
                if (stations.length > 0 && stations[0] !== '') {
                    filteredData = filteredData.filter(d => stations.includes(d['Station d\'√©coulement']));
                }
                if (modalities.length > 0 && modalities[0] !== '') {
                    filteredData = filteredData.filter(d => modalities.includes(d['Modalit√© d\'√©coulement']));
                }
            }

            return filteredData;
        }

        function resetFilters() {
            document.getElementById('stationSelect').value = '';
            document.getElementById('modalitySelect').value = '';
            document.getElementById('groupName').value = '';
            document.getElementById('yearSelect').value = '';
            document.getElementById('comparePreviousYear').checked = false;
            document.getElementById('includeWeather').checked = true;
            document.getElementById('includeHubEau').checked = true;
            document.getElementById('includeExtended').checked = true;
            comparePreviousYear = false;
            includeWeather = true;
            includeHubEau = true;
            includeExtended = true;
            sensitiveMode = false;
            document.getElementById('toggleSensitive').textContent = 'Afficher Stations Sensibles';
            updateDashboard();
        }

        function isRecurringLowFlow(station, records) {
            const yearlyData = {};
            records.forEach(r => {
                const year = new Date(r['Date de la campagne']).getFullYear();
                if (!yearlyData[year]) {
                    yearlyData[year] = { total: 0, low: 0 };
                }
                yearlyData[year].total++;
                if (trendConfig.degradedModalities.some(m => r['Modalit√© d\'√©coulement'].toLowerCase().includes(m))) {
                    yearlyData[year].low++;
                }
            });

            const yearsWithData = Object.keys(yearlyData).length;
            if (yearsWithData < 2) return false;

            const lowFlowYears = Object.values(yearlyData).filter(y => y.total > 0 && (y.low / y.total) * 100 >= trendConfig.lowFlowThreshold).length;
            return lowFlowYears >= Math.max(2, Math.floor(yearsWithData * 0.5));
        }

        function calculateTrend(records, currentYear, previousYear) {
            const currentRecords = records.filter(r => new Date(r['Date de la campagne']).getFullYear() === currentYear);
            const previousRecords = previousYear ? records.filter(r => new Date(r['Date de la campagne']).getFullYear() === previousYear) : [];

            if (currentRecords.length === 0 || (previousYear && previousRecords.length === 0)) {
                return {
                    trend: '‚Üî',
                    trendClass: 'trend-stable',
                    tooltip: previousYear ? `Donn√©es insuffisantes pour ${currentYear} ou ${previousYear}` : `Donn√©es insuffisantes pour la comparaison`
                };
            }

            const calculatePercentages = (recs) => {
                const modalityCounts = {};
                allModalities.forEach(modality => modalityCounts[modality] = 0);
                recs.forEach(r => modalityCounts[r['Modalit√© d\'√©coulement']]++);
                const total = recs.length;
                return allModalities.reduce((acc, modality) => {
                    acc[modality] = total > 0 ? Math.round((modalityCounts[modality] / total) * 100) : 0;
                    return acc;
                }, {});
            };

            const currentPercentages = calculatePercentages(currentRecords);
            const previousPercentages = previousYear ? calculatePercentages(previousRecords) : {};

            const calculateAverageWeight = (recs) => {
                if (recs.length === 0) return 0;
                const totalWeight = recs.reduce((sum, r) => sum + (trendConfig.modalityWeights[r['Modalit√© d\'√©coulement'].toLowerCase()] || 1.5), 0);
                return totalWeight / recs.length;
            };

            const currentWeight = calculateAverageWeight(currentRecords);
            const previousWeight = previousYear ? calculateAverageWeight(previousRecords) : currentWeight;

            const tooltipParts = [];
            if (currentYear) {
                tooltipParts.push(`${currentYear}: ${Object.entries(currentPercentages)
                    .filter(([_, percent]) => percent > 0)
                    .map(([modality, percent]) => `${modality} ${percent}%`)
                    .join(', ')}`);
            }
            if (previousYear && previousRecords.length > 0) {
                tooltipParts.push(`${previousYear}: ${Object.entries(previousPercentages)
                    .filter(([_, percent]) => percent > 0)
                    .map(([modality, percent]) => `${modality} ${percent}%`)
                    .join(', ')}`);
            }
            const tooltip = tooltipParts.join(' | ');

            const weightDiff = currentWeight - previousWeight;
            if (!previousYear || previousRecords.length === 0) {
                return { trend: '‚Üî', trendClass: 'trend-stable', tooltip };
            }
            if (weightDiff > 0.5) {
                return { trend: '‚Üò', trendClass: 'trend-down', tooltip }; // D√©gradation
            } else if (weightDiff < -0.5) {
                return { trend: '‚Üó', trendClass: 'trend-up', tooltip }; // Am√©lioration
            } else {
                return { trend: '‚Üî', trendClass: 'trend-stable', tooltip }; // Stable
            }
        }

        async function fetchWeather(lat, lon) {
            const cacheKey = `weather_${lat}_${lon}`;
            const cacheTimeKey = `${cacheKey}_time`;
            const cachedData = localStorage.getItem(cacheKey);
            const cachedTime = localStorage.getItem(cacheTimeKey);
            const now = Date.now();
            if (cachedData && cachedTime && now - parseInt(cachedTime) < 3600000) { // 1 hour cache
                return JSON.parse(cachedData);
            }

            try {
                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=temperature_2m_mean,precipitation_sum&forecast_days=7`);
                const data = await response.json();
                const forecast = {
                    daily: data.daily,
                    cumulativeRain: data.daily.precipitation_sum.reduce((sum, val) => sum + val, 0).toFixed(2),
                    avgTemp: (data.daily.temperature_2m_mean.reduce((sum, val) => sum + val, 0) / data.daily.temperature_2m_mean.length).toFixed(1),
                    time: data.daily.time
                };
                localStorage.setItem(cacheKey, JSON.stringify(forecast));
                localStorage.setItem(cacheTimeKey, now.toString());
                return forecast;
            } catch (error) {
                console.error('Erreur fetch m√©t√©o:', error);
                return null;
            }
        }

        async function fetchHubEauStations(lat, lon) {
            const bboxSize = 0.1; // Approximate 10km radius
            const bbox = `${lon - bboxSize},${lat - bboxSize},${lon + bboxSize},${lat + bboxSize}`;
            const url = `https://hubeau.eaufrance.fr/api/v2/hydrometrie/referentiel/stations?bbox=${bbox}&fields=code_station,libelle_station`;
            try {
                const data = await fetchViaProxy(url);
                return data.data || [];
            } catch (error) {
                console.error('Erreur fetch stations Hub\'Eau:', error);
                return [];
            }
        }

        async function fetchHubEauDebits(codeStation, dateDebut, dateFin) {
            const url = `https://hubeau.eaufrance.fr/api/v2/hydrometrie/observations_tr?code_entite=${codeStation}&grandeur_hydro=Q&date_debut_obs=${dateDebut}&date_fin_obs=${dateFin}&fields=date_obs,resultat_obs&size=100`;
            try {
                const data = await fetchViaProxy(url);
                if (!data.data || data.data.length === 0) {
                    return { avgDebit: null, recentDebit: null, debits: [], dates: [] };
                }
                const debits = data.data.map(d => d.resultat_obs / 1000); // Convert l/s to m¬≥/s
                const avgDebit = debits.length > 0 ? debits.reduce((sum, v) => sum + v, 0) / debits.length : null;
                const recentDebit = debits.length > 0 ? debits[debits.length - 1] : null;
                return { avgDebit, recentDebit, debits, dates: data.data.map(d => d.date_obs) };
            } catch (error) {
                console.error('Erreur fetch d√©bits Hub\'Eau:', error);
                return { avgDebit: null, recentDebit: null, debits: [], dates: [] };
            }
        }

        async function fetchDebitsForStation(station, lat, lon, dateDebut, dateFin) {
            const cacheKey = `hubeau_${station}_${dateDebut}_${dateFin}`;
            const cachedData = localStorage.getItem(cacheKey);
            if (cachedData) return JSON.parse(cachedData);

            let codeStation = stationHubCodes[station]; // On utilise d'abord le code si on l'a

            // Si on n'a pas le code, on le cherche par le nom de la station
            if (!codeStation) {
                const stationsUrl = `https://hubeau.eaufrance.fr/api/v2/hydrometrie/referentiel/stations?libelle_station=${encodeURIComponent(station)}&size=1`;
                const stationsData = await fetchViaProxy(stationsUrl);

                if (stationsData && stationsData.data && stationsData.data.length > 0) {
                    codeStation = stationsData.data[0].code_station;
                    stationHubCodes[station] = codeStation; // On le met en cache pour la prochaine fois
                } else {
                    console.log(`Aucune station Hub'Eau trouv√©e pour ${station}`);
                    return { avgDebit: 'N/A', recentDebit: 'N/A' };
                }
            }

            const debitsData = await fetchHubEauDebits(codeStation, dateDebut, dateFin);
            localStorage.setItem(cacheKey, JSON.stringify(debitsData));
            return debitsData;
        }

        // New: Fetch for extended data
        async function fetchPiezo(station, lat, lon, dateDebut, dateFin) {
            const bbox = getBbox(lat, lon, 0.05);
            const url = `https://hubeau.eaufrance.fr/api/v1/niveaux_nappes/chroniques?bbox=${bbox}&code_departement=40&size=20&sort=desc&date_debut_mesure=${dateDebut}&date_fin_mesure=${dateFin}`;
            const cacheKey = `piezo_${station}`;
            const cached = localStorage.getItem(cacheKey);
            if (cached) return JSON.parse(cached);
            const data = await fetchViaProxy(url);
            if (data && data.data) {
                piezoData[station] = data.data.map(d => ({ niveau: d.mesure_nappe, date: d.date_mesure, code_bss: d.code_bss }));
                localStorage.setItem(cacheKey, JSON.stringify(piezoData[station]));
            }
            return piezoData[station];
        }

        async function fetchPrelev(station, lat, lon) {
            const bbox = getBbox(lat, lon, 0.05);
            const url = `https://hubeau.eaufrance.fr/api/v1/prelevements/chroniques?bbox=${bbox}&code_departement=40&size=20&annee=2023`;
            const cacheKey = `prelev_${station}`;
            const cached = localStorage.getItem(cacheKey);
            if (cached) return JSON.parse(cached);
            const data = await fetchViaProxy(url);
            if (data && data.data) {
                prelevData[station] = data.data.map(d => ({ volume: d.volume_annuel, nature: d.nature_prelevement, coords: { lat: d.latitude, lon: d.longitude } }));
                localStorage.setItem(cacheKey, JSON.stringify(prelevData[station]));
            }
            return prelevData[station];
        }

        async function fetchMasses(station, lat, lon) {
            const bbox = getBbox(lat, lon, 0.05);
            const url = `https://hubeau.eaufrance.fr/api/v1/qualite_rivieres/station_pc?bbox=${bbox}&code_departement=40&size=20`;
            const cacheKey = `masses_${station}`;
            const cached = localStorage.getItem(cacheKey);
            if (cached) return JSON.parse(cached);
            const data = await fetchViaProxy(url);
            if (data && data.data) {
                massesData[station] = data.data.map(d => ({ libelle: d.libelle_station, etat: d.etat_masse_eau, coords: { lat: d.latitude, lon: d.longitude } }));
                localStorage.setItem(cacheKey, JSON.stringify(massesData[station]));
            }
            return massesData[station];
        }

        async function fetchBassins(station, lat, lon) {
            const url = `https://hubeau.eaufrance.fr/api/v1/referentiel/bassins?code_departement=40&format=geojson`;
            const cacheKey = `bassins_${station}`;
            const cached = localStorage.getItem(cacheKey);
            if (cached) return JSON.parse(cached);
            const data = await fetchViaProxy(url);
            if (data && data.features) {
                bassinsData[station] = findBassinForPoint(data.features, lat, lon);
                localStorage.setItem(cacheKey, JSON.stringify(bassinsData[station]));
            }
            return bassinsData[station];
        }

        function getBbox(lat, lon, size) {
            return `${lon - size},${lat - size},${lon + size},${lat + size}`;
        }

        function findBassinForPoint(features, lat, lon) {
            const point = turf.point([lon, lat]);
            const bassin = features.find(f => turf.booleanPointInPolygon(point, f));
            return bassin ? bassin.properties : null;
        }

        function calculateProjection(lastModality, forecast, recentDebit, entity) {
            if (!forecast) return { risk: 0, class: 'projection-low', text: 'Indisponible', tooltip: 'Pr√©visions m√©t√©o indisponibles', rain: 'N/A', temp: 'N/A', daily: { temperature_2m_mean: [], precipitation_sum: [], time: [] } , score: 0 };

            const weight = trendConfig.modalityWeights[lastModality.toLowerCase()] || 1.5;
            const rain = parseFloat(forecast.cumulativeRain);
            const temp = parseFloat(forecast.avgTemp);

            let risk = (weight * 50) + ((10 - rain) * 5) + (temp - 15) * 2;
            if (includeHubEau && recentDebit !== null) {
                risk += (trendConfig.debitThreshold - recentDebit) * 10;
            }
            if (includeExtended) {
                // New correlations
                const piezo = piezoData[entity]?.[0]?.niveau || 10;
                const prelev = prelevData[entity]?.reduce((sum, p) => sum + p.volume, 0) || 0;
                const masseEtat = massesData[entity]?.[0]?.etat === 'Mauvais' ? 10 : 0;
                risk += (trendConfig.nappeThreshold - piezo) * 3; // Low nappe increases risk
                risk += (prelev > trendConfig.prelevThreshold ? 20 : 0); // High prelev increases risk
                risk += masseEtat;
            }
            risk = Math.max(0, Math.min(100, risk));

            let className, text;
            if (risk > 70) {
                className = 'projection-high';
                text = 'D√©gradation probable';
            } else if (risk > 30) {
                className = 'projection-medium';
                text = 'Stable avec vigilance';
            } else {
                className = 'projection-low';
                text = 'Am√©lioration possible';
            }

            const tooltip = `Risque ${risk.toFixed(0)}% : Pluie cumul√©e ${rain}mm, Temp moy ${temp}¬∞C. Bas√© sur √©tat "${lastModality}".`;
            return { risk, class: className, text, tooltip, rain, temp, daily: forecast.daily, time: forecast.time, score: risk };
        }

        async function getWeatherForEntity(entity, isGroup) {
            let lat, lon;
            if (isGroup) {
                const groupStations = stationGroups[entity];
                let sumLat = 0, sumLon = 0, count = 0;
                groupStations.forEach(st => {
                    const coord = stationCoordinates[st];
                    if (coord) {
                        sumLat += coord.lat;
                        sumLon += coord.lon;
                        count++;
                    }
                });
                if (count === 0) return null;
                lat = sumLat / count;
                lon = sumLon / count;
            } else {
                const coord = stationCoordinates[entity];
                if (!coord) return null;
                lat = coord.lat;
                lon = coord.lon;
            }
            return await fetchWeather(lat, lon);
        }

        async function updateTrendTable() {
            const tbody = document.querySelector('#trendTable tbody');
            tbody.innerHTML = '';
            projections = []; // Reset projections

            const filteredData = getFilteredData();
            if (filteredData.length === 0) {
                tbody.innerHTML = `<tr><td colspan="14" class="p-3 text-center border">Aucune donn√©e disponible pour les filtres s√©lectionn√©s.</td></tr>`;
                return;
            }

            const selections = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);
            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => parseInt(opt.value));
            const comparePrevious = comparePreviousYear;

            let stations = [];
            selections.forEach(selection => {
                if (selection.startsWith('group:')) {
                    const groupName = selection.replace('group:', '');
                    if (stationGroups[groupName]) stations.push(...stationGroups[groupName]);
                } else {
                    stations.push(selection);
                }
            });

            const stationStats = {};
            const allDataForStations = comparePrevious ? data.filter(d => stations.length === 0 || stations.includes(d['Station d\'√©coulement'])) : filteredData;
            allDataForStations.forEach(d => {
                const station = d['Station d\'√©coulement'];
                const date = new Date(d['Date de la campagne']);
                if (!stationStats[station]) {
                    stationStats[station] = [];
                }
                stationStats[station].push({ ...d, DateObj: date });
            });

            const groupStats = {};
            Object.keys(stationGroups).forEach(group => {
                groupStats[group] = [];
                const groupStations = stationGroups[group];
                (comparePrevious ? data : filteredData).forEach(d => {
                    if (groupStations.includes(d['Station d\'√©coulement'])) {
                        groupStats[group].push({ ...d, DateObj: new Date(d['Date de la campagne']) });
                    }
                });
            });

            const rows = [];
            const variationList = [];
            const degradedList = [];
            const recurringList = [];

            const addRow = async (entity, records, isGroup = false) => {
                let sortedRecords, selectedYear, previousYear, dates, modalities, trendData;

                if (comparePrevious) {
                    const availableYears = [...new Set(records.map(r => new Date(r['Date de la campagne']).getFullYear()))].sort((a, b) => b - a);
                    selectedYear = years.length > 0 && years[0] !== NaN ? years[0] : availableYears[0];
                    previousYear = selectedYear ? selectedYear - 1 : availableYears[1] || null;

                    sortedRecords = records.filter(r => {
                        const year = new Date(r['Date de la campagne']).getFullYear();
                        return year === selectedYear || (previousYear && year === previousYear);
                    }).sort((a, b) => b.DateObj - a.DateObj);

                    if (sortedRecords.length === 0) {
                        const rowHtml = `
                            <td class="p-3 border"><strong>${isGroup ? `Groupe: ${entity}` : entity}</strong></td>
                            <td class="p-3 border">0</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border trend-stable" data-tooltip="Aucune donn√©e disponible">‚Üî</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">Aucune donn√©e pour ${selectedYear}${previousYear ? ` ou ${previousYear}` : ''}.</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">0</td>
                        `;
                        rows.push({ html: rowHtml, score: 0 });
                        return;
                    }

                    const currentRecords = sortedRecords.filter(r => new Date(r['Date de la campagne']).getFullYear() === selectedYear);
                    const previousRecords = previousYear ? sortedRecords.filter(r => new Date(r['Date de la campagne']).getFullYear() === previousYear) : [];

                    dates = [];
                    if (currentRecords.length > 0) dates.push(`${selectedYear}`);
                    if (previousRecords.length > 0) dates.push(`${previousYear}`);

                    modalities = [];
                    if (currentRecords.length > 0) {
                        const modalityCounts = {};
                        allModalities.forEach(modality => modalityCounts[modality] = 0);
                        currentRecords.forEach(r => modalityCounts[r['Modalit√© d\'√©coulement']]++);
                        const currentSummary = Object.entries(modalityCounts)
                            .filter(([_, count]) => count > 0)
                            .map(([modality, count]) => `${modality} (${count})`);
                        modalities.push(`${selectedYear}: ${currentSummary.join(', ')}`);
                    }
                    if (previousRecords.length > 0) {
                        const modalityCounts = {};
                        allModalities.forEach(modality => modalityCounts[modality] = 0);
                        previousRecords.forEach(r => modalityCounts[r['Modalit√© d\'√©coulement']]++);
                        const previousSummary = Object.entries(modalityCounts)
                            .filter(([_, count]) => count > 0)
                            .map(([modality, count]) => `${modality} (${count})`);
                        modalities.push(`${previousYear}: ${previousSummary.join(', ')}`);
                    }

                    trendData = calculateTrend(records, selectedYear, previousYear);
                } else {
                    sortedRecords = records.sort((a, b) => b.DateObj - a.DateObj).slice(0, 2);
                    selectedYear = sortedRecords[0] ? new Date(sortedRecords[0]['Date de la campagne']).getFullYear() : null;
                    previousYear = sortedRecords[1] ? new Date(sortedRecords[1]['Date de la campagne']).getFullYear() : null;

                    if (sortedRecords.length < trendConfig.minObservations) {
                        const rowHtml = `
                            <td class="p-3 border"><strong>${isGroup ? `Groupe: ${entity}` : entity}</strong></td>
                            <td class="p-3 border">${sortedRecords.length}</td>
                            <td class="p-3 border">${sortedRecords.map(r => r['Date de la campagne']).join(', ')}</td>
                            <td class="p-3 border">${sortedRecords.map(r => r['Modalit√© d\'√©coulement']).join(', ')}</td>
                            <td class="p-3 border trend-stable" data-tooltip="Donn√©es insuffisantes pour la comparaison">‚Üî</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">Au moins 2 relev√©s n√©cessaires pour analyser les tendances.</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">-</td>
                            <td class="p-3 border">0</td>
                        `;
                        rows.push({ html: rowHtml, score: 0 });
                        return;
                    }

                    dates = sortedRecords.map(r => r['Date de la campagne']);
                    modalities = sortedRecords.map(r => r['Modalit√© d\'√©coulement']);
                    trendData = calculateTrend(sortedRecords, selectedYear, previousYear);
                }

                const modalityCounts = {};
                allModalities.forEach(modality => modalityCounts[modality] = 0);
                sortedRecords.forEach(r => modalityCounts[r['Modalit√© d\'√©coulement']]++);

                const totalObs = records.length;
                const isLowFlowStation = !isGroup && isRecurringLowFlow(entity, records);

                let recommendation = '';
                const criticalIndex = allModalities.findIndex(m => m.toLowerCase().includes('assec'));
                const lowIndex = allModalities.findIndex(m => m.toLowerCase().includes('faible'));
                const favorableIndex = allModalities.findIndex(m => m.toLowerCase().includes('acceptable'));

                if (isLowFlowStation) {
                    recommendation = `Station √† faible √©coulement r√©current. Surveillance renforc√©e recommand√©e √† ${entity}.`;
                } else if (sortedRecords.length < trendConfig.minObservations) {
                    recommendation = `Donn√©es insuffisantes (<${trendConfig.minObservations} relev√©s) √† ${entity}. Collecte suppl√©mentaire recommand√©e.`;
                } else if (criticalIndex !== -1 && sortedRecords[0]?.['Modalit√© d\'√©coulement'].toLowerCase().includes('assec') && trendData.trend === '‚Üò') {
                    recommendation = `Alerte : Tendance √† la hausse des niveaux critiques √† ${entity}. Mesures d'urgence recommand√©es.`;
                } else if (favorableIndex !== -1 && sortedRecords[0]?.['Modalit√© d\'√©coulement'].toLowerCase().includes('acceptable') && trendData.trend === '‚Üó') {
                    recommendation = `Situation favorable √† ${entity}. Suivi standard recommand√©.`;
                } else if ((lowIndex !== -1 || criticalIndex !== -1) &&
                            (sortedRecords[0]?.['Modalit√© d\'√©coulement'].toLowerCase().includes('faible') || sortedRecords[0]?.['Modalit√© d\'√©coulement'].toLowerCase().includes('assec'))) {
                    recommendation = `Tendance d√©favorable √† ${entity}. Surveillance renforc√©e recommand√©e.`;
                } else {
                    recommendation = `Situation mod√©r√©e √† ${entity}. Maintenir le suivi standard.`;
                }

                let meteoHtml = '-';
                let projectionHtml = '-';
                let projection = { risk: 0, class: 'projection-low', text: 'Indisponible', tooltip: 'Pr√©visions m√©t√©o indisponibles', rain: 'N/A', temp: 'N/A', daily: { temperature_2m_mean: [], precipitation_sum: [], time: [] } , score: 0 };
                if (includeWeather) {
                    const forecast = await getWeatherForEntity(entity, isGroup);
                    const lastModality = sortedRecords[0] ? sortedRecords[0]['Modalit√© d\'√©coulement'] : 'Inconnu';
                    const recentDebit = hubEauDebits[entity]?.recentDebit || null;
                    projection = calculateProjection(lastModality, forecast, recentDebit, entity);
                    meteoHtml = `Pluie: ${projection.rain}mm, Temp: ${projection.temp}¬∞C`;
                    projectionHtml = `<span class="${projection.class}" data-tooltip="${projection.tooltip}">${projection.text} (${projection.risk}%)</span>`;
                }

                // Corr√©ler recommendation avec projection
                if (projection.risk > 70) {
                    recommendation += ` Alerte m√©t√©o : Risque √©lev√© de d√©gradation en raison des pr√©visions (pluie faible, temp √©lev√©e). Mesures pr√©ventives urgentes recommand√©es.`;
                } else if (projection.risk > 30) {
                    recommendation += ` Vigilance m√©t√©o : Risque mod√©r√© ; surveillez les √©volutions bas√©es sur √©tat "${sortedRecords[0]?.['Modalit√© d\'√©coulement']}" et pr√©visions.`;
                } else if (projection.risk > 0) {
                    recommendation += ` Pr√©visions favorables : Am√©lioration probable avec pluie pr√©vue ; maintien du suivi.`;
                } else {
                    recommendation += ` Pr√©visions indisponibles ; basez-vous sur √©tat actuel.`;
                }

                let debitHtml = '-';
                let debitData = { avgDebit: 'N/A', recentDebit: 'N/A' };
                if (includeHubEau) {
                    const coord = stationCoordinates[entity];
                    const dateFin = new Date().toISOString().split('T')[0];
                    const dateDebut = new Date();
                    dateDebut.setDate(dateDebut.getDate() - 30);
                    dateDebut = dateDebut.toISOString().split('T')[0]; // Derniers 30 jours
                    debitData = await fetchDebitsForStation(entity, coord ? coord.lat : null, coord ? coord.lon : null, dateDebut, dateFin);
                    hubEauDebits[entity] = debitData;
                    debitHtml = (typeof debitData.avgDebit === 'number') ? debitData.avgDebit.toFixed(2) : debitData.avgDebit || 'N/A';
                    if (typeof debitData.avgDebit === 'number' && debitData.avgDebit < trendConfig.debitThreshold) {
                        recommendation += ` Alerte d√©bit faible : D√©bit moyen ${debitHtml} m¬≥/s. Surveillance renforc√©e.`;
                    }

                    // Validation incoh√©rence
                    const lastModality = sortedRecords[0]?.['Modalit√© d\'√©coulement'].toLowerCase() || '';
                    if (lastModality.includes('assec') && typeof debitData.recentDebit === 'number' && debitData.recentDebit > 0) {
                        recommendation += ` Incoh√©rence : Assec d√©clar√© mais d√©bit positif (${debitData.recentDebit.toFixed(2)} m¬≥/s). V√©rifier donn√©es.`;
                    } else if (lastModality.includes('acceptable') && typeof debitData.recentDebit === 'number' && debitData.recentDebit < trendConfig.debitThreshold) {
                        recommendation += ` Incoh√©rence : √âcoulement acceptable mais d√©bit faible (${debitData.recentDebit.toFixed(2)} m¬≥/s). V√©rifier donn√©es.`;
                    }
                }

                let nappeHtml = '-';
                let prelevHtml = '-';
                let masseHtml = '-';
                let bassinHtml = '-';
                if (includeExtended) {
                    const coord = stationCoordinates[entity];
                    const dateFin = new Date().toISOString().split('T')[0];
                    const dateDebut = new Date();
                    dateDebut.setDate(dateDebut.getDate() - 30);
                    dateDebut = dateDebut.toISOString().split('T')[0];
                    const [piezo, prelev, masses, bassins] = await Promise.all([
                        fetchPiezo(entity, coord.lat, coord.lon, dateDebut, dateFin),
                        fetchPrelev(entity, coord.lat, coord.lon),
                        fetchMasses(entity, coord.lat, coord.lon),
                        fetchBassins(entity, coord.lat, coord.lon)
                    ]);
                    nappeHtml = piezo?.[0]?.niveau || 'N/A';
                    prelevHtml = prelev?.reduce((sum, p) => sum + p.volume, 0) || 'N/A';
                    masseHtml = masses?.[0]?.etat || 'N/A';
                    bassinHtml = bassins?.code_bassin || 'N/A';
                    if (piezo?.[0]?.niveau < trendConfig.nappeThreshold) recommendation += ` Alerte nappe basse: ${nappeHtml}m.`;
                    if (prelevHtml > trendConfig.prelevThreshold) recommendation += ` Alerte pr√©l√®vement √©lev√©: ${prelevHtml} m¬≥.`;
                }

                const rowHtml = `
                    <td class="p-3 border"><strong>${isGroup ? `Groupe: ${entity}` : entity}${isLowFlowStation ? ' (Faible r√©current)' : ''}</strong></td>
                    <td class="p-3 border">${totalObs}</td>
                    <td class="p-3 border">${dates.join(', ')}</td>
                    <td class="p-3 border">${modalities.join(', ')}</td>
                    <td class="p-3 border ${trendData.trendClass}" data-tooltip="${trendData.tooltip}">${trendData.trend}</td>
                    <td class="p-3 border">${meteoHtml}</td>
                    <td class="p-3 border">${projectionHtml}</td>
                    <td class="p-3 border">${recommendation}</td>
                    <td class="p-3 border">${debitHtml}</td>
                    <td class="p-3 border">${nappeHtml}</td>
                    <td class="p-3 border">${prelevHtml}</td>
                    <td class="p-3 border">${masseHtml}</td>
                    <td class="p-3 border">${bassinHtml}</td>
                    <td class="p-3 border">${projection.score.toFixed(0)}</td>
                `;
                const variation = calculateVariationScore(records, years);
                const recurrence = isLowFlowStation ? 1 : 0;
                const lastWeight = trendConfig.modalityWeights[sortedRecords[0]?.['Modalit√© d\'√©coulement'].toLowerCase()] || 1.5;
                const risk = projection.risk;
                const score = variation * 0.2 + recurrence * 50 + lastWeight * 10 + risk * 0.5;

                rows.push({ html: rowHtml, score, forecast: projection.daily });
                if (!isGroup) {
                    const degraded = calculateDegradedPercentage(records, years).percentage;
                    const isRecurring = isLowFlowStation;
                    variationList.push(variation);
                    degradedList.push(degraded);
                    recurringList.push(isRecurring);
                    projections.push({
                        entity: entity,
                        risk: projection.risk,
                        color: projection.class === 'projection-high' ? '#ef4444' : projection.class === 'projection-medium' ? '#f59e0b' : projection.class === 'projection-low' ? '#22c55e' : '#6b7280',
                        text: projection.text,
                        lastModality: sortedRecords[0] ? sortedRecords[0]['Modalit√© d\'√©coulement'] : 'Inconnu',
                        trend: trendData.trend,
                        lastDate: sortedRecords[0] ? sortedRecords[0]['Date de la campagne'] : 'N/A',
                        rain: projection.rain,
                        temp: projection.temp,
                        recommendation: recommendation,
                        degradedPct: degraded,
                        variation: variation,
                        isRecurring: isRecurring,
                        avgDebit: debitData.avgDebit,
                        nappe: nappeHtml,
                        prelev: prelevHtml,
                        masse: masseHtml,
                        bassin: bassinHtml,
                        score: projection.score
                    });
                }
            };
            if (stations.length > 0 && stations[0] !== '') {
                for (const station of stations) {
                    if (stationStats[station]) {
                        await addRow(station, stationStats[station]);
                    } else {
                        const rowHtml = `<td class="p-3 border"><strong>${station}</strong></td><td colspan="13" class="p-3 text-center border">Aucune donn√©e pour cette station.</td>`;
                        rows.push({ html: rowHtml, score: 0 });
                    }
                }
            } else {
                for (const station of Object.keys(stationStats)) {
                    await addRow(station, stationStats[station]);
                }
            }

            for (const group of Object.keys(groupStats)) {
                if (selections.includes(`group:${group}`)) {
                    if (groupStats[group].length > 0) {
                        await addRow(group, groupStats[group], true);
                    } else {
                        const rowHtml = `<td class="p-3 border"><strong>Groupe: ${group}</strong></td><td colspan="13" class="p-3 text-center border">Aucune donn√©e pour ce groupe.</td>`;
                        rows.push({ html: rowHtml, score: 0 });
                    }
                }
            }

            if (rows.length === 0) {
                tbody.innerHTML = `<tr><td colspan="14" class="p-3 text-center border">Aucune donn√©es disponible pour les filtres s√©lectionn√©s. Essayez de r√©initialiser les filtres.</td></tr>`;
                return;
            }

            // Sort rows by score descending (most likely to degrade first)
            rows.sort((a, b) => b.score - a.score);

            rows.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = row.html;
                tr.className = row.score > 50 ? 'trend-down-row' : ''; // Highlight high risk
                tr.dataset.forecast = JSON.stringify(row.forecast || {});
                tr.style.cursor = 'pointer';
                tr.onclick = () => showForecastModal(row.forecast || {});
                tbody.appendChild(tr);
            });

            // Calculate global Spearman
            const spearman = calculateSpearman(variationList, degradedList);

            // Add sensitivityScore to projections
            projections.forEach(p => {
                p.sensitivityScore = (p.degradedPct * 0.4) + (p.variation * 0.3) + (p.isRecurring ? 30 : 0) + (spearman > 0.5 ? spearman * 30 : 0);
                p.sensitivityScore = Math.max(0, Math.min(100, p.sensitivityScore));
            });
        }

        // ML Prediction Button
        document.getElementById('predictML').addEventListener('click', async () => {
            const xs = tf.tensor2d(projections.map(p => [p.risk, p.nappe || 0, p.prelev || 0])); // Inputs: risk, nappe, prelev
            const ys = tf.tensor2d(projections.map(p => [p.score / 100])); // Output: score normalis√©
            const model = tf.sequential();
            model.add(tf.layers.dense({ units: 1, inputShape: [3] }));
            model.compile({ optimizer: 'sgd', loss: 'meanSquaredError' });
            await model.fit(xs, ys, { epochs: 100 });
            projections.forEach(async (p, i) => {
                const input = tf.tensor2d([[p.risk, p.nappe || 0, p.prelev || 0]]);
                const pred = (await model.predict(input).dataSync()[0]) * 100;
                // Update table row (ex. find row and append pred)
                const rows = document.querySelectorAll('#trendTable tbody tr');
                rows[i].lastChild.textContent = pred.toFixed(0); // Update score with pred
            });
            showStatus('Pr√©dictions ML termin√©es ! Scores mis √† jour.', 'success');
        });

        function showForecastModal(daily) {
            document.getElementById('forecastModal').style.display = 'block';
            const chartDom = document.getElementById('forecastChart');
            const chart = echarts.init(chartDom);
            const option = {
                tooltip: { trigger: 'axis' },
                legend: { data: ['Temp (¬∞C)', 'Pluie (mm)'] },
                xAxis: { type: 'category', data: daily.time || [] },
                yAxis: { type: 'value' },
                series: [
                    { name: 'Temp (¬∞C)', type: 'line', data: daily.temperature_2m_mean || [] },
                    { name: 'Pluie (mm)', type: 'bar', data: daily.precipitation_sum || [] }
                ],
                toolbox: { feature: { saveAsImage: {}, dataZoom: {} } }
            };
            chart.setOption(option);
        }

        function calculateInterAnnualVariance(filteredData) {
            const yearlyWeights = {};
            filteredData.forEach(d => {
                const year = new Date(d['Date de la campagne']).getFullYear();
                const weight = trendConfig.modalityWeights[d['Modalit√© d\'√©coulement'].toLowerCase()] || 1.5;
                if (!yearlyWeights[year]) yearlyWeights[year] = [];
                yearlyWeights[year].push(weight);
            });

            const years = Object.keys(yearlyWeights).sort();
            if (years.length < 2) return 'N/A (Donn√©es insuffisantes pour variance)';

            const averages = years.map(year => {
                const weights = yearlyWeights[year];
                return weights.reduce((sum, w) => sum + w, 0) / weights.length;
            });

            const meanAvg = averages.reduce((sum, a) => sum + a, 0) / averages.length;
            const variance = averages.reduce((sum, a) => sum + Math.pow(a - meanAvg, 2), 0) / (averages.length - 1);
            return variance.toFixed(2);
        }

        function calculateSpearman(variationData, degradedData) {
            if (variationData.length !== degradedData.length || variationData.length < 2) return 0;

            const n = variationData.length;
            const ranksVar = variationData.map((v, i) => ({ v, i })).sort((a, b) => b.v - a.v).map((item, rank) => ({ i: item.i, rank: rank + 1 }));
            const ranksDeg = degradedData.map((v, i) => ({ v, i })).sort((a, b) => b.v - a.v).map((item, rank) => ({ i: item.i, rank: rank + 1 }));

            let sumDiff = 0;
            for (let i = 0; i < n; i++) {
                const rankVar = ranksVar.find(r => r.i === i).rank;
                const rankDeg = ranksDeg.find(r => r.i === i).rank;
                sumDiff += Math.pow(rankVar - rankDeg, 2);
            }
            return (1 - (6 * sumDiff) / (n * (n*n - 1)));
        }

        function updateSummaryStats(filteredData) {
            const totalObs = filteredData.length;
            const stations = [...new Set(filteredData.map(d => d['Station d\'√©coulement']))];
            const modalityCounts = {};
            allModalities.forEach(modality => {
                modalityCounts[modality] = filteredData.filter(d => d['Modalit√© d\'√©coulement'] === modality).length;
            });

            const statsContainer = document.getElementById('summaryStats');
            statsContainer.innerHTML = `
                <div class="stat-card bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border-l-4 border-[#00a3a6]">
                    <div class="flex items-center gap-3">
                        <svg class="w-8 h-8 text-[#005566]" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2a10 10 0 100 20 10 10 0 000-20zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></svg>
                        <div>
                            <div class="text-2xl font-bold text-gray-800 dark:text-gray-100">${totalObs}</div>
                            <div class="text-sm text-gray-500 dark:text-gray-400">Total Observations</div>
                        </div>
                    </div>
                </div>
                <div class="stat-card bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border-l-4 border-[#00a3a6]">
                    <div class="flex items-center gap-3">
                        <svg class="w-8 h-8 text-[#005566]" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2a10 10 0 100 20 10 10 0 000-20zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></svg>
                        <div>
                            <div class="text-2xl font-bold text-gray-800 dark:text-gray-100">${stations.length}</div>
                            <div class="text-sm text-gray-500 dark:text-gray-400">Stations Actives</div>
                        </div>
                    </div>
                </div>
                ${allModalities.map(modality => {
                    const percent = totalObs > 0 ? Math.round((modalityCounts[modality] / totalObs) * 100) : 0;
                    return percent > 0 ? `
                        <div class="stat-card bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border-l-4 border-[#00a3a6]">
                            <div class="flex items-center gap-3">
                                <svg class="w-8 h-8 text-[#005566]" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2a10 10 0 100 20 10 10 0 000-20zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></svg>
                                <div>
                                    <div class="text-2xl font-bold text-gray-800 dark:text-gray-100">${percent}%</div>
                                    <div class="text-sm text-gray-500 dark:text-gray-400">% ${modality}</div>
                                </div>
                            </div>
                        </div>
                    ` : '';
                }).join('')}
            `;
        }

        function updateCharts(filteredData) {
            if (filteredData.length === 0) return;
            updateStationChart(filteredData);
            updateModalityChart(filteredData);
            updateYearlyTrendChart(filteredData);
            updateStationTrendChart(filteredData);
        }

        function updateStationChart(filteredData) {
            const chartDom = document.getElementById('stationChart');
            if (charts.station) charts.station.dispose();
            charts.station = echarts.init(chartDom, null, { renderer: 'canvas' });
            const modalityColors = generateDynamicColors(allModalities);

            const stationData = {};
            filteredData.forEach(d => {
                const station = d['Station d\'√©coulement'];
                const modality = d['Modalit√© d\'√©coulement'];
                if (!stationData[station]) {
                    stationData[station] = { Total: 0, modalities: {} };
                    allModalities.forEach(modality => stationData[station].modalities[modality] = 0);
                }
                stationData[station].Total++;
                stationData[station].modalities[modality]++;
            });

            const stations = Object.keys(stationData).sort((a, b) => {
                const primaryModality = allModalities[0] || 'Inconnu';
                const percentA = stationData[a].Total > 0 ? (stationData[a].modalities[primaryModality] / stationData[a].Total) * 100 : 0;
                const percentB = stationData[b].Total > 0 ? (stationData[b].modalities[primaryModality] / stationData[b].Total) * 100 : 0;
                return percentB - percentA;
            });

            if (stations.length === 0) return;

            const series = allModalities.map(modality => ({
                name: modality,
                type: 'bar',
                stack: 'total',
                data: stations.map(station => {
                    const percent = stationData[station].Total > 0 ? Math.round((stationData[station].modalities[modality] / stationData[station].Total) * 100) : 0;
                    return { value: percent, itemStyle: { color: modalityColors[modality.toLowerCase()] } };
                }),
                label: {
                    show: true,
                    position: 'inside',
                    formatter: params => params.value > 0 ? `${params.value}%` : ''
                },
                itemStyle: { color: modalityColors[modality.toLowerCase()] }
            }));

            charts.station.setOption({
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'shadow' },
                    formatter: params => {
                        const station = params[0].axisValue;
                        let result = `<strong>${station}</strong><br/>`;
                        params.forEach(p => {
                            const value = stationData[station].modalities[p.seriesName];
                            const percent = stationData[station].Total > 0 ? Math.round((value / stationData[station].Total) * 100) : 0;
                            if (percent > 0) result += `${p.seriesName}: ${value} (${percent}%)<br/>`;
                        });
                        return result;
                    }
                },
                legend: {
                     top: '0',
                     orient: 'horizontal',
                     textStyle: { color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' },
                    data: allModalities.map(modality => ({
                        name: modality,
                        icon: 'circle',
                        itemStyle: { color: modalityColors[modality.toLowerCase()] }
                    }))
                },
                grid: { left: '3%', right: '4%', bottom: '15%', containLabel: true, top: '20%' },
                xAxis: { type: 'category', data: stations, axisLabel: { rotate: 45, color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' } },
                yAxis: { type: 'value', max: 100, axisLabel: { formatter: '{value}%', color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' } },
                series: series,
                toolbox: { feature: { saveAsImage: {}, dataZoom: {} } }
            });
        }

        function updateModalityChart(filteredData) {
            const chartDom = document.getElementById('modalityChart');
            if (charts.modality) charts.modality.dispose();
            charts.modality = echarts.init(chartDom, null, { renderer: 'canvas' });
            const modalityColors = generateDynamicColors(allModalities);

            const modalityCounts = {};
            allModalities.forEach(modality => {
                modalityCounts[modality] = filteredData.filter(d => d['Modalit√© d\'√©coulement'] === modality).length;
            });
            const total = filteredData.length;

            if (total === 0) return;

            charts.modality.setOption({
                tooltip: { trigger: 'item', formatter: params => params.value > 0 ? `${params.name}: ${params.value} (${Math.round(params.percent)}%)` : '' },
                legend: { top: '0', orient: 'horizontal', textStyle: { color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' }, data: allModalities.map(modality => ({
                        name: modality,
                        icon: 'circle',
                        itemStyle: { color: modalityColors[modality.toLowerCase()] }
                    })) },
                series: [{
                    name: 'Modalit√©s',
                    type: 'pie',
                    radius: ['40%', '70%'],
                    center: ['50%', '60%'],
                    data: allModalities.map(modality => ({
                        value: modalityCounts[modality],
                        name: modality,
                        itemStyle: { color: modalityColors[modality.toLowerCase()] }
                    })).filter(d => d.value > 0),
                    label: {
                        formatter: params => params.percent > 0 ? `${params.name}: ${Math.round(params.percent)}%` : '',
                        fontSize: 14,
                        color: document.documentElement.classList.contains('dark') ? '#fff' : '#000'
                    }
                }],
                toolbox: { feature: { saveAsImage: {}, dataZoom: {} } }
            });
        }

        function updateYearlyTrendChart(filteredData) {
            const chartDom = document.getElementById('yearlyTrendChart');
            if (charts.yearlyTrend) charts.yearlyTrend.dispose();
            charts.yearlyTrend = echarts.init(chartDom, null, { renderer: 'canvas' });
            const modalityColors = generateDynamicColors(allModalities);

            const yearlyData = {};
            filteredData.forEach(d => {
                const year = new Date(d['Date de la campagne']).getFullYear();
                const modality = d['Modalit√© d\'√©coulement'];
                if (!yearlyData[year]) {
                    yearlyData[year] = { Total: 0, modalities: {} };
                    allModalities.forEach(modality => yearlyData[year].modalities[modality] = 0);
                }
                yearlyData[year].Total++;
                yearlyData[year].modalities[modality]++;
            });

            const sortedYears = Object.keys(yearlyData).sort();
            if (sortedYears.length === 0) return;

            const series = allModalities.map(modality => ({
                name: modality,
                type: 'line',
                stack: 'total',
                areaStyle: { opacity: 0.3 },
                smooth: true,
                data: sortedYears.map(year => {
                    const percent = yearlyData[year].Total > 0 ? Math.round((yearlyData[year].modalities[modality] / yearlyData[year].Total) * 100) : 0;
                    return { value: percent, itemStyle: { color: modalityColors[modality.toLowerCase()] } };
                }),
                label: {
                    show: true,
                    position: 'top',
                    formatter: params => params.value > 0 ? `${params.value}%` : ''
                },
                itemStyle: { color: modalityColors[modality.toLowerCase()] },
                lineStyle: { color: modalityColors[modality.toLowerCase()] },
                areaStyle: { color: modalityColors[modality.toLowerCase()] }
            }));

            if (includeHubEau) {
                series.push({
                    name: 'D√©bit Moyen (m¬≥/s)',
                    type: 'line',
                    yAxisIndex: 1,
                    data: sortedYears.map(year => {
                        let totalDebit = 0, count = 0;
                        Object.keys(hubEauDebits).forEach(st => {
                            if (hubEauDebits[st].dates.some(d => new Date(d).getFullYear() === year)) {
                                const yearDebits = hubEauDebits[st].debits.filter((_, i) => new Date(hubEauDebits[st].dates[i]).getFullYear() === year);
                                if (yearDebits.length > 0) {
                                    totalDebit += yearDebits.reduce((sum, v) => sum + v, 0) / yearDebits.length;
                                    count++;
                                }
                            }
                        });
                        return count > 0 ? totalDebit / count : 0;
                    }),
                    itemStyle: { color: '#0000FF' },
                    lineStyle: { color: '#0000FF' }
                });
            }

            charts.yearlyTrend.setOption({
                tooltip: {
                    trigger: 'axis',
                    formatter: params => {
                        const year = params[0].axisValue;
                        let result = `<strong>${year}</strong><br/>`;
                        params.forEach(p => {
                            if (p.value > 0) result += `${p.seriesName}: ${p.value}${p.seriesName.includes('D√©bit') ? ' m¬≥/s' : '%'}<br/>`;
                        });
                        return result;
                    }
                },
                legend: {
                     top: '0',
                     orient: 'horizontal',
                     textStyle: { color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' },
                    data: allModalities.map(modality => ({
                        name: modality,
                        icon: 'circle',
                        itemStyle: { color: modalityColors[modality.toLowerCase()] }
                    })).concat(includeHubEau ? [{ name: 'D√©bit Moyen (m¬≥/s)', icon: 'circle', itemStyle: { color: '#0000FF' } }] : [])
                },
                grid: { left: '3%', right: '4%', bottom: '10%', containLabel: true, top: '20%' },
                xAxis: { type: 'category', data: sortedYears, axisLabel: { color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' } },
                yAxis: [
                    { type: 'value', max: 100, axisLabel: { formatter: '{value}%', color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' } },
                    { type: 'value', position: 'right', axisLabel: { formatter: '{value} m¬≥/s', color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' } }
                ],
                series: series,
                toolbox: { feature: { saveAsImage: {}, dataZoom: {} } }
            });
        }

        function updateStationTrendChart(filteredData) {
            const chartDom = document.getElementById('stationTrendChart');
            if (charts.stationTrend) charts.stationTrend.dispose();
            charts.stationTrend = echarts.init(chartDom, null, { renderer: 'canvas' });
            const modalityColors = generateDynamicColors(allModalities);

            const selections = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);
            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => parseInt(opt.value));
            const modality = document.getElementById('modalitySelect').value;

            let stations = [];
            selections.forEach(selection => {
                if (selection.startsWith('group:')) {
                    const groupName = selection.replace('group:', '');
                    if (stationGroups[groupName]) stations.push(...stationGroups[groupName]);
                } else {
                    stations.push(selection);
                }
            });

            let filtered = [...filteredData];
            if (stations.length > 0 && stations[0] !== '') {
                filtered = filtered.filter(d => stations.includes(d['Station d\'√©coulement']));
            }
            if (years.length > 0 && years[0] !== NaN) {
                filtered = filtered.filter(d => years.includes(new Date(d['Date de la campagne']).getFullYear()));
            }

            const yearlyData = {};
            filtered.forEach(d => {
                const year = new Date(d['Date de la campagne']).getFullYear();
                const station = d['Station d\'√©coulement'];
                const modality = d['Modalit√© d\'√©coulement'];
                if (!yearlyData[station]) yearlyData[station] = {};
                if (!yearlyData[station][year]) {
                    yearlyData[station][year] = { Total: 0, modalities: {} };
                    allModalities.forEach(modality => yearlyData[station][year].modalities[modality] = 0);
                }
                yearlyData[station][year].Total++;
                yearlyData[station][year].modalities[modality]++;
            });

            const groupData = {};
            Object.keys(stationGroups).forEach(group => {
                groupData[group] = {};
                const groupStations = stationGroups[group];
                filtered.forEach(d => {
                    if (groupStations.includes(d['Station d\'√©coulement'])) {
                        const year = new Date(d['Date de la campagne']).getFullYear();
                        const modality = d['Modalit√© d\'√©coulement'];
                        if (!groupData[group][year]) {
                            groupData[group][year] = { Total: 0, modalities: {} };
                            allModalities.forEach(modality => groupData[group][year].modalities[modality] = 0);
                        }
                        groupData[group][year].Total++;
                        groupData[group][year].modalities[modality]++;
                    }
                });
            });

            const sortedYears = [...new Set([
                ...Object.values(yearlyData).flatMap(s => Object.keys(s)),
                ...Object.values(groupData).flatMap(g => Object.keys(g))
            ])].sort();

            if (sortedYears.length === 0) return;

            const series = [];
            if (modality && modality !== '') {
                stations.forEach((station, index) => {
                    series.push({
                        name: station,
                        type: 'line',
                        smooth: true,
                        data: sortedYears.map(year => {
                            const percent = yearlyData[station]?.[year]?.Total > 0 ? Math.round((yearlyData[station][year].modalities[modality] / yearlyData[station][year].Total) * 100) : 0;
                            return { value: percent, itemStyle: { color: modalityColors[modality.toLowerCase()] } };
                        }),
                        label: {
                            show: true,
                            position: 'top',
                            formatter: params => params.value > 0 ? `${params.value}%` : ''
                        }
                    });
                });
                Object.keys(groupData).forEach((group, index) => {
                    if (selections.includes(`group:${group}`)) {
                        series.push({
                            name: `Groupe: ${group}`,
                            type: 'line',
                            smooth: true,
                            lineStyle: { width: 4, type: 'dashed' },
                            data: sortedYears.map(year => {
                                const percent = groupData[group][year]?.Total > 0 ? Math.round((groupData[group][year].modalities[modality] / groupData[group][year].Total) * 100) : 0;
                                return { value: percent, itemStyle: { color: `hsl(${index * 60 + 30}, 70%, 50%)` } };
                            }),
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value > 0 ? `${params.value}%` : ''
                            }
                        });
                    }
                });
            } else {
                allModalities.forEach((modality, index) => {
                    series.push({
                        name: modality,
                        type: 'bar',
                        stack: 'total',
                        data: sortedYears.map(year => {
                            let total = 0;
                            let count = 0;
                            stations.forEach(station => {
                                const stats = yearlyData[station]?.[year];
                                if (stats) {
                                    total += (stats.modalities[modality] / stats.Total) * 100;
                                    count++;
                                }
                            });
                            Object.keys(groupData).forEach(group => {
                                if (selections.includes(`group:${group}`)) {
                                    const stats = groupData[group][year];
                                    if (stats) {
                                        total += (stats.modalities[modality] / stats.Total) * 100;
                                        count++;
                                    }
                                }
                            });
                            const percent = count > 0 ? Math.round(total / count) : 0;
                            return { value: percent, itemStyle: { color: modalityColors[modality.toLowerCase()] } };
                        }),
                        label: {
                            show: true,
                            position: 'inside',
                            formatter: params => params.value > 0 ? `${params.value}%` : ''
                        },
                        itemStyle: { color: modalityColors[modality.toLowerCase()] }
                    });
                });
            }

            charts.stationTrend.setOption({
                tooltip: {
                    trigger: 'axis',
                    formatter: params => {
                        const year = params[0].axisValue;
                        let result = `<strong>${year}</strong><br/>`;
                        params.forEach(p => {
                            if (p.value > 0) result += `${p.seriesName}: ${p.value}%<br/>`;
                        });
                        return result;
                    }
                },
                legend: {
                     top: '0',
                     orient: 'horizontal',
                     textStyle: { color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' },
                    data: series.map(s => ({
                        name: s.name,
                        icon: 'circle',
                        itemStyle: { color: s.itemStyle?.color || modalityColors[s.name.toLowerCase()] || `hsl(${series.indexOf(s) * 60 + 30}, 70%, 50%)` }
                    }))
                },
                grid: { left: '3%', right: '4%', bottom: '10%', containLabel: true, top: '20%' },
                xAxis: { type: 'category', data: sortedYears, axisLabel: { color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' } },
                yAxis: { type: 'value', max: 100, axisLabel: { formatter: '{value}%', color: document.documentElement.classList.contains('dark') ? '#fff' : '#000' } },
                series: series,
                toolbox: { feature: { saveAsImage: {}, dataZoom: {} } }
            });
        }

        function calculateVariationScore(records, years) {
            const yearlyData = {};
            records.forEach(r => {
                const year = new Date(r['Date de la campagne']).getFullYear();
                if (years.length > 0 && !years.includes(year)) return;
                if (!yearlyData[year]) {
                    yearlyData[year] = { total: 0, modalities: {} };
                    allModalities.forEach(modality => yearlyData[year].modalities[modality] = 0);
                }
                yearlyData[year].total++;
                yearlyData[year].modalities[r['Modalit√© d\'√©coulement']]++;
            });

            const sortedYears = Object.keys(yearlyData).sort().map(Number);
            if (sortedYears.length < 2) return 0;

            let totalVariation = 0;
            for (let i = 1; i < sortedYears.length; i++) {
                const prevYear = sortedYears[i - 1];
                const currYear = sortedYears[i];
                let variation = 0;
                allModalities.forEach(modality => {
                    const prevPercent = yearlyData[prevYear].total > 0 ? (yearlyData[prevYear].modalities[modality] / yearlyData[prevYear].total) * 100 : 0;
                    const currPercent = yearlyData[currYear].total > 0 ? (yearlyData[currYear].modalities[modality] / yearlyData[currYear].total) * 100 : 0;
                    variation += Math.abs(currPercent - prevPercent);
                });
                totalVariation += variation / allModalities.length;
            }

            return totalVariation / (sortedYears.length - 1);
        }

        function calculateDegradedPercentage(records, years) {
            const filteredRecords = records.filter(r => {
                const year = new Date(r['Date de la campagne']).getFullYear();
                return years.length === 0 || years.includes(year);
            });

            const total = filteredRecords.length;
            if (total === 0) return { percentage: 0, modalities: [] };

            const degradedCount = filteredRecords.filter(r =>
                trendConfig.degradedModalities.some(m => r['Modalit√© d\'√©coulement'].toLowerCase().includes(m))
            ).length;

            const modalities = {};
            allModalities.forEach(modality => {
                modalities[modality] = filteredRecords.filter(r => r['Modalit√© d\'√©coulement'] === modality).length;
            });

            return {
                percentage: total > 0 ? Math.round((degradedCount / total) * 100) : 0,
                modalities: Object.entries(modalities)
                    .filter(([_, count]) => count > 0)
                    .map(([modality, count]) => `${modality} (${count})`)
                    .join(', ')
            };
        }

        function updateVariationTable(filteredData) {
            const tbody = document.querySelector('#variationTable tbody');
            tbody.innerHTML = '';

            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => parseInt(opt.value));
            const stationStats = {};
            filteredData.forEach(d => {
                const station = d['Station d\'√©coulement'];
                if (!stationStats[station]) {
                    stationStats[station] = [];
                }
                stationStats[station].push(d);
            });

            const groupStats = {};
            Object.keys(stationGroups).forEach(group => {
                groupStats[group] = filteredData.filter(d => stationGroups[group].includes(d['Station d\'√©coulement']));
            });

            const variations = [];
            Object.keys(stationStats).forEach(station => {
                const variation = calculateVariationScore(stationStats[station], years);
                const modalities = [...new Set(stationStats[station].map(d => d['Modalit√© d\'√©coulement']))].join(', ');
                variations.push({ name: station, variation, modalities });
            });

            Object.keys(groupStats).forEach(group => {
                const variation = calculateVariationScore(groupStats[group], years);
                const modalities = [...new Set(groupStats[group].map(d => d['Modalit√© d\'√©coulement']))].join(', ');
                variations.push({ name: `Groupe: ${group}`, variation, modalities });
            });

            variations.sort((a, b) => b.variation - a.variation).slice(0, 10).forEach(item => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="p-3 border">${item.name}</td>
                    <td class="p-3 border">${item.variation.toFixed(2)}%</td>
                    <td class="p-3 border">${item.modalities}</td>
                `;
            });

            if (tbody.innerHTML === '') {
                tbody.innerHTML = `<tr><td colspan="3" class="p-3 text-center border">Aucune donn√©es disponible.</td></tr>`;
            }
        }

        function updateDegradedTable(filteredData) {
            const tbody = document.querySelector('#degradedTable tbody');
            tbody.innerHTML = '';

            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => parseInt(opt.value));
            const stationStats = {};
            filteredData.forEach(d => {
                const station = d['Station d\'√©coulement'];
                if (!stationStats[station]) {
                    stationStats[station] = [];
                }
                stationStats[station].push(d);
            });

            const groupStats = {};
            Object.keys(stationGroups).forEach(group => {
                groupStats[group] = filteredData.filter(d => stationGroups[group].includes(d['Station d\'√©coulement']));
            });

            const degraded = [];
            Object.keys(stationStats).forEach(station => {
                const stats = calculateDegradedPercentage(stationStats[station], years);
                if (stats.percentage > 0) {
                    degraded.push({ name: station, percentage: stats.percentage, modalities: stats.modalities });
                }
            });

            Object.keys(groupStats).forEach(group => {
                const stats = calculateDegradedPercentage(groupStats[group], years);
                if (stats.percentage > 0) {
                    degraded.push({ name: `Groupe: ${group}`, percentage: stats.percentage, modalities: stats.modalities });
                }
            });

            degraded.sort((a, b) => b.percentage - a.percentage).slice(0, 10).forEach(item => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td class="p-3 border">${item.name}</td>
                    <td class="p-3 border">${item.percentage}%</td>
                    <td class="p-3 border">${item.modalities}</td>
                `;
            });

            if (tbody.innerHTML === '') {
                tbody.innerHTML = `<tr><td colspan="3" class="p-3 text-center border">Aucune donn√©es disponible.</td></tr>`;
            }
        }

        async function captureElement(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return '';
            await new Promise(resolve => setTimeout(resolve, 500));
            const canvas = await html2canvas(element, { scale: 2, useCORS: true });
            return canvas.toDataURL('image/png');
        }

        async function exportToWordRisk() {
            const filteredData = getFilteredData();
            if (filteredData.length === 0) {
                showStatus('Aucune donn√©e disponible pour g√©n√©rer le rapport.', 'error');
                return;
            }

            const selections = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);
            const modalities = Array.from(document.getElementById('modalitySelect').selectedOptions).map(opt => opt.value);
            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => opt.value);

            const variance = calculateInterAnnualVariance(filteredData);
            const variationData = [];
            const variationRows = document.querySelectorAll('#variationTable tbody tr');
            variationRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                variationData.push(parseFloat(cells[1].textContent) || 0);
            });

            const degradedData = [];
            const degradedRows = document.querySelectorAll('#degradedTable tbody tr');
            degradedRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                degradedData.push(parseFloat(cells[1].textContent) || 0);
            });

            const spearman = calculateSpearman(variationData, degradedData);

            const stationChartImage = await captureElement('stationChart');
            const modalityChartImage = await captureElement('modalityChart');
            const yearlyTrendChartImage = await captureElement('yearlyTrendChart');
            const stationTrendChartImage = await captureElement('stationTrendChart');

            let hubEauSection = '';
            if (includeHubEau) {
                hubEauSection = `<h2 id="hubeau-data">Donn√©es D√©bits Hub'Eau</h2><p>Int√©gration des d√©bits en temps r√©el et historiques.</p><table><tr><th>Station</th><th>D√©bit Moyen (m¬≥/s)</th></tr>${Object.entries(hubEauDebits).map(([st, d]) => `<tr><td>${st}</td><td>${(typeof d.avgDebit === 'number') ? d.avgDebit.toFixed(2) : d.avgDebit || 'N/A'}</td></tr>`).join('')}</table>`;
            }

            let extendedSection = '';
            if (includeExtended) {
                extendedSection = `<h2 id="extended-data">Donn√©es √âtendues</h2><p>Nappes, Pr√©l√®vements, Masses, Bassins.</p><table><tr><th>Station</th><th>Nappe</th><th>Pr√©l√®vement</th><th>Masse</th><th>Bassin</th></tr>${projections.map(p => `<tr><td>${p.entity}</td><td>${p.nappe}</td><td>${p.prelev}</td><td>${p.masse}</td><td>${p.bassin}</td></tr>`).join('')}</table>`;
            }

            let htmlContent = `
                <html>
                <head>
                    <title>Rapport d'Analyse D√©taill√©e des √âcoulements</title>
                    <style>
                        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 20px; }
                        h1 { color: #005566; text-align: center; }
                        h2 { color: #00a3a6; border-bottom: 2px solid #00a3a6; padding-bottom: 10px; }
                        h3 { color: #005566; }
                        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
                        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                        th { background-color: #005566; color: white; }
                        img { max-width: 100%; height: auto; margin-bottom: 20px; display: block; }
                        .page-break { page-break-before: always; }
                        ul { list-style-type: disc; padding-left: 20px; }
                        .toc { margin-bottom: 40px; }
                        .toc a { color: #00a3a6; text-decoration: none; }
                        .toc a:hover { text-decoration: underline; }
                    </style>
                </head>
                <body>
                    <h1>Rapport d'Analyse D√©taill√©e des √âcoulements</h1>
                    <p style="text-align: center; font-style: italic;">Office Fran√ßais de la Biodiversit√© - Date : ${new Date().toLocaleDateString('fr-FR')}</p>
                    <p style="text-align: center;">Version 1.0 - G√©n√©r√© par l'outil d'analyse avanc√©e</p>

                    <div class="page-break"></div>

                    <h2>Table des Mati√®res</h2>
                    <div class="toc">
                        <ul>
                            <li><a href="#introduction">Introduction</a></li>
                            <li><a href="#resume-statistique">R√©sum√© Statistique</a></li>
                            <li><a href="#analyse-tendances">Analyse des Tendances</a></li>
                            <li><a href="#classements">Classements</a></li>
                            <li><a href="#visualisations">Visualisations</a></li>
                            ${includeHubEau ? '<li><a href="#hubeau-data">Donn√©es D√©bits Hub\'Eau</a></li>' : ''}
                            ${includeExtended ? '<li><a href="#extended-data">Donn√©es √âtendues (Nappes, etc.)</a></li>' : ''}
                        </ul>
                    </div>

                    <div class="page-break"></div>

                    <h2 id="introduction">Introduction</h2>
                    <p>Ce rapport pr√©sente une analyse d√©taill√©e des donn√©es d'ecoulement charg√©es, incluant ${data.length} observations au total. Les filtres appliqu√©s sont : Stations/Groupes : ${selections.join(', ') || 'Tous'}, Ann√©es : ${years.join(', ') || 'Toutes'}, Modalit√©s : ${modalities.join(', ') || 'Toutes'}, Comparaison avec ann√©e pr√©c√©dente : ${comparePreviousYear ? 'Oui' : 'Non'}, Inclusion des pr√©visions m√©t√©o : ${includeWeather ? 'Oui' : 'Non'}${includeHubEau ? ', Inclusion d√©bits Hub\'Eau : Oui' : ''}${includeExtended ? ', Inclusion √©tendue : Oui' : ''}.</p>
                    <p>M√©thodologie : Les tendances sont calcul√©es en utilisant des pond√©rations pour les modalit√©s (assec: 4, ecoulement non visible: 3, ecoulement visible faible: 2, ecoulement visible acceptable: 1). La tendance est d√©termin√©e par la diff√©rence de poids moyen entre les relev√©s (am√©lioration si < -0.5, d√©gradation si > 0.5). Les projections m√©t√©o sont bas√©es sur Open-Meteo, avec risque = (poids * 50) + ((10 - pluie) * 5) + (temp - 15) * 2.</p>

                    <h2 id="resume-statistique">R√©sum√© Statistique</h2>
                    <p>Statistiques globales des donn√©es filtr√©es. Variance inter-annuelle des poids moyens : ${variance}.</p>
                    <table>
                        <tr><th>Statistique</th><th>Valeur</th></tr>
                        <tr><td>Total Observations</td><td>${filteredData.length}</td></tr>
                        <tr><td>Stations Actives</td><td>${[...new Set(filteredData.map(d => d['Station d\'√©coulement']))].length}</td></tr>
                        ${allModalities.map(modality => {
                            const count = filteredData.filter(d => d['Modalit√© d\'√©coulement'] === modality).length;
                            const percent = filteredData.length > 0 ? Math.round((count / filteredData.length) * 100) : 0;
                            return `<tr><td>% ${modality}</td><td>${percent}% (${count})</td></tr>`;
                        }).join('')}
                    </table>
                    <h2 id="analyse-tendances">Analyse des Tendances</h2>
                    <p>Tableau des tendances avec sous-sections par entit√©.</p>
                    <table>
                        ${document.querySelector('#trendTable').outerHTML.replace(/class="table-header"/g, 'style="background-color: #005566; color: white;"').replace(/data-tooltip="[^"]*"/g, '').replace(/onclick="[^"]*"/g, '').replace(/class="[^"]*"/g, '').replace(/data-forecast="[^"]*"/g, '')}
                    </table>
                    <p>Analyse : Les tendances montrent une d√©gradation g√©n√©rale si le poids moyen augmente, avec focus sur les stations √† risque √©lev√©.</p>

                    <div class="page-break"></div>

                    <h2 id="classements">Classements</h2>
                    <h3>Variations Importantes</h3>
                    <table>
                        ${document.querySelector('#variationTable').outerHTML.replace(/class="table-header"/g, 'style="background-color: #005566; color: white;"').replace(/class="[^"]*"/g, '')}
                    </table>
                    <h3>Stations D√©grad√©es</h3>
                    <table>
                        ${document.querySelector('#degradedTable').outerHTML.replace(/class="table-header"/g, 'style="background-color: #005566; color: white;"').replace(/class="[^"]*"/g, '')}
                    </table>
                    <p>Analyse : Coefficient de Spearman entre variations et d√©gradations : ${spearman}. Une valeur proche de 1 indique une forte corr√©lation, sugg√©rant que les stations avec hautes variations sont souvent d√©grad√©es.</p>

                    <div class="page-break"></div>

                    <h2 id="visualisations">Visualisations</h2>
                    <h3>R√©partition par Station</h3>
                    <img src="${stationChartImage || ''}" alt="R√©partition par Station" />
                    <p>L√©gende : Pourcentage des modalit√©s par station, avec code couleur.</p>

                    <h3>R√©partition des Modalit√©s</h3>
                    <img src="${modalityChartImage || ''}" alt="Modalit√©s d'√âcoulement" />
                    <p>L√©gende : Pie chart de la r√©partition globale.</p>

                    <h3>√âvolution Annuelle</h3>
                    <img src="${yearlyTrendChartImage || ''}" alt="√âvolution Annuelle" />
                    <p>L√©gende : Lignes d'√©volution des pourcentages par ann√©e.</p>

                    <h3>Tendances par Station/Groupe</h3>
                    <img src="${stationTrendChartImage || ''}" alt="Tendances par Station/Groupe" />
                    <p>L√©gende : Tendances filtr√©es, avec lignes pour groupes en pointill√©.</p>
                    ${hubEauSection}
                    ${extendedSection}
                </body>
                </html>
            `;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            saveAs(blob, 'Rapport_Analyse_Detailee.html');
            showStatus('Exportation du rapport d√©taill√© en HTML r√©ussie ! Ouvrez-le dans Word.', 'success');
        }

        async function exportToPDF() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const filteredData = getFilteredData();
            if (filteredData.length === 0) {
                showStatus('Aucune donn√©e disponible pour g√©n√©rer le rapport PDF.', 'error');
                return;
            }

            // Reuse the same content generation as HTML export
            const stationChartImage = await captureElement('stationChart');
            const modalityChartImage = await captureElement('modalityChart');
            const yearlyTrendChartImage = await captureElement('yearlyTrendChart');
            const stationTrendChartImage = await captureElement('stationTrendChart');

            // Add text and images to PDF
            pdf.text('Rapport d\'Analyse D√©taill√©e des √âcoulements', 105, 10, { align: 'center' });
            pdf.addImage(stationChartImage, 'PNG', 10, 20, 190, 100);
            pdf.addPage();
            pdf.addImage(modalityChartImage, 'PNG', 10, 20, 190, 100);
            pdf.addPage();
            pdf.addImage(yearlyTrendChartImage, 'PNG', 10, 20, 190, 100);
            pdf.addPage();
            pdf.addImage(stationTrendChartImage, 'PNG', 10, 20, 190, 100);

            pdf.save('Rapport_Analyse_Detailee.pdf');
            showStatus('Exportation du rapport en PDF r√©ussie !', 'success');
        }

        async function updateDashboard() {
            const filteredData = getFilteredData();
            if (filteredData.length === 0) {
                showStatus('Aucune donn√©es avec ces filtres.', 'error');
                document.getElementById('dashboard').style.display = 'none';
                document.querySelector('#trendTable tbody').innerHTML = `<tr><td colspan="14" class="p-3 text-center border">Aucune donn√©es disponible pour les filtres s√©lectionn√©s.</td></tr>`;
                document.querySelector('#variationTable tbody').innerHTML = `<tr><td colspan="3" class="p-3 text-center border">Aucune donn√©es disponible.</td></tr>`;
                document.querySelector('#degradedTable tbody').innerHTML = `<tr><td colspan="3" class="p-3 text-center border">Aucune donn√©es disponible.</td></tr>`;
                return;
            }
            document.getElementById('dashboard').style.display = 'block';
            updateSummaryStats(filteredData);
            updateCharts(filteredData);
            await updateTrendTable();
            updateVariationTable(filteredData);
            updateDegradedTable(filteredData);
            updateMapAndWeather();
        }

        function updateMapAndWeather() {
            const mapContainer = document.getElementById('map-container');
            if (Object.keys(stationCoordinates).length === 0) {
                mapContainer.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400">Aucune coordonn√©e disponible pour les stations.</p>';
                return;
            }

            if (map) map.remove();
            map = L.map('map-container').setView([46.603354, 1.888334], 5);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            const heatPoints = [];
            projections.forEach(p => {
                const coord = stationCoordinates[p.entity];
                if (coord) {
                    const intensity = sensitiveMode ? p.sensitivityScore / 100 : p.risk / 100;
                    heatPoints.push([coord.lat, coord.lon, intensity]);
                }
            });

            heatLayer = L.heatLayer(heatPoints, { radius: 25, blur: 15 }).addTo(map);

            // Genial layers: Toggleable overlays for extended data
            const overlays = {
                'Nappes': L.layerGroup(),
                'Pr√©l√®vements': L.layerGroup(),
                'Masses d\'Eau': L.layerGroup(),
                'Bassins': L.layerGroup()
            };

            projections.forEach(p => {
                const coord = stationCoordinates[p.entity];
                if (coord) {
                    let fillColor;
                    if (sensitiveMode) {
                        if (p.sensitivityScore > 70) fillColor = 'red';
                        else if (p.sensitivityScore > 40) fillColor = 'orange';
                        else fillColor = 'green';
                    } else {
                        fillColor = modalityColors[p.lastModality.toLowerCase()] || 'gray';
                    }
                    const projectionBorder = p.color === '#ef4444' ? 'red' : p.color === '#f59e0b' ? 'orange' : 'green';
                    const marker = L.circleMarker([coord.lat, coord.lon], { color: projectionBorder, fillColor: fillColor, fillOpacity: 0.8, radius: 10 }).addTo(map);
                    let popupContent = `<b>${p.entity}</b><br> Dernier relev√©: ${p.lastModality}<br>Date dernier relev√©: ${p.lastDate}<br>Tendance: ${p.trend}<br>Projection: ${p.text} (${p.risk}%)<br>Pr√©visions m√©t√©o (7j): Pluie ${p.rain}mm, Temp ${p.temp}¬∞C<br>Score: ${p.score.toFixed(0)}%`;
                    if (sensitiveMode) {
                        popupContent += `<br>Sensibilit√©: ${p.sensitivityScore.toFixed(0)}% (R√©current: ${p.isRecurring ? 'Oui' : 'Non'}, Variation: ${p.variation.toFixed(2)}%, D√©grad√©: ${p.degradedPct}%)`;
                    }
                    marker.bindPopup(popupContent);

                    // Add to layers (genial: colored markers for extended)
                    if (p.nappe !== 'N/A') L.circleMarker([coord.lat, coord.lon], { color: 'blue', radius: 5 }).addTo(overlays['Nappes']).bindPopup(`Nappe: ${p.nappe}m`);
                    if (p.prelev !== 'N/A') L.circleMarker([coord.lat, coord.lon], { color: 'red', radius: 5 }).addTo(overlays['Pr√©l√®vements']).bindPopup(`Pr√©l√®vement: ${p.prelev} m¬≥`);
                    if (p.masse !== 'N/A') L.circleMarker([coord.lat, coord.lon], { color: 'purple', radius: 5 }).addTo(overlays['Masses d\'Eau']).bindPopup(`Masse: ${p.masse}`);
                    if (p.bassin !== 'N/A') L.circleMarker([coord.lat, coord.lon], { color: 'brown', radius: 5 }).addTo(overlays['Bassins']).bindPopup(`Bassin: ${p.bassin}`);
                }
            });

            L.control.layers(null, overlays).addTo(map); // Genial toggle layers

            // Update legend
            const legendDiv = document.getElementById('map-legend');
            if (sensitiveMode) {
                legendDiv.innerHTML = 'L√©gende Sensibilit√© : <span style="color:red">Haut (>70%)</span> <span style="color:orange">Moyen (40-70%)</span> <span style="color:green">Bas (<40%)</span>';
            } else {
                legendDiv.innerHTML = 'L√©gende : Couleur remplissage (dernier relev√©), Bordure (projection m√©t√©o). Couches pour extended data.';
            }

            setTimeout(() => map.invalidateSize(), 100);
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('excelFile').addEventListener('change', function() {
                loadDataFromFile(this);
            });
            document.getElementById('stationSelect').addEventListener('change', updateDashboard);
            document.getElementById('modalitySelect').addEventListener('change', updateDashboard);
            document.getElementById('yearSelect').addEventListener('change', updateDashboard);
            document.getElementById('comparePreviousYear').addEventListener('change', (e) => {
                comparePreviousYear = e.target.checked;
                updateDashboard();
            });
            document.getElementById('includeWeather').addEventListener('change', (e) => {
                includeWeather = e.target.checked;
                updateDashboard();
            });
            document.getElementById('includeHubEau').addEventListener('change', (e) => {
                includeHubEau = e.target.checked;
                updateDashboard();
            });
            document.getElementById('includeExtended').addEventListener('change', (e) => {
                includeExtended = e.target.checked;
                updateDashboard();
            });
            document.getElementById('toggleSensitive').addEventListener('click', () => {
                sensitiveMode = !sensitiveMode;
                document.getElementById('toggleSensitive').textContent = sensitiveMode ? 'Revenir au Mode Normal' : 'Afficher Stations Sensibles';
                updateMapAndWeather();
            });
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                document.documentElement.classList.toggle('dark', e.matches);
                updateCharts(getFilteredData());
            });
            // Add event for opening the explicative modal
            document.getElementById('openExplicativeModal').addEventListener('click', () => {
                document.getElementById('explicativeModal').style.display = 'block';
            });
        });
    </script>
</body>
</html>