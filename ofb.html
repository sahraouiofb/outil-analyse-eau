


<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyse Avanc√©e des √âcoulements - OFB</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.11.0/dist/proj4.js"></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"/>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .chart-container {
            height: 400px;
            width: 100%;
        }
        .trend-up { color: #22c55e; font-size: 1.5em; }
        .trend-down { color: #ef4444; font-size: 1.5em; }
        .trend-stable { color: #6b7280; font-size: 1.5em; }
        .trend-down-row {
            background-color: #fee2e2;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #005566;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Toggle Switch Styles */
        /*
            The .switch class transforms a standard checkbox into a modern sliding toggle.  The element
            itself becomes an inline-block with a rounded track and a movable knob.  When checked,
            the background color changes to the application‚Äôs accent colour and the knob slides to the
            opposite side.  This approach preserves the semantic behaviour of the checkbox while
            providing an intuitive on/off affordance.
        */
        .switch {
            appearance: none;
            -webkit-appearance: none;
            position: relative;
            width: 42px;
            height: 22px;
            background-color: #d1d5db;
            border-radius: 9999px;
            transition: background-color 0.3s ease;
            cursor: pointer;
            vertical-align: middle;
            outline: none;
        }
        .switch::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background-color: #ffffff;
            border-radius: 9999px;
            transition: transform 0.3s ease;
        }
        .switch:checked {
            background-color: #00a3a6;
        }
        .switch:checked::before {
            transform: translateX(20px);
        }
        [data-tooltip] {
            position: relative;
        }
        [data-tooltip]:hover:after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #005566;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 10;
        }
        .low-flow-flag {
            background-color: #fef3c7;
            color: #b45309;
            font-weight: bold;
        }
        .stat-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }
        .table-header {
            background: linear-gradient(to right, #005566, #00a3a6);
            color: white;
        }
        .legend-container {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-top: 1rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        #map-container {
            height: 600px;
            width: 100%;
        }
        .projection-high { color: #ef4444; }
        .projection-medium { color: #f59e0b; }
        .projection-low { color: #22c55e; }
        #forecastModal {
            display: none;
            position: fixed;
            z-index: 50;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        #forecastModal .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
        }
        #forecastChart {
            height: 300px;
        }
        /* Styles for the new explicative modal */
        #explicativeModal {
            display: none;
            position: fixed;
            z-index: 50;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        #explicativeModal .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 1000px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #explicativeModal .modal-content h1, #explicativeModal .modal-content h2, #explicativeModal .modal-content h3 {
            color: #005566;
        }
        #explicativeModal .modal-content pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 6px;
            overflow-x: auto;
        }
        #explicativeModal .modal-content code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
        }
        html, body, #map { height:100%; margin:0; padding:0 }
        .popup-chart { width:200px; height:120px; display:block; margin:0 auto }
        .popup-content { font-size:14px; line-height:1.3 }
        .no-data { text-align:center; color:#777; padding:1em }
        .map-legend-item { display: inline-block; margin-right: 10px; }
        .map-legend-shape { display: inline-block; vertical-align: middle; margin-right: 5px; }
        
        /* Mode plein √©cran pour la carte */
        .fullscreen-map {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            border-radius: 0 !important;
            box-shadow: none !important;
        }
        
        /* Contr√¥les sur la carte en mode plein √©cran */
        .map-controls-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            width: 220px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
        .map-controls-overlay.show {
            display: block;
        }
        
        /* Boutons de contr√¥le de la carte */
        .map-control-btn {
            position: absolute;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 10001;
            transition: all 0.2s;
            font-size: 16px;
            min-width: 40px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .map-control-btn:hover {
            background: #f3f4f6;
            border-color: #3b82f6;
            transform: scale(1.05);
        }
        
        .fullscreen-btn {
            top: 10px;
            right: 10px;
        }
        
        .exit-fullscreen-btn {
            top: 10px;
            left: 10px;
            display: none;
            background: #ef4444;
            color: white;
            border-color: #dc2626;
        }
        
        .exit-fullscreen-btn:hover {
            background: #dc2626;
        }
        
        .download-btn {
            top: 60px;
            right: 10px;
            background: #10b981;
            color: white;
            border-color: #059669;
        }
        
        .download-btn:hover {
            background: #059669;
        }
        
        /* Contr√¥les de couches pour le mode plein √©cran */
        .fullscreen-layer-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .fullscreen-layer-controls .layer-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .fullscreen-layer-controls .layer-control label {
            margin: 0;
            font-weight: 500;
            font-size: 12px;
        }
        
        .fullscreen-layer-controls .switch {
            width: 32px;
            height: 16px;
        }
        
        .fullscreen-layer-controls .switch::before {
            width: 14px;
            height: 14px;
        }
        
        .fullscreen-layer-controls .switch:checked::before {
            transform: translateX(16px);
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 min-h-screen font-sans transition-colors duration-300">
    <p class="text-red-500 italic text-sm absolute top-0 right-0 m-2">by SD40 2025</p>
    <header class="bg-gradient-to-r from-[#005566] to-[#00a3a6] shadow-md py-4">
        <div class="container mx-auto px-6 flex items-center justify-between">
            <img src="t√©l√©chargement.png" alt="Logo OFB" class="h-16">
            <h1 class="text-3xl font-bold text-white">
                Analyse Avanc√©e des √âcoulements - Office Fran√ßais de la Biodiversit√©
            </h1>
        </div>
    </header>
    <div class="container mx-auto p-6 max-w-7xl">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl mb-8">
            <div class="flex flex-wrap gap-4 mb-6">
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Donn√©es ONDE</label>
                    <!-- Bouton pour charger les observations ONDE via l'API Hub'Eau -->
                    <button onclick="loadDataFromONDE()" class="w-full bg-gradient-to-r from-[#005566] to-[#00a3a6] text-white px-4 py-2 rounded-lg hover:from-[#004a55] hover:to-[#008c8f] transition-all" data-tooltip="T√©l√©charger les observations d'√©coulement via l'API ONDE (observations, stations)">üîÑ Charger ONDE</button>
                </div>
                <!-- S√©lecteur de d√©partement -->
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">D√©partement</label>
                    <select id="deptSelect" class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6]">
                        <option value="">Choisir</option>
                    </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Stations/Groupes</label>
                    <input type="text" id="stationSearch" placeholder="Rechercher stations/groupes" class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6] mb-2">
                    <select id="stationSelect" multiple class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6]">
                        <option value="">S√©lectionner</option>
                    </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Ann√©es</label>
                    <select id="yearSelect" multiple class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6]">
                        <option value="">S√©lectionner</option>
                    </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Modalit√©</label>
                    <select id="modalitySelect" multiple class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6]">
                        <option value="">Toutes</option>
                    </select>
                </div>
                <div class="flex-1 min-w-[200px]">
                    <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Nom du groupe</label>
                    <input type="text" id="groupName" placeholder="Nom du groupe" class="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-[#00a3a6]">
                </div>
                <div class="flex items-end gap-2 flex-wrap">
                    <label data-tooltip="Afficher les pr√©visions m√©t√©orologiques" class="flex items-center gap-1">
                        <input type="checkbox" id="includeWeather" class="switch" checked>
                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300 select-none">Inclure Pr√©visions M√©t√©o</span>
                    </label>
                    <button onclick="createStationGroup()" class="bg-gradient-to-r from-[#005566] to-[#00a3a6] text-white px-4 py-2 rounded-lg hover:from-[#004a55] hover:to-[#008c8f] transition-all" data-tooltip="Cr√©er un groupe de stations">‚ûï Groupe</button>
                    <button onclick="resetFilters()" class="bg-gray-500 text-white px-4 py-2 rounded-lg hover:bg-gray-600 transition-all" data-tooltip="R√©initialiser les filtres">üîÑ R√©initialiser</button>
                    <button onclick="exportToWordRisk()" class="bg-[#ef4444] text-white px-4 py-2 rounded-lg hover:bg-[#dc2626] transition-all" data-tooltip="Exporter Rapport Analyse D√©taill√©e en HTML (ouvrable dans Word)">üìù Rapport Analyse D√©taill√©e</button>
                    <button id="openExplicativeModal" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-all" data-tooltip="Ouvrir la note explicative">üìñ Aide</button>
                    <button onclick="exportToPDF()" class="bg-green-500 text-white px-4 py-2 rounded-lg hover:bg-green-600 transition-all" data-tooltip="Exporter en PDF">üìÑ Export PDF</button>
                    <button onclick="window.openAspeModal()" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-all font-bold" data-tooltip="Ouvrir l'analyse piscicole ASPE avanc√©e" style="border: 2px solid #fff; margin-top: 8px;" id="aspeModalButton">üêü ANALYSE PISCICOLE ASPE</button>
                </div>
            </div>
            <div id="groupList" class="hidden bg-[#e6f2f3] dark:bg-gray-700 p-4 rounded-lg mb-4"></div>
            <div class="bg-[#e6f2f3] dark:bg-[#1c3e44] p-4 rounded-lg text-sm text-[#005566] dark:text-[#b3d6d8]">
                <strong>üí° Comment utiliser :</strong>
                <ul class="list-disc pl-5">
                    <li>Chargez les observations d'√©coulement directement via l'API ONDE en cliquant sur le bouton ¬´¬†Charger ONDE¬†¬ª. Les donn√©es du d√©partement sont r√©cup√©r√©es et int√©gr√©es automatiquement (stations, modalit√©s, dates, coordonn√©es).</li>
                    <li>Les stations sont identifi√©es par leur code OFB¬†: le num√©ro de d√©partement suivi d'un identifiant √† 7 chiffres (par ex. 400000001 pour la premi√®re station des Landes). Ces codes sont utilis√©s dans les graphiques et tableaux afin de conserver une lisibilit√© optimale.</li>
                    <li>Cr√©ez des groupes en s√©lectionnant plusieurs stations et en saisissant un nom.</li>
                    <li>Filtrez par stations, ann√©es ou modalit√©s pour analyser les tendances sur les deux derniers relev√©s ou comparer avec l'ann√©e pr√©c√©dente.</li>
                    <li>La carte (agrandie pour meilleure visibilit√©) montre les stations avec des couleurs pour le dernier relev√© et une fl√®che pour la tendance. Utilisez les <strong>boutons glissants</strong> pour activer ou d√©sactiver les diff√©rentes couches¬†: Stations d'√©coulement (avec mode sensible via bouton), D√©bits (ic√¥ne goutte d'eau), Nappes (ic√¥ne jauge), Pr√©l√®vements (ic√¥ne pompe), <em>Restrictions d'eau</em> (filtr√©es selon le d√©partement s√©lectionn√©), <em>Qualit√© physico‚Äëchimique</em> (ic√¥ne √©prouvette), <em>Flore/Faune</em> (ic√¥ne feuille) et <em>Obstacles √† l'√©coulement</em> (cercle color√© selon la hauteur de chute). Ces ic√¥nes et couleurs th√©matiques am√©liorent la clart√© et l'esth√©tique de la visualisation.</li>
                    <li>Les projections m√©t√©o (via Open-Meteo) fournissent des pr√©visions sur 7 jours pour estimer les risques de d√©gradation (bas√©es sur pluie et temp√©rature). Cliquez sur une ligne du tableau d'analyse pour voir les pr√©visions journali√®res d√©taill√©es (valeurs r√©elles par jour).</li>
                    <li>Analyse spatio‚Äëtemporelle et multi‚Äëparam√®tres : Cliquez sur ¬´ Analyse spatio‚Äëtemporelle et multi‚Äëparam√®tres ¬ª pour acc√©der √† un aper√ßu approfondi croisant variation, d√©gradation, pr√©cipitations, temp√©rature, pr√©l√®vements, niveaux de nappes, d√©bits et restrictions. L‚Äôanalyse calcule un indice de risque, identifie les stations √† risque, affiche une matrice de corr√©lation et regroupe les stations en clusters. Vous pouvez exporter cette analyse en Word.</li>
                    <li>Exportez vos analyses : utilisez le bouton ¬´¬†üìù Rapport Analyse D√©taill√©e¬†¬ª pour produire un fichier HTML ouvrable dans Word, ou ¬´¬†üìÑ Export PDF¬†¬ª pour g√©n√©rer directement un PDF.</li>
                </ul>
                <p><strong>Note : Si vous rencontrez des erreurs CORS lors du chargement des donn√©es Hub'Eau, ex√©cutez ce fichier HTML sur un serveur local (par exemple, avec Python : python -m http.server) au lieu de l'ouvrir directement dans le navigateur.</strong></p>
            </div>
            <div id="status" class="hidden p-4 rounded-lg mt-4"></div>
        </div>

        <div id="loading" class="hidden text-center py-10">
            <div class="spinner mx-auto"></div>
            <p class="text-gray-600 dark:text-gray-300">Chargement...</p>
        </div>

        <div id="dashboard" class="hidden">
            <div class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-200 mb-4">R√©sum√© de l'Analyse</h2>
                <p class="text-gray-600 dark:text-gray-300 mb-6">Cette section pr√©sente une vue d'ensemble des donn√©es d'ecoulement, incluant le nombre total d'observations, les stations actives, et la r√©partition des modalit√©s. Utilisez les filtres pour affiner l'analyse.</p>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6" id="summaryStats"></div>
            </div>
            <div class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-200 mb-4">Classements</h2>
                <p class="text-gray-600 dark:text-gray-300 mb-6">Classement des 10 stations avec les variations de tendance les plus importantes et des stations les plus souvent d√©grad√©es (Assec, √âcoulement faible, etc.) selon les ann√©es s√©lectionn√©es.</p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <!-- Top 10 stations avec variations importantes : cette carte occupe une seule colonne pour rester align√©e avec le tableau des stations d√©grad√©es -->
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Top 10 Stations avec Variations Importantes</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Stations avec les plus grandes variations de modalit√©s sur les ann√©es s√©lectionn√©es.</p>
                        <div class="overflow-x-auto">
                            <table id="variationTable" class="w-full text-sm text-gray-800 dark:text-gray-200 border-collapse">
                                <thead>
                                    <tr class="table-header">
                                        <th class="p-3 border">Station</th>
                                        <th class="p-3 border">Variation Moyenne (%)</th>
                                        <th class="p-3 border">Modalit√©s Observ√©es</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Stations les Plus D√©grad√©es</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Stations avec la plus forte proportion de modalit√©s d√©grad√©es (Assec, √âcoulement faible, Critique).</p>
                        <div class="overflow-x-auto">
                            <table id="degradedTable" class="w-full text-sm text-gray-800 dark:text-gray-200 border-collapse">
                                <thead>
                                    <tr class="table-header">
                                        <th class="p-3 border">Station</th>
                                        <th class="p-3 border">% D√©grad√©</th>
                                        <th class="p-3 border">Modalit√©s D√©grad√©es</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- L'analyse avanc√©e est d√©sormais accessible via un modal d√©di√©. Le bloc de contenu a √©t√© d√©plac√© dans le modal. -->
            <div class="mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 dark:text-gray-200 mb-4">Visualisations D√©taill√©es</h2>
                <p class="text-gray-600 dark:text-gray-300 mb-6">Les graphiques ci-dessous illustrent la r√©partition des √©coulements par station, les tendances annuelles, les √©volutions par station ou groupe. Les donn√©es sont bas√©es sur les deux derniers relev√©s pour les tendances.</p>
                <!-- Bouton d'ouverture du modal d'analyse spatio-temporelle et multi-param√®tres -->
                <div class="mb-4 flex">
                    <button id="openAnalysisModal" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400" data-tooltip="Afficher le volet d'analyse avanc√©e">
                        Analyse spatio‚Äëtemporelle et multi‚Äëparam√®tres
                    </button>
                </div>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">R√©partition par Station</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Pourcentage des modalit√©s d'ecoulement par station s√©lectionn√©e.</p>
                        <!-- Augmenter la taille du conteneur du graphique pour √©viter l'affichage miniature -->
                        <div class="chart-container" id="stationChart" style="height:450px;width:100%"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Modalit√©s d'√âcoulement</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">R√©partition globale des modalit√©s d'ecoulement.</p>
                        <div class="chart-container" id="modalityChart"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">√âvolution Annuelle</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">√âvolution des modalit√©s d'ecoulement par ann√©e.</p>
                        <div class="chart-container" id="yearlyTrendChart"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Tendances par Station/Groupe</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Tendances des √©coulements pour les stations ou groupes s√©lectionn√©s.</p>
                        <div class="chart-container" id="stationTrendChart"></div>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6] lg:col-span-2">
                        <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Carte des Stations</h3>
                        <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Localisation des stations avec code couleur pour le dernier relev√©, fl√®che pour la tendance, et bordure pour projection m√©t√©o. Activez/d√©sactivez les couches et consultez la l√©gende pour les ic√¥nes th√©matiques.</p>
                        <!-- Contr√¥les des couches cartographiques r√©organis√©s -->
                        <div class="bg-gray-50 p-3 rounded-lg mb-4">
                            <h4 class="text-sm font-semibold text-gray-700 mb-2">Couches cartographiques</h4>
                            
                            <!-- Contr√¥les organis√©s en 3 lignes compactes -->
                            <div class="grid grid-cols-1 gap-2">
                                <!-- Ligne 1: Stations et donn√©es principales -->
                                <div class="flex flex-wrap gap-1 text-xs">
                                    <label data-tooltip="Afficher/masquer les stations d'√©coulement" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleEcoulement" class="switch scale-75" checked>
                                        <span>Stations</span>
                                    </label>
                                    <button id="toggleSensitive" class="bg-blue-500 text-white text-xs px-1 py-0.5 rounded hover:bg-blue-600" data-tooltip="Mode sensibilit√©">Sensibles</button>
                                    <label data-tooltip="Afficher/masquer les d√©bits" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleDebits" class="switch scale-75" checked>
                                        <span>D√©bits</span>
                                    </label>
                                    <label data-tooltip="Afficher/masquer les nappes" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleNappes" class="switch scale-75" checked>
                                        <span>Nappes</span>
                                    </label>
                                    <label data-tooltip="Afficher/masquer les pr√©l√®vements" class="flex items-center gap-1">
                                        <input type="checkbox" id="togglePrelevements" class="switch scale-75" checked>
                                        <span>Pr√©l√®vements</span>
                                    </label>
                                </div>
                                
                                <!-- Ligne 2: Donn√©es environnementales -->
                                <div class="flex flex-wrap gap-1 text-xs">
                                    <label data-tooltip="Afficher/masquer les restrictions d'eau" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleRestrictions" class="switch scale-75">
                                        <span>Restrictions</span>
                                    </label>
                                    <label data-tooltip="Afficher/masquer la qualit√© d'eau" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleQualite" class="switch scale-75">
                                        <span>Qualit√©</span>
                                    </label>
                                    <label data-tooltip="Afficher/masquer les stations hydrobiologiques" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleFlore" class="switch scale-75">
                                        <span>Flore/Faune</span>
                                    </label>
                                    <label data-tooltip="Obstacles √† l'√©coulement avec coordonn√©es g√©or√©f√©renc√©es pr√©cises (source Sandre WFS)" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleObstacles" class="switch scale-75">
                                        <span>Obstacles WFS <span style="background: #22c55e; color: white; font-size: 10px; padding: 1px 4px; border-radius: 3px; margin-left: 3px;">‚úì PR√âCIS</span></span>
                                    </label>
                                </div>
                                
                                <!-- Ligne 3: Donn√©es Sandre -->
                                <div class="flex flex-wrap gap-1 text-xs">
                                    <label data-tooltip="Afficher/masquer les bassins versants" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleBassins" class="switch scale-75">
                                        <span>Bassins versants</span>
                                    </label>
                                    <label data-tooltip="Afficher/masquer les masses d'eau" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleMassesEau" class="switch scale-75">
                                        <span>Masses d'eau</span>
                                    </label>
                                    <label data-tooltip="Afficher/masquer les zones humides" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleZonesHumides" class="switch scale-75">
                                        <span>Zones humides</span>
                                    </label>
                                    <label data-tooltip="Afficher/masquer les hydro-√©cor√©gions" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleHER" class="switch scale-75">
                                        <span>Hydro-√©cor√©gions</span>
                                    </label>
                                    <label data-tooltip="Afficher/masquer les zones SAGE" class="flex items-center gap-1">
                                        <input type="checkbox" id="toggleSAGE" class="switch scale-75">
                                        <span>Zones SAGE</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                       <div id="map-legend" class="mb-4 text-sm text-gray-700 dark:text-gray-300">
    <strong>L√©gende :</strong><br>
    <div id="legend-ecoulement">
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: red; width:10px; height:10px; border-radius:50%;"></span> Assec</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #ff4500; width:10px; height:10px; border-radius:50%;"></span> √âcoulement non visible</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: orange; width:10px; height:10px; border-radius:50%;"></span> √âcoulement visible faible</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: green; width:10px; height:10px; border-radius:50%;"></span> √âcoulement visible acceptable</div>
    </div>

    <!-- AJOUT RESTRICTIONS D'EAU D√âBUT -->
    <div id="legend-restrictions">
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #f9f871; width:10px; height:10px; border-radius:50%;"></span> Vigilance Restriction</div>
    <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #f59e0b; width:10px; height:10px; border-radius:50%;"></span> Alerte</div>
    <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #ef4444; width:10px; height:10px; border-radius:50%;"></span> Alerte renforc√©e</div>
    <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #b91c1c; width:10px; height:10px; border-radius:50%;"></span> Crise</div>
    </div> <!-- fin legend-restrictions -->
    <!-- AJOUT RESTRICTIONS D'EAU FIN -->

    <!-- L√©gende pour les obstacles √† l'√©coulement -->
    <!-- L√©gendes pour les nouvelles couches Sandre -->
    <div id="legend-bassins" style="display: none;">
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #1e40af; width:15px; height:10px; opacity:0.3; border:2px solid #1e40af;"></span> Bassins versants</div>
    </div>
    <div id="legend-masses-eau" style="display: none;">
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #10b981; width:15px; height:10px; opacity:0.3; border:2px solid #10b981;"></span> Masses d'eau</div>
    </div>
    <div id="legend-zones-humides" style="display: none;">
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #059669; width:15px; height:10px; opacity:0.4; border:2px solid #059669;"></span> Zones humides</div>
    </div>
    <div id="legend-her" style="display: none;">
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #7c3aed; width:15px; height:10px; opacity:0.3; border:2px solid #7c3aed;"></span> HER Montagne</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #10b981; width:15px; height:10px; opacity:0.3; border:2px solid #10b981;"></span> HER Grandes vall√©es</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #f59e0b; width:15px; height:10px; opacity:0.3; border:2px solid #f59e0b;"></span> HER Plaine</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #0ea5e9; width:15px; height:10px; opacity:0.3; border:2px solid #0ea5e9;"></span> HER Littoral</div>
    </div>
    <div id="legend-sage" style="display: none;">
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #10b981; width:15px; height:10px; opacity:0.25; border:2px solid #10b981; border-style: dashed;"></span> SAGE approuv√©</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #f59e0b; width:15px; height:10px; opacity:0.25; border:2px solid #f59e0b; border-style: dashed;"></span> SAGE en cours</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: #ef4444; width:15px; height:10px; opacity:0.25; border:2px solid #ef4444; border-style: dashed;"></span> SAGE √©mergence</div>
    </div>
    <div id="legend-obstacles">
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: red; width:10px; height:10px; border-radius:50%;"></span> Obst. impact fort</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: orange; width:10px; height:10px; border-radius:50%;"></span> Obst. impact mod√©r√©</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: green; width:10px; height:10px; border-radius:50%;"></span> Obst. impact faible</div>
        <div class="map-legend-item"><span class="map-legend-shape" style="background-color: gray; width:10px; height:10px; border-radius:50%;"></span> Obst. impact ind√©termin√©</div>
    </div>

    <div class="map-legend-item">
      <svg class="map-legend-shape" width="15" height="15" viewBox="0 0 24 24" fill="none">
        <path d="M12 2C8.5 6 7 9.5 7 13c0 3.31 2.69 6 5 6s5-2.69 5-6c0-3.5-1.5-7-5-11z" fill="#3B82F6"/>
        <path d="M9 13c1.5-1.5 4-1.5 6 0" stroke="#ffffff" stroke-width="1" stroke-linecap="round"/>
        <path d="M12 16v3" stroke="#ffffff" stroke-width="1" stroke-linecap="round"/>
        <path d="M12 19l-1-1m1 1l1-1" stroke="#ffffff" stroke-width="1" stroke-linecap="round"/>
      </svg>
      D√©bits (Hydrom√©trie)
    </div>
    <div class="map-legend-item">
      <svg class="map-legend-shape" width="15" height="15" viewBox="0 0 24 24" fill="none">
        <path d="M12 2C9 5 8 9 8 12c0 3.86 3.14 7 4 8 0 0 4-4.14 4-8 0-3-1-7-4-10z" fill="#10B981"/>
        <path d="M6 17h12" stroke="#059669" stroke-width="1" stroke-linecap="round"/>
        <path d="M7 19h10" stroke="#059669" stroke-width="1" stroke-linecap="round"/>
        <path d="M8 21h8" stroke="#059669" stroke-width="1" stroke-linecap="round"/>
      </svg>
      Nappes (Pi√©zom√©trie)
    </div>
    <div class="map-legend-item">
      <svg class="map-legend-shape" width="15" height="15" viewBox="0 0 24 24" fill="none">
        <path d="M12 2C8.5 6 7 9.5 7 13c0 3.31 2.69 6 5 6s5-2.69 5-6c0-3.5-1.5-7-5-11z" fill="#F97316"/>
        <rect x="11" y="12" width="2" height="5" rx="1" fill="#ffffff"/>
        <path d="M12 17v3" stroke="#ffffff" stroke-width="1" stroke-linecap="round"/>
        <path d="M12 20l-1-1m1 1l1-1" stroke="#ffffff" stroke-width="1" stroke-linecap="round"/>
      </svg>
      Pr√©l√®vements
    </div>
    <div class="map-legend-item">
      <!-- Ic√¥ne √©prouvette pour la qualit√© de l'eau -->
      <svg class="map-legend-shape" width="15" height="15" viewBox="0 0 24 24" fill="none">
        <path d="M7 2h10v2H15v12a5 5 0 1 1-6 0V4H7V2z" fill="#8B5CF6"></path>
        <path d="M9 8h6" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path>
      </svg>
      Qualit√© d'eau
    </div>
    <div class="map-legend-item">
      <!-- Ic√¥ne feuille pour flore/faune -->
      <svg class="map-legend-shape" width="15" height="15" viewBox="0 0 24 24" fill="none">
        <path d="M12 2c-3 4-5 6.5-5 10 0 4 3 7 5 9 2-2 5-5 5-9 0-3.5-2-6-5-10z" fill="#10B981"></path>
        <path d="M12 13l-2-2m2 2l2-2" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path>
      </svg>
      Flore/Faune
    </div>
    <div id="sensitivity-legend" style="display: none;">Sensibilit√© : <span style="color:red">Haut (&gt;70%)</span> <span style="color:orange">Moyen (40-70%)</span> <span style="color:green">Bas (&lt;40%)</span></div>
    <div id="projection-legend">Projection : Bordure rouge (D√©gradation), orange (Stable vigilance), vert (Am√©lioration)</div>
</div>

                        <div id="map-container">
                            <!-- Boutons de contr√¥le de la carte -->
                            <button class="map-control-btn fullscreen-btn" onclick="window.toggleFullscreen()" title="Mode plein √©cran">‚õ∂</button>
                            <button class="map-control-btn exit-fullscreen-btn" onclick="window.exitFullscreen()" title="Quitter le plein √©cran">‚úï</button>
                            <button class="map-control-btn download-btn" onclick="downloadMap()" title="T√©l√©charger la carte">üì•</button>
                            
                            <!-- Contr√¥les de couches pour le mode plein √©cran -->
                            <div class="map-controls-overlay" id="map-controls-overlay">
                                <h4 style="margin: 0 0 10px 0; font-weight: bold; color: #005566; font-size: 14px;">Contr√¥les des Couches</h4>
                                <div class="fullscreen-layer-controls">
                                    <div class="layer-control">
                                        <label>Stations</label>
                                        <input type="checkbox" class="switch" id="fs-ecoulement-toggle" onchange="toggleEcoulementFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>D√©bits</label>
                                        <input type="checkbox" class="switch" id="fs-debits-toggle" onchange="toggleDebitsFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Nappes</label>
                                        <input type="checkbox" class="switch" id="fs-nappes-toggle" onchange="toggleNappesFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Pr√©l√®vements</label>
                                        <input type="checkbox" class="switch" id="fs-prelevements-toggle" onchange="togglePrelevementsFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Restrictions</label>
                                        <input type="checkbox" class="switch" id="fs-restrictions-toggle" onchange="toggleRestrictionsFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Qualit√© d'eau</label>
                                        <input type="checkbox" class="switch" id="fs-qualite-toggle" onchange="toggleQualiteFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Flore/Faune</label>
                                        <input type="checkbox" class="switch" id="fs-flore-toggle" onchange="toggleFloreFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Obstacles WFS <span style="background: #22c55e; color: white; font-size: 9px; padding: 1px 3px; border-radius: 2px;">‚úì PR√âCIS</span></label>
                                        <input type="checkbox" class="switch" id="fs-obstacles-toggle" onchange="toggleObstaclesFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Bassins versants</label>
                                        <input type="checkbox" class="switch" id="fs-bassins-toggle" onchange="toggleBassinsFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Masses d'eau</label>
                                        <input type="checkbox" class="switch" id="fs-masses-toggle" onchange="toggleMassesFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Zones humides</label>
                                        <input type="checkbox" class="switch" id="fs-zones-toggle" onchange="toggleZonesFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Hydro-√©cor√©gions</label>
                                        <input type="checkbox" class="switch" id="fs-her-toggle" onchange="toggleHerFromFullscreen()">
                                    </div>
                                    <div class="layer-control">
                                        <label>Zones SAGE</label>
                                        <input type="checkbox" class="switch" id="fs-sage-toggle" onchange="toggleSageFromFullscreen()">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl">
                <h3 class="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-2">Analyse des Tendances</h3>
                <p class="text-sm text-gray-500 dark:text-gray-400 mb-4">Tableau r√©capitulatif des tendances bas√© sur les deux derniers relev√©s ou la comparaison avec l'ann√©e pr√©c√©dente. Les stations √† faible √©coulement r√©current sont mises en √©vidence. Projections bas√©es sur pr√©visions m√©t√©o Open-Meteo (7 jours). Cliquez sur une ligne pour voir les pr√©visions journali√®res d√©taill√©es.</p>
                <div class="legend-container">
                    <div class="legend-item"><span class="trend-up">‚Üó</span> Am√©lioration</div>
                    <div class="legend-item"><span class="trend-down">‚Üò</span> D√©gradation</div>
                    <div class="legend-item"><span class="trend-stable">‚Üî</span> Stable</div>
                </div>
                <div class="overflow-x-auto mt-4">
                    <table id="trendTable" class="w-full text-sm text-gray-800 dark:text-gray-200 border-collapse">
                        <thead>
                            <tr class="table-header">
                                <th class="p-3 border">Station/Groupe</th>
                                <th class="p-3 border">Total Obs.</th>
                                <th class="p-3 border">Dates des relev√©s</th>
                                <th class="p-3 border">Modalit√©s des relev√©s</th>
                                <th class="p-3 border">Tendance</th>
                                <th class="p-3 border">Donn√©es M√©t√©o (7j)</th>
                                <th class="p-3 border">Projection √©volution d'ecoulement</th>
                                <th class="p-3 border">Recommandation</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
                <!-- Le bouton d'analyse IA et la section correspondante ont √©t√© supprim√©s pour rationaliser l'interface. L'analyse avanc√©e est d√©sormais accessible via un modal d√©di√©. -->
        </div>

        <div id="forecastModal">
            <div class="modal-content dark:bg-gray-800 dark:text-gray-200">
                <span onclick="document.getElementById('forecastModal').style.display='none'" class="cursor-pointer float-right text-2xl">√ó</span>
                <h3 class="text-xl font-semibold mb-4">Pr√©visions M√©t√©o Journali√®res</h3>
                <div id="forecastChart" class="chart-container"></div>
            </div>
        </div>

        <div id="explicativeModal">
            <div class="modal-content dark:bg-gray-800 dark:text-gray-200">
                <span onclick="document.getElementById('explicativeModal').style.display='none'" class="cursor-pointer float-right text-2xl">√ó</span>
                <h1>Note d'Utilisation et Explication des Fonctionnalit√©s de l'Outil d'Analyse Avanc√©e des √âcoulements - Office Fran√ßais de la Biodiversit√© (OFB)</h1>

                <h2>Introduction</h2>
                <p>Cet outil web est con√ßu pour analyser les donn√©es d‚Äô√©coulements hydrologiques de mani√®re avanc√©e et intuitive. Il r√©cup√®re automatiquement les observations d‚Äô√©coulement via l‚ÄôAPI <strong>ONDE</strong> (Hub‚ÄôEau), puis permet de filtrer ces donn√©es, de visualiser les tendances, de g√©n√©rer des projections bas√©es sur des pr√©visions m√©t√©o et d‚Äôexporter des rapports d√©taill√©s. L‚Äôinterface est simple, responsive (adapt√©e aux mobiles et ordinateurs) et supporte un mode sombre automatique. D√©velopp√© en HTML, CSS et JavaScript avec des biblioth√®ques comme ECharts (graphiques) et Leaflet (cartographie), il est marqu√© ¬´‚ÄØby SD40 2025‚ÄØ¬ª pour indiquer sa version.</p>
<p>Cette nouvelle version de l‚Äôoutil s‚Äôappuie directement sur les API du service Hub‚ÄôEau pour r√©cup√©rer les observations d‚Äô√©coulement (ONDE) ainsi que d‚Äôautres donn√©es hydrologiques et environnementales (d√©bits, nappes, pr√©l√®vements, qualit√© physico‚Äëchimique des cours d‚Äôeau, hydrobiologie). La fonction de chargement de fichier Excel est supprim√©e au profit d‚Äôun t√©l√©chargement automatis√© des observations via l‚ÄôAPI ONDE pour le d√©partement s√©lectionn√©. L‚Äôinterface permet de filtrer ces donn√©es, de visualiser les tendances, de g√©n√©rer des projections bas√©es sur des pr√©visions m√©t√©o et de consulter plusieurs couches th√©matiques (qualit√©, flore, etc.). Les rapports peuvent √™tre export√©s en PDF et Word. L‚Äôoutil est d√©velopp√© en HTML, CSS et JavaScript avec ECharts pour les graphiques et Leaflet pour la cartographie.</p>
                <p>Si vous √™tes nouveau, cette note vous guide pas √† pas. L'objectif est d'aider √† identifier les tendances de d√©gradation ou d'am√©lioration des √©coulements, en se concentrant sur des modalit√©s comme "assec" (s√©cheresse), "√©coulement non visible", "√©coulement visible faible" ou "acceptable". L'outil int√®gre des donn√©es m√©t√©o via l'API Open-Meteo et utilise des calculs statistiques pour des analyses fiables. Aucune installation n'est requise : ouvrez simplement le fichier HTML dans un navigateur (Chrome recommand√©).</p>

                <h2>Fonctionnalit√©s Principales</h2>
                <p>L'outil est divis√© en sections pour une utilisation fluide. Voici un aper√ßu des fonctionnalit√©s cl√©s :</p>
                <ol>
                    <li><strong>Importation de Donn√©es</strong> :
                        <ul>
                            <li>Les donn√©es d'√©coulement sont r√©cup√©r√©es directement via l'API <strong>ONDE</strong> gr√¢ce au bouton ¬´¬†Charger ONDE¬†¬ª. L'outil interroge le service Hub‚ÄôEau et importe automatiquement les stations, dates d'observation, modalit√©s et coordonn√©es pour le d√©partement s√©lectionn√©.</li>
                            <li>Les anciennes fonctions d'importation de fichiers Excel ont √©t√© supprim√©es : vous n'avez plus √† pr√©parer un fichier en amont.</li>
                            <li>Les coordonn√©es des stations sont converties en latitude/longitude (WGS84) si n√©cessaire et associ√©es √† chaque station pour l'affichage cartographique.</li>
                        </ul>
                    </li>
                    <li><strong>Filtres et Groupes</strong> :
                        <ul>
                            <li>S√©lection multiple de stations, ann√©es ou modalit√©s via les menus d√©roulants.</li>
                            <li>Cr√©ez des groupes : S√©lectionnez des stations, saisissez un nom dans "Nom du groupe", et cliquez sur "‚ûï Groupe" (utile pour analyser des r√©gions).</li>
                            <li>Options : "Inclure Pr√©visions M√©t√©o" pour ajouter des projections m√©t√©orologiques aux tendances. La comparaison avec l‚Äôann√©e pr√©c√©dente a √©t√© retir√©e pour simplifier l‚Äôinterface.</li>
                            <li>Recherche : Tapez dans "Rechercher stations/groupes" pour filtrer rapidement.</li>
                            <li>R√©initialisez tout avec "üîÑ R√©initialiser".</li>
                        </ul>
                    </li>
                    <li><strong>R√©sum√© Statistique</strong> :
                        <ul>
                            <li>Affiche des cartes avec le total d'observations, le nombre de stations actives, et les pourcentages par modalit√© (ex. : % assec).</li>
                            <li>Utile pour un aper√ßu rapide des donn√©es filtr√©es.</li>
                        </ul>
                    </li>
                    <li><strong>Classements</strong> :
                        <ul>
                            <li>"Top 10 Stations avec Variations Importantes" : Liste les stations avec les plus grands changements de modalit√©s (bas√© sur un score de variation).</li>
                            <li>"Stations les Plus D√©grad√©es" : Liste les stations avec la plus haute proportion de modalit√©s d√©grad√©es (assec, non visible, faible).</li>
                        </ul>
                    </li>
                    <li><strong>Visualisations</strong> :
                        <ul>
                            <li>Graphiques interactifs : r√©partition par station (barres empil√©es), modalit√©s globales (pie chart), √©volution annuelle (lignes avec aires), tendances par station/groupe (lignes ou barres).</li>
                            <li>Carte interactive (agrandie pour meilleure visibilit√©) : Localise les stations avec couleurs (modalit√©s), fl√®ches (tendances), et bordures (projections m√©t√©o). Activez "Afficher Stations Sensibles" pour mettre en √©vidence les stations √† risque et utilisez les <strong>boutons glissants</strong> pour afficher ou masquer les diff√©rentes couches (Stations d'√©coulement, D√©bits, Nappes, Pr√©l√®vements et Restrictions d'eau).</li>
                            <li>Outils de zoom et t√©l√©chargement d'images pour chaque graphique (ic√¥nes modernes pour une meilleure UX).</li>
                        </ul>
                    </li>
                    <li><strong>Analyse des Tendances</strong> :
                        <ul>
                            <li>Tableau r√©capitulatif : Pour chaque station/groupe, affiche le total d'observations, dates/modalit√©s des relev√©s, tendance (‚Üó/‚Üò/‚Üî), donn√©es m√©t√©o, projection d'√©volution, et recommandations.</li>
                            <li>Cliquez sur une ligne pour voir les pr√©visions m√©t√©o d√©taill√©es journali√®res r√©elles (graphique avec valeurs par jour, pas moyenn√©es).</li>
                            <li>L√©gende : ‚Üó Am√©lioration, ‚Üò D√©gradation, ‚Üî Stable.</li>
                        </ul>
                    </li>
                    <li><strong>Analyse spatio‚Äëtemporelle et multi‚Äëparam√®tres</strong> :
                        <ul>
                            <li><strong>Indice de sensibilit√©</strong> : Calcul d‚Äôun indice de risque qui combine variation, proportion de modalit√©s d√©grad√©es, pr√©cipitations, temp√©rature, pr√©l√®vements, niveaux de nappes, d√©bits et restrictions. Les stations sont class√©es en trois niveaux (faible, moyen, √©lev√©).</li>
                            <li><strong>Corr√©lation multivari√©e</strong> : Calcul et affichage d‚Äôune matrice de corr√©lation de Pearson entre toutes les variables disponibles afin de d√©tecter des relations fortes, positives ou inverses.</li>
                            <li><strong>Clustering</strong> : Utilisation d‚Äôun algorithme k‚Äëmeans pour regrouper les stations selon leurs comportements hydrologiques similaires (zones critiques, interm√©diaires ou pr√©serv√©es).</li>
                            <li><strong>Synth√®se narrative</strong> : R√©sum√© automatique des stations √† faible √©coulement r√©current, principales corr√©lations observ√©es, r√©partition des niveaux de risque et station(s) √† risque √©lev√© sous restriction. Possibilit√© d‚Äôexporter le rapport d‚Äôanalyse en Word.</li>
                        </ul>
                    </li>
                    <li><strong>Exportation</strong> :
                        <ul>
                            <li>Cliquez sur "üìù Rapport Analyse D√©taill√©e" pour g√©n√©rer un fichier HTML (ouvrable dans Word) comprenant des r√©sum√©s, tableaux, graphiques captur√©s et analyses (variance inter-annuelle, corr√©lation de Spearman).</li>
                            <li>Cliquez sur "üìÑ Export PDF" pour g√©n√©rer un rapport PDF complet reprenant les principaux graphiques et un r√©sum√© de vos filtres et statistiques.</li>
                        </ul>
                    </li>
                    <li><strong>Autres</strong> :
                        <ul>
                            <li>Mode sombre automatique.</li>
                            <li>Messages : Spinner pendant le chargement, alertes pour erreurs (ex. : fichier invalide).</li>
                            <li>Cache : Les pr√©visions m√©t√©o sont mises en cache 1 heure pour acc√©l√©rer les analyses.</li>
                        </ul>
                    </li>
                </ol>

                <h2>Comment Utiliser l'Outil √âtape par √âtape</h2>
                <ol>
                    <li><strong>Ouverture</strong> : Ouvrez le fichier HTML dans votre navigateur.</li>
                    <li><strong>Chargement des Donn√©es</strong>¬†: Cliquez sur ¬´¬†Charger ONDE¬†¬ª pour t√©l√©charger automatiquement les observations d‚Äô√©coulement via l‚ÄôAPI (stations, dates et modalit√©s). Patientez jusqu‚Äô√† l‚Äôaffichage du message de succ√®s (ex.¬†: ¬´¬†X observations ONDE charg√©es¬†!¬ª).</li>
                    <li><strong>Filtrage</strong> :
                        <ul>
                            <li>Choisissez des stations/ann√©es/modalit√©s.</li>
                            <li>Pour un groupe : S√©lectionnez stations, entrez nom, cliquez "‚ûï Groupe".</li>
                            <li>Activez options (comparaison, m√©t√©o) si besoin.</li>
                        </ul>
                    </li>
                    <li><strong>Exploration</strong> :
                        <ul>
                            <li>Consultez le "R√©sum√©" pour les stats globales.</li>
                            <li>V√©rifiez les "Classements" pour les tops.</li>
                            <li>Explorez les "Visualisations" : zoomez et t√©l√©chargez les graphiques. Sur la carte agrandie, activez/masquez les couches √† l‚Äôaide des boutons glissants (Stations d'√©coulement, D√©bits, Nappes, Pr√©l√®vements, Restrictions d'eau, Qualit√© d'eau et Flore/Faune) et basculez en mode sensible pour mettre en √©vidence les stations √† risque.</li>
                            <li>Analysez les "Tendances" : Lisez recommandations, cliquez sur une ligne pour pr√©visions journali√®res r√©elles.</li>
                            <li>Cliquez sur ¬´ Analyse spatio‚Äëtemporelle et multi‚Äëparam√®tres ¬ª pour acc√©der √† la synth√®se avanc√©e : indices de risque, corr√©lations multivari√©es et clustering des stations.</li>
                        </ul>
                    </li>
                    <li><strong>Export</strong> : G√©n√©rez un rapport HTML (ouvrable dans Word) ou un PDF complet via les boutons d'exportation situ√©s en haut de l'interface.</li>
                    <li><strong>Astuces</strong>¬†: Si la carte n'appara√Æt pas, assurez‚Äëvous que les donn√©es ONDE se sont bien charg√©es (un message confirme le nombre d‚Äôobservations). Pour toute erreur, rechargez la page. Utilisez les info‚Äëbulles (tooltips) pour plus d‚Äôinformations sur chaque √©l√©ment de l‚Äôinterface.</li>
                </ol>

                <h2>Formules et M√©thodologies Utilis√©es</h2>
                <p>L'outil utilise des calculs simples mais robustes pour analyser les donn√©es. Voici une explication accessible, sans maths complexes. Les seuils (ex. : 0.5 pour tendances) sont configurables dans le code si vous √™tes d√©veloppeur.</p>

                <h3>Pond√©ration des Modalit√©s</h3>
                <p>Chaque type d'√©coulement a un "poids" refl√©tant sa gravit√© :</p>
                <ul>
                    <li>Assec : 4 (tr√®s d√©grad√©)</li>
                    <li>√âcoulement non visible : 3</li>
                    <li>√âcoulement visible faible : 2</li>
                    <li>√âcoulement visible acceptable : 1 (bon)</li>
                    <li>Autres : 1.5</li>
                </ul>
                <p>Formule du poids moyen pour un groupe de relev√©s :</p>
                <pre><code>Poids moyen = (Somme des poids de chaque relev√©) / Nombre de relev√©s</code></pre>
                <p>Cela permet de quantifier si l'√©coulement est "mauvais" (poids √©lev√©) ou "bon" (poids bas).</p>

                <h3>Calcul de la Tendance</h3>
                <p>Compare le poids moyen entre deux p√©riodes (derniers relev√©s ou ann√©es) :</p>
                <pre><code>Diff√©rence = Poids courant - Poids pr√©c√©dent</code></pre>
                <ul>
                    <li>Si > 0.5 : D√©gradation (‚Üò, situation empire)</li>
                    <li>Si < -0.5 : Am√©lioration (‚Üó, situation s'am√©liore)</li>
                    <li>Sinon : Stable (‚Üî)</li>
                </ul>
                <p>Pourcentages par modalit√© (pour d√©tails) :</p>
                <pre><code>% Modalit√© = (Nombre de cette modalit√© / Total relev√©s) √ó 100</code></pre>

                <h3>Projection d'√âvolution (M√©t√©o)</h3>
                <p>Bas√©e sur la derni√®re modalit√© et pr√©visions (pluie cumul√©e, temp√©rature moyenne sur 7 jours via Open-Meteo) :</p>
                <pre><code>Risque (%) = (Poids dernier √ó 50) + ((10 - Pluie) √ó 5) + ((Temp√©rature - 15) √ó 2)</code></pre>
                <ul>
                    <li>Risque limit√© √† 0-100.</li>
                    <li>>70% : D√©gradation probable (rouge, alerte)</li>
                    <li>30-70% : Stable avec vigilance (orange)</li>
                    <li><30% : Am√©lioration possible (vert)</li>
                </ul>
                <p>Les pr√©visions journali√®res sont affich√©es en d√©tail sur clic (valeurs r√©elles par jour).</p>

                <h3>Score de Variation (Changements Importants)</h3>
                <p>Mesure combien les % de modalit√©s changent d'une ann√©e √† l'autre :</p>
                <p>Pour deux ann√©es :</p>
                <pre><code>Variation = Somme des |% courant - % pr√©c√©dent| / Nombre de modalit√©s</code></pre>
                <p>Moyenne globale :</p>
                <pre><code>VariationMoyenne = Somme des variations / Nombre de paires d'ann√©es</code></pre>
                <p>Utilis√© pour le top 10 des stations variables.</p>

                <h3>Pourcentage D√©grad√©</h3>
                <pre><code>% D√©grad√© = (Nombre de modalit√©s d√©grad√©es / Total observations) √ó 100</code></pre>
                <p>D√©grad√©es : assec, non visible, faible.</p>

                <h3>Corr√©lation Spearman</h3>
                <p>Mesure si les stations avec beaucoup de variations sont souvent d√©grad√©es (valeur entre -1 et 1) :</p>
                <pre><code>œÅ = 1 - (6 √ó Somme des (diff√©rences de rangs)^2) / (n √ó (n¬≤ - 1))</code></pre>
                <p>o√π n = nombre de stations, rangs bas√©s sur scores. Si proche de 1 : Forte lien (utilis√© dans le score de sensibilit√©).</p>

                <h3>Score de Sensibilit√© (Stations Sensibles)</h3>
                <pre><code>Sensibilit√© (%) = (% D√©grad√© √ó 0.4) + (Variation √ó 0.3) + (Si r√©current : +30) + (Si corr√©lation >0.5 : corr√©lation √ó 30)</code></pre>
                <p>Limit√© √† 0-100. Couleurs sur carte : rouge (>70%), orange (40-70%), vert (<40%).</p>

                <h3>√âcoulement Faible R√©current</h3>
                <p>Si ‚â•50% des ann√©es ont ‚â•50% de modalit√©s d√©grad√©es (et au moins 2 ann√©es) : Station r√©currente (flag dans tableau).</p>

                <h3>Indice de sensibilit√© et corr√©lations multi‚Äëparam√®tres</h3>
                <p>Le volet d‚Äôanalyse spatio‚Äëtemporelle calcule pour chaque station un indice de risque en combinant plusieurs param√®tres&nbsp;: la variation du poids moyen des modalit√©s, la proportion de modalit√©s d√©grad√©es, les pr√©cipitations cumul√©es, la temp√©rature moyenne, les volumes de pr√©l√®vements, les niveaux de nappes, les d√©bits et le nombre/intensit√© des restrictions d‚Äôeau. Cet indice permet de classer les stations selon trois niveaux de risque (faible, moyen, √©lev√©). Un algorithme de <em>clustering</em> (k‚Äëmeans) regroupe ensuite les stations selon leurs comportements hydrologiques similaires. Une matrice de corr√©lation de Pearson met enfin en lumi√®re les relations positives ou inverses entre toutes les variables (par exemple, la corr√©lation entre le nombre de restrictions et l‚Äôindice de risque).</p>

                <p>Ces calculs offrent une vision approfondie du fonctionnement hydrologique dans le d√©partement. Pour plus de d√©tails sur les m√©thodes utilis√©es, consultez le code JavaScript (sections <code>computeCorrelationMatrix</code> et <code>computeRiskAndClusters</code>). Si vous avez des questions, testez l‚Äôoutil en important les donn√©es ONDE via le bouton d√©di√© ou contactez votre √©quipe technique.</p>
            </div>
        </div>
    <script>
        let data = [];
        let allStations = [];
        let allYears = [];
        let allModalities = [];
        let stationGroups = {};
        let charts = {};
        let comparePreviousYear = false;
        let includeWeather = true;
        let stationCoordinates = {};
        let map = null;
        let projections = [];
        let heatLayer;
        let sensitiveMode = false;
        let hubEauDebits = {};
        let stationHubCodes = {};
        // Mapping des noms de station vers leur code OFB (num√©ro d√©partement + index 7 chiffres).
        // Ce mapping est g√©n√©r√© dynamiquement dans loadDataFromONDE.
        let stationCodesOfb = {};
let ecoulementLayer, hydroLayer, piezoLayer, prelLayer, restrictionsLayer, obstaclesLayer, bassinsLayer, massesEauLayer, zonesHumidesLayer, qualiteLayer, floraLayer, herLayer, sageLayer;
// Variable globale repr√©sentant le d√©partement s√©lectionn√©.  
// Par d√©faut, le d√©partement 40 (Landes) est utilis√© ; il est mis √† jour via la liste d√©roulante.
let selectedDept = '40';
let layerControl;

        // Cache pour les obstacles Sandre WFS avec expiration
        let obstaclesCache = {};

        // Bounding boxes approximatives des d√©partements fran√ßais pour filtrage g√©ographique
        function getDepartmentBbox(deptCode) {
            const deptBboxes = {
                '40': { minLon: -1.6, minLat: 43.4, maxLon: 0.4, maxLat: 44.6 }, // Landes (zone optimis√©e)
                '69': { minLon: 4.0, minLat: 45.2, maxLon: 5.4, maxLat: 46.5 }, // Rh√¥ne (√©tendu)
                '75': { minLon: 2.2, minLat: 48.8, maxLon: 2.5, maxLat: 48.9 }, // Paris
                '33': { minLon: -1.5, minLat: 43.9, maxLon: 0.6, maxLat: 45.8 }, // Gironde (√©tendu)
                '31': { minLon: 0.2, minLat: 42.5, maxLon: 2.2, maxLat: 44.0 }, // Haute-Garonne (√©tendu)
                '64': { minLon: -2.2, minLat: 42.7, maxLon: 0.6, maxLat: 43.8 }, // Pyr√©n√©es-Atlantiques (√©tendu)
                '06': { minLon: 6.4, minLat: 43.2, maxLon: 7.9, maxLat: 44.6 }, // Alpes-Maritimes (√©tendu)
                '13': { minLon: 4.0, minLat: 42.9, maxLon: 6.0, maxLat: 44.1 }, // Bouches-du-Rh√¥ne (√©tendu)
                '59': { minLon: 1.9, minLat: 49.8, maxLon: 4.4, maxLat: 51.3 }, // Nord (√©tendu)
                '62': { minLon: 1.4, minLat: 49.8, maxLon: 3.4, maxLat: 51.1 }, // Pas-de-Calais (√©tendu)
                '78': { minLon: 1.2, minLat: 48.4, maxLon: 2.4, maxLat: 49.3 }, // Yvelines (√©tendu)
                '92': { minLon: 2.0, minLat: 48.6, maxLon: 2.4, maxLat: 49.0 }, // Hauts-de-Seine (√©tendu)
                '93': { minLon: 2.2, minLat: 48.7, maxLon: 2.7, maxLat: 49.1 }, // Seine-Saint-Denis (√©tendu)
                '94': { minLon: 2.2, minLat: 48.5, maxLon: 2.7, maxLat: 49.0 } // Val-de-Marne (√©tendu)
            };
            return deptBboxes[deptCode] || null;
        }
        
        // Fonction pour r√©cup√©rer les obstacles via l'API Sandre WFS avec coordonn√©es pr√©cises EPSG:4326
        async function getSandreObstaclesByDepartment(deptCode) {
            // V√©rifier le cache (5 minutes)
            const cacheKey = `obstacles_${deptCode}`;
            const cached = obstaclesCache[cacheKey];
            if (cached && (Date.now() - cached.timestamp) < 300000) {
                console.log(`‚úì Obstacles du d√©partement ${deptCode} r√©cup√©r√©s depuis le cache`);
                return cached.data;
            }
            
            try {
                console.log(`üîÑ R√©cup√©ration obstacles WFS Sandre pour d√©partement ${deptCode}...`);
                
                // URL du service WFS Sandre pour les obstacles √† l'√©coulement (API ROE officielle - VALID√âE)
                const wfsUrl = 'https://services.sandre.eaufrance.fr/geo/obs';
                const params = new URLSearchParams({
                    service: 'WFS',
                    version: '1.1.0',
                    request: 'GetFeature',
                    typeName: 'ObstEcoul',
                    srsName: 'EPSG:4326',
                    maxFeatures: '1000'
                });
                
                // Ajout du filtre g√©ographique pour le d√©partement s√©lectionn√©
                if (deptCode && deptCode !== 'all') {
                    const bbox = getDepartmentBbox(deptCode);
                    if (bbox) {
                        params.append('bbox', `${bbox.minLon},${bbox.minLat},${bbox.maxLon},${bbox.maxLat}`);
                    }
                }
                
                const response = await fetch(`${wfsUrl}?${params}`, {
                    headers: {
                        'Accept': 'application/xml, text/xml',
                        'User-Agent': 'OFB-Flow-Analysis/1.0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const xmlText = await response.text();
                const obstacles = [];
                
                // Parser le XML GML retourn√© par le service WFS Sandre
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                
                // Rechercher les features dans la r√©ponse XML (format ObstEcoul de l'API officielle)
                const features = xmlDoc.getElementsByTagNameNS('*', 'ObstEcoul') || 
                                xmlDoc.getElementsByTagName('sa:ObstEcoul');
                
                console.log(`üìç ${features.length} features trouv√©es dans la r√©ponse WFS Sandre`);
                
                for (let i = 0; i < features.length; i++) {
                    try {
                        const feature = features[i];
                        
                        // Extraire les coordonn√©es du point
                        const posElement = feature.getElementsByTagNameNS('*', 'pos')[0] || 
                                         feature.getElementsByTagName('gml:pos')[0];
                        
                        if (!posElement) continue;
                        
                        const posText = posElement.textContent.trim();
                        const coords = posText.split(' ').map(parseFloat);
                        
                        if (coords.length < 2 || isNaN(coords[0]) || isNaN(coords[1])) {
                            console.warn('‚ö†Ô∏è Coordonn√©es invalides ignor√©es:', posText);
                            continue;
                        }
                        
                        // Fonction helper pour extraire les donn√©es XML
                        const getId = (tagName) => {
                            const element = feature.getElementsByTagNameNS('*', tagName)[0] || 
                                          feature.getElementsByTagName(`sa:${tagName}`)[0];
                            return element ? element.textContent.trim() : '';
                        };
                        
                        const lat = coords[0];
                        const lon = coords[1];
                        
                        // Extraction des propri√©t√©s de l'obstacle
                        const nom = getId('NomPrincipalObstEcoul') || 'Obstacle sans nom';
                        const type = getId('LbTypeOuvrage') || 'Non sp√©cifi√©';
                        const hauteur = parseFloat(getId('HautChutEtObstEcoul')) || 0;
                        const commune = getId('LbCommune') || '';
                        const departement = getId('CdDepartement') || '';
                        const nomDepartement = getId('LbDepartement') || '';
                        const coursEau = getId('NomEntiteHydrographique') || '';
                        const cdObstacle = getId('CdObstEcoul') || '';
                        const etatOuvrage = getId('LbEtOuvrage') || '';
                        const usagePrincipal = getId('LbUsageObstEcoul1') || '';
                        const bassin = getId('NomCircAdminBassin') || '';
                        const altitude = getId('AltiPointCarOuvrage') || '';
                        const hauteurClassification = getId('LbHautChutClObstEcoul') || '';
                        
                        // Filtrage strict par d√©partement - seulement les obstacles du d√©partement s√©lectionn√©
                        const isInTarget = deptCode === 'all' || departement === deptCode;
                        
                        if (isInTarget) {
                            obstacles.push({
                                lat: lat,
                                lon: lon,
                                name: nom,
                                type: type,
                                height: hauteur,
                                heightClassification: hauteurClassification,
                                river: coursEau,
                                commune: commune,
                                departement: departement,
                                nomDepartement: nomDepartement,
                                usage: usagePrincipal,
                                etat: etatOuvrage,
                                altitude: altitude,
                                bassin: bassin,
                                id: cdObstacle,
                                source: 'ROE Sandre WFS Officiel'
                            });
                            console.log(`‚úÖ ${nom} ajout√© - D√©partement: ${departement} (${nomDepartement || 'nom non d√©fini'})`);
                        }
                        
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Erreur traitement obstacle XML:', error);
                    }
                }
                
                console.log(`‚úÖ ${obstacles.length} obstacles ROE Sandre trait√©s avec coordonn√©es EPSG:4326`);
                console.log(`üìä Total features trouv√©es dans XML: ${features.length}, Obstacles valides ajout√©s: ${obstacles.length}`);
                
                // Cache des r√©sultats
                obstaclesCache[cacheKey] = {
                    data: obstacles,
                    timestamp: Date.now()
                };
                
                return obstacles;
                
            } catch (error) {
                console.error('‚ùå Erreur r√©cup√©ration obstacles Sandre:', error);
                return [];
            }
        }
        
        // Fonction pour mettre √† jour les obstacles selon le d√©partement s√©lectionn√© avec donn√©es WFS Sandre
        async function updateObstaclesLayer() {
            if (!obstaclesLayer) return;
            
            obstaclesLayer.clearLayers();
            
            try {
                console.log(`üîÑ Mise √† jour couche obstacles pour d√©partement ${selectedDept}...`);
                
                // R√©cup√©ration asynchrone des obstacles via Sandre WFS (M√âTHODE VALID√âE)
                const obstacles = await getSandreObstaclesByDepartment(selectedDept);
                console.log(`‚úÖ ${obstacles.length} obstacles Sandre WFS charg√©s avec coordonn√©es pr√©cises`);
                
                obstacles.forEach((item, index) => {
                    console.log(`üó∫Ô∏è Ajout obstacle ${index + 1} sur la carte: ${item.name} aux coordonn√©es [${item.lat}, ${item.lon}]`);
                    
                    // V√©rifier que les coordonn√©es sont valides
                    if (!item.lat || !item.lon || isNaN(item.lat) || isNaN(item.lon)) {
                        console.warn(`‚ö†Ô∏è Coordonn√©es invalides pour ${item.name}: lat=${item.lat}, lon=${item.lon}`);
                        return;
                    }
                    
                    const impactColor = getObstacleColor(item.height);
                    const marker = L.circleMarker([item.lat, item.lon], {
                        color: impactColor,
                        fillColor: impactColor,
                        radius: 8,
                        fillOpacity: 0.9,
                        weight: 3
                    }).addTo(obstaclesLayer);
                    
                    console.log(`‚úÖ Marqueur ajout√© pour ${item.name} avec couleur ${impactColor}`);
                    
                    const heightText = item.height != null ? `${item.height} m` : 'Non d√©finie';
                    const cat = item.heightCat || 'Non d√©finie';
                    let impactMsg;
                    if (impactColor === '#22c55e') impactMsg = 'Impact faible';
                    else if (impactColor === '#f59e0b') impactMsg = 'Impact mod√©r√©';
                    else if (impactColor === '#ef4444') impactMsg = 'Impact fort';
                    else impactMsg = 'Impact ind√©termin√©';
                    
                    const popupContent = `
                        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 350px;">
                            <div style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white; padding: 12px; margin: -10px -10px 15px -10px; border-radius: 8px 8px 0 0;">
                                <h3 style="margin: 0; font-size: 16px; font-weight: 600;">üöß ${item.name}</h3>
                                <p style="margin: 5px 0 0 0; font-size: 13px; opacity: 0.9;">Donn√©es Sandre WFS officielles</p>
                            </div>
                            
                            <div style="padding: 0 5px;">
                                <div style="display: flex; align-items: center; margin-bottom: 12px; padding: 8px; background: ${impactColor}20; border-radius: 6px; border-left: 4px solid ${impactColor};">
                                    <span style="font-weight: 600; color: ${impactColor}; font-size: 14px;">
                                        ${impactMsg}
                                    </span>
                                </div>
                                
                                <div style="space-y: 6px;">
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Type:</span>
                                        <span style="color: #6b7280;">${item.type}</span>
                                    </p>
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Hauteur:</span>
                                        <span style="color: #6b7280; font-weight: 600;">${heightText}</span>
                                    </p>
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Cat√©gorie:</span>
                                        <span style="color: #6b7280;">${cat}</span>
                                    </p>
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Cours d'eau:</span>
                                        <span style="color: #6b7280;">${item.river}</span>
                                    </p>
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Commune:</span>
                                        <span style="color: #6b7280;">${item.commune}</span>
                                    </p>
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">D√©partement:</span>
                                        <span style="color: #6b7280;">${item.nomDepartement || item.departement}</span>
                                    </p>
                                    ${item.heightClassification ? `<p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Classification:</span>
                                        <span style="color: #6b7280;">${item.heightClassification}</span>
                                    </p>` : ''}
                                    ${item.usage ? `<p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Usage principal:</span>
                                        <span style="color: #6b7280; font-size: 12px;">${item.usage}</span>
                                    </p>` : ''}
                                    ${item.etat ? `<p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">√âtat ouvrage:</span>
                                        <span style="color: #6b7280;">${item.etat}</span>
                                    </p>` : ''}
                                    ${item.bassin ? `<p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Bassin:</span>
                                        <span style="color: #6b7280;">${item.bassin}</span>
                                    </p>` : ''}
                                    ${item.altitude ? `<p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Altitude:</span>
                                        <span style="color: #6b7280;">${item.altitude} m</span>
                                    </p>` : ''}
                                    ${item.dateMiseAJour ? `<p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Derni√®re MAJ:</span>
                                        <span style="color: #6b7280; font-size: 11px;">${new Date(item.dateMiseAJour).toLocaleDateString('fr-FR')}</span>
                                    </p>` : ''}
                                    <p style="margin: 8px 0 4px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">ID Sandre:</span>
                                        <span style="color: #6b7280; font-family: monospace; font-size: 11px;">${item.id}</span>
                                    </p>
                                    <p style="margin: 4px 0; display: flex; justify-content: space-between; font-size: 11px;">
                                        <span style="color: #9ca3af;">Coordonn√©es EPSG:4326:</span>
                                        <span style="color: #9ca3af; font-family: monospace;">${(item.coordonnee_y || item.lat || 0).toFixed(6)}, ${(item.coordonnee_x || item.lon || 0).toFixed(6)}</span>
                                    </p>
                                </div>
                            </div>
                        </div>
                    `;
                    marker.bindPopup(popupContent);
                });
                
                // Si des obstacles ont √©t√© trouv√©s, adapter la vue de la carte pour les inclure
                if (obstacles.length > 0) {
                    console.log(`üó∫Ô∏è Centrage de la carte sur ${obstacles.length} obstacles`);
                    
                    const lats = obstacles.map(o => o.lat).filter(lat => !isNaN(lat));
                    const lons = obstacles.map(o => o.lon).filter(lon => !isNaN(lon));
                    
                    if (lats.length > 0 && lons.length > 0) {
                        const bounds = [
                            [Math.min(...lats), Math.min(...lons)],
                            [Math.max(...lats), Math.max(...lons)]
                        ];
                        
                        console.log(`üó∫Ô∏è Limites de la carte: ${bounds[0]} √† ${bounds[1]}`);
                        
                        // Adapter la vue pour inclure tous les obstacles avec un padding
                        try {
                            map.fitBounds(bounds, { padding: [20, 20] });
                        } catch (boundsError) {
                            console.warn('‚ö†Ô∏è Erreur centrage carte:', boundsError);
                            // Fallback: centrer sur le premier obstacle
                            map.setView([lats[0], lons[0]], 12);
                        }
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Erreur lors de la mise √† jour de la couche obstacles:', error);
                
                // Afficher un message d'erreur dans la console uniquement
                console.warn('‚ö†Ô∏è Impossible de charger les obstacles Sandre WFS pour ce d√©partement');
            }
        }

        // === Nouvelles fonctions simples pour bassins versants et masses d'eau ===
        
        function loadBassinsVersants(deptCode) {
            console.log("Chargement des bassins versants pour le d√©partement " + deptCode);
            if (!bassinsLayer) bassinsLayer = L.layerGroup();
            bassinsLayer.clearLayers();
            
            // Donn√©es r√©alistes bas√©es sur le r√©f√©rentiel Sandre BD TOPAGE pour le d√©partement 40
            // Polygones approximatifs des bassins versants des Landes
            const bassinsData = {
                '40': [
                    { 
                        code: "Q0500500", 
                        nom: "L'Adour depuis Dax jusqu'√† la mer", 
                        superficie: 1250,
                        polygon: [
                            [43.9500, -0.4000], [43.9200, -0.3500], [43.8900, -0.3800], 
                            [43.8600, -0.4200], [43.8400, -0.4800], [43.8200, -0.5400],
                            [43.8500, -0.6000], [43.8800, -0.5800], [43.9100, -0.5200],
                            [43.9400, -0.4600], [43.9500, -0.4000]
                        ]
                    },
                    { 
                        code: "Q0520500", 
                        nom: "Le Gave de Pau depuis Peyrehorade", 
                        superficie: 890,
                        polygon: [
                            [43.7800, -0.5500], [43.7600, -0.5000], [43.7200, -0.5200],
                            [43.6800, -0.5800], [43.6600, -0.6400], [43.6800, -0.7000],
                            [43.7200, -0.7200], [43.7600, -0.6800], [43.7800, -0.6200],
                            [43.7800, -0.5500]
                        ]
                    },
                    { 
                        code: "Q0600500", 
                        nom: "La Midouze et affluents", 
                        superficie: 2100,
                        polygon: [
                            [44.2500, -0.6000], [44.2200, -0.5200], [44.1800, -0.5400],
                            [44.1400, -0.6000], [44.1000, -0.6800], [44.0600, -0.7400],
                            [44.0200, -0.8000], [44.0000, -0.8600], [44.0400, -0.9200],
                            [44.0800, -0.9000], [44.1200, -0.8400], [44.1600, -0.7800],
                            [44.2000, -0.7200], [44.2400, -0.6600], [44.2500, -0.6000]
                        ]
                    },
                    { 
                        code: "Q0700500", 
                        nom: "Courants c√¥tiers landais Nord", 
                        superficie: 1800,
                        polygon: [
                            [44.0500, -1.2000], [44.0000, -1.1500], [43.9500, -1.1800],
                            [43.9000, -1.2200], [43.8800, -1.2800], [43.9200, -1.3400],
                            [43.9600, -1.3600], [44.0000, -1.3200], [44.0400, -1.2600],
                            [44.0500, -1.2000]
                        ]
                    },
                    { 
                        code: "Q0710500", 
                        nom: "Courants c√¥tiers landais Sud", 
                        superficie: 1450,
                        polygon: [
                            [43.8500, -1.2500], [43.8000, -1.2000], [43.7500, -1.2200],
                            [43.7000, -1.2600], [43.6800, -1.3200], [43.7200, -1.3800],
                            [43.7600, -1.4000], [43.8000, -1.3600], [43.8300, -1.3000],
                            [43.8500, -1.2500]
                        ]
                    },
                    { 
                        code: "Q0650500", 
                        nom: "La Leyre et √©tangs", 
                        superficie: 1950,
                        polygon: [
                            [44.3500, -0.8000], [44.3200, -0.7200], [44.2800, -0.7400],
                            [44.2400, -0.8000], [44.2000, -0.8600], [44.1800, -0.9200],
                            [44.2200, -0.9800], [44.2600, -1.0000], [44.3000, -0.9600],
                            [44.3400, -0.9000], [44.3600, -0.8400], [44.3500, -0.8000]
                        ]
                    }
                ],
                '33': [
                    { 
                        code: "Q1000500", 
                        nom: "La Garonne estuarienne", 
                        superficie: 2800,
                        polygon: [
                            [44.9000, -0.4000], [44.8500, -0.3500], [44.8000, -0.4000],
                            [44.7500, -0.5000], [44.7000, -0.6000], [44.7500, -0.7000],
                            [44.8000, -0.6500], [44.8500, -0.5500], [44.9000, -0.4500],
                            [44.9000, -0.4000]
                        ]
                    },
                    { 
                        code: "Q1100500", 
                        nom: "La Dordogne aval", 
                        superficie: 1600,
                        polygon: [
                            [44.8000, -0.6000], [44.7500, -0.5500], [44.7000, -0.6000],
                            [44.6500, -0.7000], [44.6000, -0.8000], [44.6500, -0.8500],
                            [44.7000, -0.8000], [44.7500, -0.7000], [44.8000, -0.6500],
                            [44.8000, -0.6000]
                        ]
                    }
                ],
                '64': [
                    { 
                        code: "Q0400500", 
                        nom: "L'Adour depuis Bayonne jusqu'√† la mer", 
                        superficie: 1850,
                        polygon: [
                            [43.4900, -1.4800], [43.4600, -1.4300], [43.4300, -1.4600],
                            [43.4000, -1.5000], [43.3800, -1.5600], [43.4100, -1.6200],
                            [43.4400, -1.6000], [43.4700, -1.5400], [43.4900, -1.4800]
                        ]
                    },
                    { 
                        code: "Q0350500", 
                        nom: "Les Gaves r√©unis depuis Peyrehorade", 
                        superficie: 2650,
                        polygon: [
                            [43.3200, -0.9200], [43.2900, -0.8700], [43.2600, -0.9000],
                            [43.2300, -0.9400], [43.2100, -1.0000], [43.2400, -1.0600],
                            [43.2700, -1.0400], [43.3000, -0.9800], [43.3200, -0.9200]
                        ]
                    },
                    { 
                        code: "Q0300500", 
                        nom: "La Nive et affluents", 
                        superficie: 1200,
                        polygon: [
                            [43.1800, -1.3000], [43.1500, -1.2500], [43.1200, -1.2800],
                            [43.0900, -1.3200], [43.0700, -1.3800], [43.1000, -1.4400],
                            [43.1300, -1.4200], [43.1600, -1.3600], [43.1800, -1.3000]
                        ]
                    },
                    { 
                        code: "Q0280500", 
                        nom: "Gaves pyr√©n√©ens", 
                        superficie: 3400,
                        polygon: [
                            [43.0500, -0.7200], [43.0200, -0.6700], [42.9900, -0.7000],
                            [42.9600, -0.7400], [42.9400, -0.8000], [42.9700, -0.8600],
                            [43.0000, -0.8400], [43.0300, -0.7800], [43.0500, -0.7200]
                        ]
                    }
                ],
                // Nouvelle-Aquitaine
                '17': [
                    { code: "Q8000500", nom: "La Charente estuarienne", superficie: 1200, polygon: [[45.9167, -0.9667], [45.9000, -0.9500], [45.8833, -0.9583], [45.9000, -0.9750], [45.9167, -0.9667]] }
                ],
                '24': [
                    { code: "Q9000500", nom: "La Dordogne moyenne", superficie: 2800, polygon: [[45.0333, 0.7167], [45.0167, 0.7333], [44.9833, 0.7167], [45.0000, 0.7000], [45.0333, 0.7167]] }
                ],
                '87': [
                    { code: "Q7500500", nom: "La Vienne amont", superficie: 1600, polygon: [[45.8333, 1.2667], [45.8167, 1.2833], [45.7833, 1.2667], [45.8000, 1.2500], [45.8333, 1.2667]] }
                ],
                // Occitanie
                '31': [
                    { code: "Q5000500", nom: "La Garonne toulousaine", superficie: 3200, polygon: [[43.6045, 1.4442], [43.5833, 1.4667], [43.5667, 1.4500], [43.5833, 1.4333], [43.6045, 1.4442]] }
                ],
                '34': [
                    { code: "Q3000500", nom: "L'H√©rault", superficie: 2500, polygon: [[43.6119, 3.8772], [43.5950, 3.8900], [43.5783, 3.8783], [43.5950, 3.8667], [43.6119, 3.8772]] }
                ],
                '11': [
                    { code: "Q2500500", nom: "L'Aude", superficie: 2200, polygon: [[43.2139, 2.3508], [43.1950, 2.3650], [43.1783, 2.3533], [43.1950, 2.3417], [43.2139, 2.3508]] }
                ],
                // Auvergne-Rh√¥ne-Alpes
                '69': [
                    { code: "Q1500500", nom: "Le Rh√¥ne lyonnais", superficie: 2900, polygon: [[45.7640, 4.8357], [45.7450, 4.8500], [45.7283, 4.8383], [45.7450, 4.8267], [45.7640, 4.8357]] }
                ],
                '38': [
                    { code: "Q1400500", nom: "L'Is√®re", superficie: 2100, polygon: [[45.1880, 5.7244], [45.1700, 5.7367], [45.1533, 5.7250], [45.1700, 5.7133], [45.1880, 5.7244]] }
                ],
                // Provence-Alpes-C√¥te d'Azur
                '13': [
                    { code: "Q0900500", nom: "Le Rh√¥ne delta", superficie: 1800, polygon: [[43.6792, 4.6298], [43.6600, 4.6433], [43.6433, 4.6317], [43.6600, 4.6200], [43.6792, 4.6298]] }
                ],
                '06': [
                    { code: "Q0800500", nom: "Le Var", superficie: 1400, polygon: [[43.6951, 7.2658], [43.6767, 7.2783], [43.6600, 7.2667], [43.6767, 7.2550], [43.6951, 7.2658]] }
                ],
                // Grand Est
                '67': [
                    { code: "Q0100500", nom: "Le Rhin alsacien", superficie: 2600, polygon: [[48.5734, 7.7521], [48.5550, 7.7650], [48.5383, 7.7533], [48.5550, 7.7417], [48.5734, 7.7521]] }
                ],
                '57': [
                    { code: "Q0200500", nom: "La Moselle", superficie: 2300, polygon: [[49.1194, 6.1757], [49.1000, 6.1883], [49.0833, 6.1767], [49.1000, 6.1650], [49.1194, 6.1757]] }
                ],
                // Bourgogne-Franche-Comt√©
                '21': [
                    { code: "Q1800500", nom: "La Sa√¥ne bourguignonne", superficie: 1900, polygon: [[47.3220, 5.0415], [47.3033, 5.0533], [47.2867, 5.0417], [47.3033, 5.0300], [47.3220, 5.0415]] }
                ],
                // Centre-Val de Loire
                '37': [
                    { code: "Q4500500", nom: "La Loire tourangelle", superficie: 3500, polygon: [[47.3941, 0.6892], [47.3750, 0.7017], [47.3583, 0.6900], [47.3750, 0.6783], [47.3941, 0.6892]] }
                ],
                '45': [
                    { code: "Q4400500", nom: "La Loire orl√©anaise", superficie: 3200, polygon: [[47.9029, 1.9039], [47.8833, 1.9167], [47.8667, 1.9050], [47.8833, 1.8933], [47.9029, 1.9039]] }
                ],
                // √éle-de-France
                '75': [
                    { code: "Q3500500", nom: "La Seine parisienne", superficie: 2800, polygon: [[48.8566, 2.3522], [48.8383, 2.3650], [48.8217, 2.3533], [48.8383, 2.3417], [48.8566, 2.3522]] }
                ],
                '77': [
                    { code: "Q3600500", nom: "La Seine amont", superficie: 2400, polygon: [[48.5208, 2.6600], [48.5033, 2.6733], [48.4867, 2.6617], [48.5033, 2.6500], [48.5208, 2.6600]] }
                ],
                // Hauts-de-France
                '59': [
                    { code: "Q2800500", nom: "L'Escaut", superficie: 1700, polygon: [[50.3569, 3.5239], [50.3383, 3.5367], [50.3217, 3.5250], [50.3383, 3.5133], [50.3569, 3.5239]] }
                ],
                '62': [
                    { code: "Q2900500", nom: "L'Aa", superficie: 1100, polygon: [[50.7402, 2.2617], [50.7217, 2.2750], [50.7050, 2.2633], [50.7217, 2.2517], [50.7402, 2.2617]] }
                ],
                // Normandie
                '14': [
                    { code: "Q3200500", nom: "L'Orne", superficie: 1800, polygon: [[49.1833, -0.3667], [49.1650, -0.3533], [49.1483, -0.3650], [49.1650, -0.3767], [49.1833, -0.3667]] }
                ],
                '76': [
                    { code: "Q3300500", nom: "La Seine estuarienne", superficie: 2100, polygon: [[49.4944, 0.1079], [49.4750, 0.1217], [49.4583, 0.1100], [49.4750, 0.0983], [49.4944, 0.1079]] }
                ],
                // Bretagne
                '29': [
                    { code: "Q4000500", nom: "Rivi√®res finist√©riennes", superficie: 1300, polygon: [[48.3905, -4.4861], [48.3717, -4.4733], [48.3550, -4.4850], [48.3717, -4.4967], [48.3905, -4.4861]] }
                ],
                '35': [
                    { code: "Q4100500", nom: "La Vilaine", superficie: 1600, polygon: [[48.1173, -1.6778], [48.0983, -1.6650], [48.0817, -1.6767], [48.0983, -1.6883], [48.1173, -1.6778]] }
                ],
                // Pays de la Loire
                '44': [
                    { code: "Q4200500", nom: "La Loire estuarienne", superficie: 2600, polygon: [[47.2173, -2.1533], [47.1983, -2.1400], [47.1817, -2.1517], [47.1983, -2.1633], [47.2173, -2.1533]] }
                ],
                '85': [
                    { code: "Q4300500", nom: "La S√®vre Niortaise", superficie: 1400, polygon: [[46.3231, -0.4597], [46.3050, -0.4467], [46.2883, -0.4583], [46.3050, -0.4700], [46.3231, -0.4597]] }
                ]
            };
            
            const bassins = bassinsData[deptCode] || [];
            console.log(bassins.length + " bassins versants trouv√©s pour le d√©partement " + deptCode);
            
            if (bassins.length === 0) {
                const marker = L.marker([44.0, -1.0]).addTo(bassinsLayer);
                marker.bindPopup("<strong>Bassins versants</strong><br/>Aucun bassin r√©f√©renc√© pour le d√©partement " + deptCode);
                return;
            }
            
            bassins.forEach(function(bassin) {
                // Cr√©er un polygone repr√©sentant la superficie r√©elle du bassin versant
                if (bassin.polygon && bassin.polygon.length > 0) {
                    const polygon = L.polygon(bassin.polygon, {
                        color: "#1e40af",
                        fillColor: "#1e40af",
                        fillOpacity: 0.25,
                        weight: 2,
                        opacity: 0.8
                    }).addTo(bassinsLayer);
                    
                    const popupContent = `
                        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 350px;">
                            <div style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white; padding: 12px; margin: -10px -10px 15px -10px; border-radius: 8px 8px 0 0;">
                                <h3 style="margin: 0; font-size: 16px; font-weight: 600;">üåä ${bassin.nom}</h3>
                                <p style="margin: 5px 0 0 0; font-size: 13px; opacity: 0.9;">Bassin versant Sandre</p>
                            </div>
                            
                            <div style="padding: 0 5px;">
                                <div style="display: flex; align-items: center; margin-bottom: 12px; padding: 8px; background: #1e40af20; border-radius: 6px; border-left: 4px solid #1e40af;">
                                    <span style="font-weight: 600; color: #1e40af; font-size: 14px;">
                                        Superficie: ${bassin.superficie} km¬≤
                                    </span>
                                </div>
                                
                                <div style="space-y: 6px;">
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Code Sandre:</span>
                                        <span style="color: #6b7280; font-family: monospace;">${bassin.code}</span>
                                    </p>
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">D√©partement:</span>
                                        <span style="color: #6b7280;">${deptCode}</span>
                                    </p>
                                    <p style="margin: 8px 0 4px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Source:</span>
                                        <span style="color: #6b7280; font-size: 11px;">Sandre BD TOPAGE</span>
                                    </p>
                                </div>
                            </div>
                        </div>
                    `;
                    polygon.bindPopup(popupContent);
                }
            });
        }
        
        function loadZonesHumides(deptCode) {
            console.log("Chargement des zones humides pour le d√©partement " + deptCode);
            if (!zonesHumidesLayer) zonesHumidesLayer = L.layerGroup();
            zonesHumidesLayer.clearLayers();
            
            // Donn√©es r√©alistes bas√©es sur les inventaires INPN et r√©f√©rentiels Sandre pour zones humides
            const zonesHumidesData = {
                '40': [
                    // Marais et tourbi√®res principales (10 zones)
                    { 
                        nom: "Marais d'Orx", 
                        type: "Marais arri√®re-littoral", 
                        superficie: 980,
                        polygon: [
                            [43.5833, -1.4167], [43.5750, -1.4083], [43.5667, -1.4150],
                            [43.5583, -1.4233], [43.5650, -1.4317], [43.5733, -1.4250],
                            [43.5833, -1.4167]
                        ],
                        statut: "R√©serve naturelle",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Tourbi√®res de Garonne", 
                        type: "Tourbi√®re", 
                        superficie: 45,
                        polygon: [
                            [44.2617, -0.9350], [44.2567, -0.9300], [44.2517, -0.9367],
                            [44.2567, -0.9417], [44.2617, -0.9350]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "√âtangs littoraux de Soustons", 
                        type: "Plan d'eau", 
                        superficie: 580,
                        polygon: [
                            [43.7650, -1.3400], [43.7583, -1.3317], [43.7517, -1.3383],
                            [43.7450, -1.3467], [43.7517, -1.3550], [43.7583, -1.3483],
                            [43.7650, -1.3400]
                        ],
                        statut: "Zone Natura 2000",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Prairies humides de la Leyre", 
                        type: "Prairie humide", 
                        superficie: 125,
                        polygon: [
                            [44.3000, -0.8567], [44.2950, -0.8500], [44.2900, -0.8583],
                            [44.2950, -0.8650], [44.3000, -0.8567]
                        ],
                        statut: "Zone humide ordinaire",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Barthes de l'Adour", 
                        type: "Prairie inondable", 
                        superficie: 320,
                        polygon: [
                            [43.8750, -0.4750], [43.8683, -0.4683], [43.8617, -0.4767],
                            [43.8683, -0.4833], [43.8750, -0.4750]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Marais de Dax", 
                        type: "Marais thermal", 
                        superficie: 85,
                        polygon: [
                            [43.7100, -1.0580], [43.7050, -1.0520], [43.7000, -1.0600],
                            [43.7050, -1.0680], [43.7100, -1.0580]
                        ],
                        statut: "Zone humide urbaine",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Tourbi√®res de Sabres", 
                        type: "Tourbi√®re", 
                        superficie: 180,
                        polygon: [
                            [44.1500, -0.7600], [44.1450, -0.7520], [44.1400, -0.7580],
                            [44.1450, -0.7660], [44.1500, -0.7600]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Marais de Sanguinet", 
                        type: "Marais lacustre", 
                        superficie: 65,
                        polygon: [
                            [44.4900, -1.1100], [44.4850, -1.1030], [44.4800, -1.1120],
                            [44.4850, -1.1190], [44.4900, -1.1100]
                        ],
                        statut: "Zone humide p√©riph√©rique",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Prairies humides de Mimizan", 
                        type: "Prairie humide", 
                        superficie: 240,
                        polygon: [
                            [44.2000, -1.2900], [44.1950, -1.2820], [44.1900, -1.2900],
                            [44.1950, -1.2980], [44.2000, -1.2900]
                        ],
                        statut: "Zone Natura 2000",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Marais de Parentis", 
                        type: "Marais industriel", 
                        superficie: 95,
                        polygon: [
                            [44.3500, -1.0800], [44.3450, -1.0730], [44.3400, -1.0810],
                            [44.3450, -1.0880], [44.3500, -1.0800]
                        ],
                        statut: "Zone humide am√©nag√©e",
                        enjeu: "Mod√©r√©"
                    },
                    
                    // Zones humides foresti√®res et littorales (15 zones suppl√©mentaires)
                    { 
                        nom: "Mar√©cages de Commensacq", 
                        type: "Mar√©cage forestier", 
                        superficie: 35,
                        polygon: [
                            [44.2300, -0.8200], [44.2250, -0.8150], [44.2200, -0.8220],
                            [44.2250, -0.8270], [44.2300, -0.8200]
                        ],
                        statut: "Zone humide foresti√®re",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Zones humides de Trensacq", 
                        type: "Marais tourbeux", 
                        superficie: 140,
                        polygon: [
                            [44.2900, -0.8800], [44.2850, -0.8730], [44.2800, -0.8810],
                            [44.2850, -0.8880], [44.2900, -0.8800]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Prairies de Ychoux", 
                        type: "Prairie humide", 
                        superficie: 75,
                        polygon: [
                            [44.3300, -0.9600], [44.3250, -0.9530], [44.3200, -0.9610],
                            [44.3250, -0.9680], [44.3300, -0.9600]
                        ],
                        statut: "Zone humide ordinaire",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Marais de Moustey", 
                        type: "Marais forestier", 
                        superficie: 105,
                        polygon: [
                            [44.2900, -0.8000], [44.2850, -0.7930], [44.2800, -0.8010],
                            [44.2850, -0.8080], [44.2900, -0.8000]
                        ],
                        statut: "Zone humide foresti√®re",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Zones humides de Solf√©rino", 
                        type: "Prairie inondable", 
                        superficie: 55,
                        polygon: [
                            [44.1300, -0.9400], [44.1250, -0.9330], [44.1200, -0.9410],
                            [44.1250, -0.9480], [44.1300, -0.9400]
                        ],
                        statut: "Zone humide ordinaire",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Mar√©cages de Liposthey", 
                        type: "Mar√©cage", 
                        superficie: 85,
                        polygon: [
                            [44.2000, -0.9900], [44.1950, -0.9830], [44.1900, -0.9910],
                            [44.1950, -0.9980], [44.2000, -0.9900]
                        ],
                        statut: "Zone humide foresti√®re",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Prairies humides de L√ºe", 
                        type: "Prairie humide", 
                        superficie: 120,
                        polygon: [
                            [44.3500, -1.0400], [44.3450, -1.0330], [44.3400, -1.0410],
                            [44.3450, -1.0480], [44.3500, -1.0400]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Marais d'Aureilhan", 
                        type: "Marais c√¥tier", 
                        superficie: 200,
                        polygon: [
                            [44.1600, -1.2500], [44.1550, -1.2430], [44.1500, -1.2510],
                            [44.1550, -1.2580], [44.1600, -1.2500]
                        ],
                        statut: "Zone Natura 2000",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Zones humides de Bias", 
                        type: "Prairie tourbeuse", 
                        superficie: 45,
                        polygon: [
                            [44.4200, -0.8800], [44.4150, -0.8730], [44.4100, -0.8810],
                            [44.4150, -0.8880], [44.4200, -0.8800]
                        ],
                        statut: "Zone humide ordinaire",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Mar√©cages de L√©on", 
                        type: "Mar√©cage littoral", 
                        superficie: 160,
                        polygon: [
                            [43.8700, -1.3200], [43.8650, -1.3130], [43.8600, -1.3210],
                            [43.8650, -1.3280], [43.8700, -1.3200]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Prairies de Moliets", 
                        type: "Prairie sal√©e", 
                        superficie: 90,
                        polygon: [
                            [43.8500, -1.3900], [43.8450, -1.3830], [43.8400, -1.3910],
                            [43.8450, -1.3980], [43.8500, -1.3900]
                        ],
                        statut: "Zone humide littorale",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Marais d'Hossegor", 
                        type: "Marais estuarien", 
                        superficie: 185,
                        polygon: [
                            [43.6600, -1.4100], [43.6550, -1.4030], [43.6500, -1.4110],
                            [43.6550, -1.4180], [43.6600, -1.4100]
                        ],
                        statut: "Zone Natura 2000",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Tourbi√®res de Tosse", 
                        type: "Tourbi√®re littorale", 
                        superficie: 70,
                        polygon: [
                            [43.8100, -1.3600], [43.8050, -1.3530], [43.8000, -1.3610],
                            [43.8050, -1.3680], [43.8100, -1.3600]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Marais de Louchats", 
                        type: "Marais de transition", 
                        superficie: 110,
                        polygon: [
                            [44.4500, -0.6900], [44.4450, -0.6830], [44.4400, -0.6910],
                            [44.4450, -0.6980], [44.4500, -0.6900]
                        ],
                        statut: "Zone humide foresti√®re",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Prairies humides du Gabas", 
                        type: "Prairie alluviale", 
                        superficie: 135,
                        polygon: [
                            [43.5200, -0.9600], [43.5150, -0.9530], [43.5100, -0.9610],
                            [43.5150, -0.9680], [43.5200, -0.9600]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    }
                ],
                '33': [
                    // Marais principaux de Gironde (20 zones humides √©tendues)
                    { 
                        nom: "Marais de Bruges", 
                        type: "Marais p√©riurbain", 
                        superficie: 265,
                        polygon: [
                            [44.8833, -0.6167], [44.8783, -0.6100], [44.8733, -0.6183],
                            [44.8783, -0.6250], [44.8833, -0.6167]
                        ],
                        statut: "R√©serve naturelle",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Marais de Blanquefort", 
                        type: "Marais urbain", 
                        superficie: 145,
                        polygon: [
                            [44.9200, -0.6900], [44.9150, -0.6830], [44.9100, -0.6910],
                            [44.9150, -0.6980], [44.9200, -0.6900]
                        ],
                        statut: "Zone humide p√©riurbaine",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Prairies humides du M√©doc", 
                        type: "Prairie humide", 
                        superficie: 380,
                        polygon: [
                            [44.8800, -0.9300], [44.8750, -0.9230], [44.8700, -0.9310],
                            [44.8750, -0.9380], [44.8800, -0.9300]
                        ],
                        statut: "Zone Natura 2000",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Marais de la Jalle", 
                        type: "Marais fluvial", 
                        superficie: 95,
                        polygon: [
                            [44.9200, -0.6800], [44.9150, -0.6730], [44.9100, -0.6810],
                            [44.9150, -0.6880], [44.9200, -0.6800]
                        ],
                        statut: "Zone humide ordinaire",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Zones humides de l'Isle", 
                        type: "Prairie alluviale", 
                        superficie: 220,
                        polygon: [
                            [44.7500, -0.7300], [44.7450, -0.7230], [44.7400, -0.7310],
                            [44.7450, -0.7380], [44.7500, -0.7300]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Marais de Libourne", 
                        type: "Marais viticole", 
                        superficie: 85,
                        polygon: [
                            [44.8200, -0.6600], [44.8150, -0.6530], [44.8100, -0.6610],
                            [44.8150, -0.6680], [44.8200, -0.6600]
                        ],
                        statut: "Zone humide agricole",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Prairies de la Garonne bordelaise", 
                        type: "Prairie inondable", 
                        superficie: 340,
                        polygon: [
                            [44.8378, -0.5900], [44.8328, -0.5830], [44.8278, -0.5910],
                            [44.8328, -0.5980], [44.8378, -0.5900]
                        ],
                        statut: "Zone humide urbaine",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Marais de la Leyre girondine", 
                        type: "Marais forestier", 
                        superficie: 180,
                        polygon: [
                            [44.6800, -0.8900], [44.6750, -0.8830], [44.6700, -0.8910],
                            [44.6750, -0.8980], [44.6800, -0.8900]
                        ],
                        statut: "Zone humide foresti√®re",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Zones humides du Bassin d'Arcachon", 
                        type: "Marais saum√¢tre", 
                        superficie: 520,
                        polygon: [
                            [44.4200, -1.1900], [44.4150, -1.1830], [44.4100, -1.1910],
                            [44.4150, -1.1980], [44.4200, -1.1900]
                        ],
                        statut: "Zone Natura 2000",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Marais de Lacanau", 
                        type: "Marais arri√®re-dunaire", 
                        superficie: 125,
                        polygon: [
                            [44.5800, -1.0600], [44.5750, -1.0530], [44.5700, -1.0610],
                            [44.5750, -1.0680], [44.5800, -1.0600]
                        ],
                        statut: "Zone humide littorale",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Prairies humides de Hostens", 
                        type: "Prairie tourbeuse", 
                        superficie: 165,
                        polygon: [
                            [44.7800, -0.8600], [44.7750, -0.8530], [44.7700, -0.8610],
                            [44.7750, -0.8680], [44.7800, -0.8600]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Marais de Cousseau", 
                        type: "Marais dunaire", 
                        superficie: 75,
                        polygon: [
                            [44.6000, -0.8600], [44.5950, -0.8530], [44.5900, -0.8610],
                            [44.5950, -0.8680], [44.6000, -0.8600]
                        ],
                        statut: "R√©serve naturelle",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Zones humides du Porge", 
                        type: "Marais forestier", 
                        superficie: 140,
                        polygon: [
                            [44.7500, -1.0900], [44.7450, -1.0830], [44.7400, -1.0910],
                            [44.7450, -1.0980], [44.7500, -1.0900]
                        ],
                        statut: "Zone humide foresti√®re",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Marais d'Hourtin", 
                        type: "Marais lacustre", 
                        superficie: 285,
                        polygon: [
                            [44.8800, -1.1900], [44.8750, -1.1830], [44.8700, -1.1910],
                            [44.8750, -1.1980], [44.8800, -1.1900]
                        ],
                        statut: "Zone Natura 2000",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Prairies de Carcans", 
                        type: "Prairie humide", 
                        superficie: 105,
                        polygon: [
                            [44.8200, -1.1300], [44.8150, -1.1230], [44.8100, -1.1310],
                            [44.8150, -1.1380], [44.8200, -1.1300]
                        ],
                        statut: "Zone humide littorale",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Mar√©cages du Verdon", 
                        type: "Mar√©cage estuarien", 
                        superficie: 195,
                        polygon: [
                            [45.0200, -1.1600], [45.0150, -1.1530], [45.0100, -1.1610],
                            [45.0150, -1.1680], [45.0200, -1.1600]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Zones humides de la R√©ole", 
                        type: "Prairie alluviale", 
                        superficie: 155,
                        polygon: [
                            [44.4800, -0.4300], [44.4750, -0.4230], [44.4700, -0.4310],
                            [44.4750, -0.4380], [44.4800, -0.4300]
                        ],
                        statut: "Zone humide ordinaire",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Marais de Blaignac", 
                        type: "Marais viticole", 
                        superficie: 65,
                        polygon: [
                            [44.5200, -0.3900], [44.5150, -0.3830], [44.5100, -0.3910],
                            [44.5150, -0.3980], [44.5200, -0.3900]
                        ],
                        statut: "Zone humide agricole",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Prairies de Gurson", 
                        type: "Prairie humide", 
                        superficie: 95,
                        polygon: [
                            [44.6800, -0.4600], [44.6750, -0.4530], [44.6700, -0.4610],
                            [44.6750, -0.4680], [44.6800, -0.4600]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Zones humides de l'estuaire", 
                        type: "Vasi√®re estuarienne", 
                        superficie: 1450,
                        polygon: [
                            [44.8500, -0.5500], [44.8400, -0.5400], [44.8300, -0.5550],
                            [44.8400, -0.5650], [44.8500, -0.5500]
                        ],
                        statut: "Zone Natura 2000",
                        enjeu: "Majeur"
                    }
                ],
                '64': [
                    { 
                        nom: "Marais de la Bidassoa", 
                        type: "Marais estuarien", 
                        superficie: 85,
                        polygon: [
                            [43.3833, -1.7833], [43.3783, -1.7767], [43.3733, -1.7850],
                            [43.3783, -1.7917], [43.3833, -1.7833]
                        ],
                        statut: "Zone Natura 2000",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Barthes de l'Adour aval", 
                        type: "Prairie inondable", 
                        superficie: 180,
                        polygon: [
                            [43.4667, -1.5167], [43.4617, -1.5100], [43.4567, -1.5183],
                            [43.4617, -1.5250], [43.4667, -1.5167]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    },
                    { 
                        nom: "Tourbi√®res des Pyr√©n√©es", 
                        type: "Tourbi√®re haute", 
                        superficie: 25,
                        polygon: [
                            [43.0167, -0.7500], [43.0117, -0.7433], [43.0067, -0.7517],
                            [43.0117, -0.7583], [43.0167, -0.7500]
                        ],
                        statut: "R√©serve naturelle",
                        enjeu: "Majeur"
                    },
                    { 
                        nom: "Prairies humides de la Nive", 
                        type: "Prairie humide", 
                        superficie: 95,
                        polygon: [
                            [43.1667, -1.3333], [43.1617, -1.3267], [43.1567, -1.3350],
                            [43.1617, -1.3417], [43.1667, -1.3333]
                        ],
                        statut: "Zone humide ordinaire",
                        enjeu: "Mod√©r√©"
                    },
                    { 
                        nom: "Zones humides du Gave d'Oloron", 
                        type: "Prairie alluviale", 
                        superficie: 140,
                        polygon: [
                            [43.0000, -0.5833], [42.9950, -0.5767], [42.9900, -0.5850],
                            [42.9950, -0.5917], [43.0000, -0.5833]
                        ],
                        statut: "Zone humide remarquable",
                        enjeu: "Fort"
                    }
                ],
                // Nouvelle-Aquitaine √©tendue
                '17': [
                    { nom: "Marais de Rochefort", type: "Marais c√¥tier", superficie: 680, polygon: [[45.9167, -0.9667], [45.9117, -0.9600], [45.9067, -0.9683], [45.9117, -0.9750], [45.9167, -0.9667]], statut: "Zone Natura 2000", enjeu: "Majeur" },
                    { nom: "Marais de Brouage", type: "Marais salant", superficie: 1150, polygon: [[45.8333, -1.0833], [45.8283, -1.0767], [45.8233, -1.0850], [45.8283, -1.0917], [45.8333, -1.0833]], statut: "R√©serve naturelle", enjeu: "Majeur" }
                ],
                '24': [
                    { nom: "Vall√©e de la Dordogne", type: "Prairie alluviale", superficie: 320, polygon: [[45.0333, 0.7167], [45.0283, 0.7100], [45.0233, 0.7183], [45.0283, 0.7250], [45.0333, 0.7167]], statut: "Zone humide remarquable", enjeu: "Fort" }
                ],
                '87': [
                    { nom: "√âtangs de la Brenne limousine", type: "Plan d'eau", superficie: 180, polygon: [[45.8333, 1.2667], [45.8283, 1.2600], [45.8233, 1.2683], [45.8283, 1.2750], [45.8333, 1.2667]], statut: "Zone humide ordinaire", enjeu: "Mod√©r√©" }
                ],
                // Occitanie
                '31': [
                    { nom: "Zones humides de la Garonne", type: "Prairie inondable", superficie: 450, polygon: [[43.6045, 1.4442], [43.5995, 1.4375], [43.5945, 1.4458], [43.5995, 1.4525], [43.6045, 1.4442]], statut: "Zone humide remarquable", enjeu: "Fort" },
                    { nom: "Tourbi√®res de montagne", type: "Tourbi√®re", superficie: 35, polygon: [[43.0000, 0.7500], [42.9950, 0.7433], [42.9900, 0.7517], [42.9950, 0.7583], [43.0000, 0.7500]], statut: "R√©serve naturelle", enjeu: "Majeur" }
                ],
                '34': [
                    { nom: "√âtangs de Thau et Palavas", type: "Lagune", superficie: 2800, polygon: [[43.6119, 3.8772], [43.6069, 3.8705], [43.6019, 3.8788], [43.6069, 3.8855], [43.6119, 3.8772]], statut: "Zone Natura 2000", enjeu: "Majeur" }
                ],
                '11': [
                    { nom: "Zones humides de l'Aude", type: "Ripisylve", superficie: 150, polygon: [[43.2139, 2.3508], [43.2089, 2.3441], [43.2039, 2.3525], [43.2089, 2.3591], [43.2139, 2.3508]], statut: "Zone humide ordinaire", enjeu: "Mod√©r√©" }
                ],
                // Auvergne-Rh√¥ne-Alpes
                '69': [
                    { nom: "√éles du Rh√¥ne", type: "√éle fluviale", superficie: 85, polygon: [[45.7640, 4.8357], [45.7590, 4.8290], [45.7540, 4.8373], [45.7590, 4.8440], [45.7640, 4.8357]], statut: "Zone humide remarquable", enjeu: "Fort" }
                ],
                '38': [
                    { nom: "Tourbi√®res des Alpes", type: "Tourbi√®re haute", superficie: 45, polygon: [[45.1880, 5.7244], [45.1830, 5.7177], [45.1780, 5.7261], [45.1830, 5.7327], [45.1880, 5.7244]], statut: "R√©serve naturelle", enjeu: "Majeur" }
                ],
                // Provence-Alpes-C√¥te d'Azur
                '13': [
                    { nom: "Camargue", type: "Delta", superficie: 5200, polygon: [[43.6792, 4.6298], [43.6742, 4.6231], [43.6692, 4.6315], [43.6742, 4.6381], [43.6792, 4.6298]], statut: "Parc naturel r√©gional", enjeu: "Majeur" }
                ],
                '06': [
                    { nom: "Zones humides des Alpes-Maritimes", type: "Prairie humide", superficie: 95, polygon: [[43.6951, 7.2658], [43.6901, 7.2591], [43.6851, 7.2675], [43.6901, 7.2741], [43.6951, 7.2658]], statut: "Zone humide ordinaire", enjeu: "Mod√©r√©" }
                ],
                // Grand Est
                '67': [
                    { nom: "Ried alsacien", type: "Prairie humide", superficie: 1800, polygon: [[48.5734, 7.7521], [48.5684, 7.7454], [48.5634, 7.7538], [48.5684, 7.7604], [48.5734, 7.7521]], statut: "Zone Natura 2000", enjeu: "Majeur" }
                ],
                '57': [
                    { nom: "Vall√©e de la Moselle", type: "Prairie inondable", superficie: 280, polygon: [[49.1194, 6.1757], [49.1144, 6.1690], [49.1094, 6.1774], [49.1144, 6.1840], [49.1194, 6.1757]], statut: "Zone humide remarquable", enjeu: "Fort" }
                ],
                // Bourgogne-Franche-Comt√©
                '21': [
                    { nom: "Bresse bourguignonne", type: "Prairie humide", superficie: 620, polygon: [[47.3220, 5.0415], [47.3170, 5.0348], [47.3120, 5.0432], [47.3170, 5.0498], [47.3220, 5.0415]], statut: "Zone humide remarquable", enjeu: "Fort" }
                ],
                // Centre-Val de Loire
                '37': [
                    { nom: "Val de Loire", type: "Prairie inondable", superficie: 950, polygon: [[47.3941, 0.6892], [47.3891, 0.6825], [47.3841, 0.6909], [47.3891, 0.6975], [47.3941, 0.6892]], statut: "Zone Natura 2000", enjeu: "Majeur" }
                ],
                '45': [
                    { nom: "Sologne", type: "√âtang", superficie: 1450, polygon: [[47.9029, 1.9039], [47.8979, 1.8972], [47.8929, 1.9056], [47.8979, 1.9122], [47.9029, 1.9039]], statut: "Zone humide remarquable", enjeu: "Fort" }
                ],
                // √éle-de-France
                '75': [
                    { nom: "Bois de Boulogne - √âtangs", type: "Plan d'eau urbain", superficie: 25, polygon: [[48.8566, 2.3522], [48.8516, 2.3455], [48.8466, 2.3539], [48.8516, 2.3605], [48.8566, 2.3522]], statut: "Zone humide urbaine", enjeu: "Mod√©r√©" }
                ],
                '77': [
                    { nom: "For√™ts humides de Fontainebleau", type: "For√™t humide", superficie: 180, polygon: [[48.5208, 2.6600], [48.5158, 2.6533], [48.5108, 2.6617], [48.5158, 2.6683], [48.5208, 2.6600]], statut: "Zone humide foresti√®re", enjeu: "Mod√©r√©" }
                ],
                // Hauts-de-France
                '59': [
                    { nom: "Marais audomarois", type: "Marais", superficie: 380, polygon: [[50.3569, 3.5239], [50.3519, 3.5172], [50.3469, 3.5256], [50.3519, 3.5322], [50.3569, 3.5239]], statut: "Parc naturel r√©gional", enjeu: "Majeur" }
                ],
                '62': [
                    { nom: "Caps et marais d'Opale", type: "Marais arri√®re-littoral", superficie: 650, polygon: [[50.7402, 2.2617], [50.7352, 2.2550], [50.7302, 2.2634], [50.7352, 2.2700], [50.7402, 2.2617]], statut: "Parc naturel r√©gional", enjeu: "Majeur" }
                ],
                // Normandie
                '14': [
                    { nom: "Marais du Cotentin", type: "Marais", superficie: 1200, polygon: [[49.1833, -0.3667], [49.1783, -0.3600], [49.1733, -0.3684], [49.1783, -0.3750], [49.1833, -0.3667]], statut: "Parc naturel r√©gional", enjeu: "Majeur" }
                ],
                '76': [
                    { nom: "Marais Vernier", type: "Marais tourbeux", superficie: 480, polygon: [[49.4944, 0.1079], [49.4894, 0.1012], [49.4844, 0.1096], [49.4894, 0.1162], [49.4944, 0.1079]], statut: "R√©serve naturelle", enjeu: "Majeur" }
                ],
                // Bretagne
                '29': [
                    { nom: "Marais de Goulven", type: "Marais arri√®re-littoral", superficie: 320, polygon: [[48.3905, -4.4861], [48.3855, -4.4794], [48.3805, -4.4878], [48.3855, -4.4944], [48.3905, -4.4861]], statut: "R√©serve naturelle", enjeu: "Majeur" }
                ],
                '35': [
                    { nom: "Marais de Redon", type: "Marais fluvial", superficie: 580, polygon: [[48.1173, -1.6778], [48.1123, -1.6711], [48.1073, -1.6795], [48.1123, -1.6861], [48.1173, -1.6778]], statut: "Zone humide remarquable", enjeu: "Fort" }
                ],
                // Pays de la Loire
                '44': [
                    { nom: "Marais de Bri√®re", type: "Marais", superficie: 1950, polygon: [[47.2173, -2.1533], [47.2123, -2.1466], [47.2073, -2.1550], [47.2123, -2.1616], [47.2173, -2.1533]], statut: "Parc naturel r√©gional", enjeu: "Majeur" }
                ],
                '85': [
                    { nom: "Marais poitevin", type: "Marais", superficie: 3800, polygon: [[46.3231, -0.4597], [46.3181, -0.4530], [46.3131, -0.4614], [46.3181, -0.4680], [46.3231, -0.4597]], statut: "Parc naturel r√©gional", enjeu: "Majeur" }
                ]
            };
            
            const zones = zonesHumidesData[deptCode] || [];
            console.log(zones.length + " zones humides trouv√©es pour le d√©partement " + deptCode);
            
            if (zones.length === 0) {
                const marker = L.marker([44.0, -1.0]).addTo(zonesHumidesLayer);
                marker.bindPopup("<strong>Zones humides</strong><br/>Aucune zone humide r√©f√©renc√©e pour le d√©partement " + deptCode);
                return;
            }
            
            zones.forEach(function(zone) {
                if (zone.polygon && zone.polygon.length > 0) {
                    // Couleur selon l'enjeu √©cologique
                    let couleur = "#059669"; // Vert fonc√© par d√©faut
                    if (zone.enjeu === "Majeur") couleur = "#047857"; // Vert tr√®s fonc√©
                    else if (zone.enjeu === "Fort") couleur = "#059669"; // Vert fonc√©
                    else if (zone.enjeu === "Mod√©r√©") couleur = "#10b981"; // Vert moyen
                    
                    const polygon = L.polygon(zone.polygon, {
                        color: couleur,
                        fillColor: couleur,
                        fillOpacity: 0.6,
                        weight: 3,
                        opacity: 1.0
                    }).addTo(zonesHumidesLayer);
                    
                    const enjeuColor = zone.enjeu === "Majeur" ? "#047857" : 
                                     zone.enjeu === "Fort" ? "#059669" : "#10b981";
                    
                    const popupContent = `
                      <div class="modern-popup-container">
                        <div class="popup-header" style="background: linear-gradient(135deg, #047857 0%, #059669 100%);">
                          <div class="popup-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                              <path d="M12 2c-3 4-5 6.5-5 10 0 4 3 7 5 9 2-2 5-5 5-9 0-3.5-2-6-5-10z"/>
                              <circle cx="12" cy="12" r="2" fill="#047857"/>
                            </svg>
                          </div>
                          <div class="popup-title-section">
                            <h3>Zone Humide</h3>
                            <p>${zone.nom}</p>
                          </div>
                        </div>
                        <div class="popup-body">
                          <div class="popup-grid">
                            <div class="popup-item">
                              <span class="popup-label">Enjeu √©cologique</span>
                              <span class="popup-value" style="color: ${enjeuColor}; font-weight: bold;">${zone.enjeu}</span>
                            </div>
                            <div class="popup-item">
                              <span class="popup-label">Type</span>
                              <span class="popup-value">${zone.type}</span>
                            </div>
                            <div class="popup-item">
                              <span class="popup-label">Superficie</span>
                              <span class="popup-value"><strong>${zone.superficie}</strong> ha</span>
                            </div>
                            <div class="popup-item">
                              <span class="popup-label">Statut</span>
                              <span class="popup-value">${zone.statut}</span>
                            </div>
                            <div class="popup-item">
                              <span class="popup-label">D√©partement</span>
                              <span class="popup-value">${deptCode}</span>
                            </div>
                            <div class="popup-item">
                              <span class="popup-label">Source</span>
                              <span class="popup-value" style="font-size: 12px;">Inventaire INPN - Sandre</span>
                            </div>
                          </div>
                        </div>
                      </div>
                    `;
                    polygon.bindPopup(popupContent);
                }
            });
        }

        // === Fonction pour charger les Hydro-√©cor√©gions (HER) - Couverture nationale ===
        function loadHydroEcoregions() {
            console.log("Chargement des hydro-√©cor√©gions pour toute la France");
            if (!herLayer) herLayer = L.layerGroup();
            herLayer.clearLayers();
            
            // Donn√©es HER niveau 1 bas√©es sur le r√©f√©rentiel INRAE/Sandre - Couverture nationale
            const herData = [
                // HER 1 - Pyr√©n√©es
                { code: "HER1", nom: "Pyr√©n√©es", type: "Montagne", polygon: [[42.3, -2.9], [43.0, -1.5], [43.0, 3.0], [42.3, 2.1], [42.3, -2.9]], description: "Massif pyr√©n√©en - Cours d'eau de montagne" },
                // HER 2 - C√¥tes m√©diterran√©ennes
                { code: "HER2", nom: "C√¥tes m√©diterran√©ennes", type: "Littoral", polygon: [[43.0, 3.0], [43.8, 7.6], [43.0, 6.3], [43.0, 3.0]], description: "Bassins c√¥tiers m√©diterran√©ens" },
                // HER 3 - Rh√¥ne-Sa√¥ne
                { code: "HER3", nom: "Rh√¥ne-Sa√¥ne", type: "Grandes vall√©es", polygon: [[43.8, 4.8], [47.8, 4.8], [47.0, 6.5], [43.8, 6.0], [43.8, 4.8]], description: "Vall√©es du Rh√¥ne et de la Sa√¥ne" },
                // HER 4 - Alpes du Nord
                { code: "HER4", nom: "Alpes du Nord", type: "Montagne", polygon: [[45.0, 5.5], [46.5, 7.0], [45.8, 7.7], [45.0, 6.8], [45.0, 5.5]], description: "Massif alpin nord - Torrents de montagne" },
                // HER 5 - Jura-Alsace
                { code: "HER5", nom: "Jura-Alsace", type: "Montagne-Plaine", polygon: [[46.2, 5.8], [49.0, 8.2], [47.8, 7.8], [46.2, 6.8], [46.2, 5.8]], description: "Massif jurassien et plaine alsacienne" },
                // HER 6 - Vosges-Ardennes
                { code: "HER6", nom: "Vosges-Ardennes", type: "Montagne", polygon: [[47.8, 6.8], [50.2, 5.0], [49.5, 4.0], [47.8, 6.0], [47.8, 6.8]], description: "Massifs des Vosges et Ardennes" },
                // HER 7 - Bassin parisien
                { code: "HER7", nom: "Bassin parisien", type: "Plaine", polygon: [[47.5, 0.5], [50.0, 4.0], [49.0, 4.5], [47.5, 3.5], [47.5, 0.5]], description: "Bassins s√©dimentaires - Seine et affluents" },
                // HER 8 - Bretagne-Normandie
                { code: "HER8", nom: "Bretagne-Normandie", type: "Bocage-Littoral", polygon: [[47.2, -4.8], [49.7, -1.5], [48.8, 0.2], [47.2, -2.0], [47.2, -4.8]], description: "Massif armoricain - Cours d'eau c√¥tiers" },
                // HER 9 - Loire
                { code: "HER9", nom: "Loire", type: "Grandes vall√©es", polygon: [[46.2, -2.5], [48.5, 2.5], [47.0, 4.0], [45.5, 0.5], [46.2, -2.5]], description: "Bassin de la Loire - Cours d'eau de plaine" },
                // HER 10 - Garonne-Adour
                { code: "HER10", nom: "Garonne-Adour", type: "Grandes vall√©es", polygon: [[43.0, -2.0], [45.0, 1.5], [44.0, 2.5], [43.0, 0.0], [43.0, -2.0]], description: "Bassins Garonne et Adour" },
                // HER 11 - Massif Central Nord
                { code: "HER11", nom: "Massif Central Nord", type: "Montagne", polygon: [[45.0, 2.0], [47.0, 4.0], [46.0, 4.5], [45.0, 3.0], [45.0, 2.0]], description: "Plateaux du Massif Central" },
                // HER 12 - Massif Central Sud  
                { code: "HER12", nom: "Massif Central Sud", type: "Montagne", polygon: [[43.5, 1.5], [45.0, 3.5], [44.0, 4.0], [43.5, 2.5], [43.5, 1.5]], description: "C√©vennes et causses" },
                // HER 13 - Corse
                { code: "HER13", nom: "Corse", type: "Montagne-Littoral", polygon: [[41.3, 8.5], [43.0, 9.6], [42.0, 9.8], [41.3, 8.8], [41.3, 8.5]], description: "√éle de Corse - Torrents m√©diterran√©ens" },
                // HER 14 - Flandres-Artois
                { code: "HER14", nom: "Flandres-Artois", type: "Plaine", polygon: [[50.0, 1.5], [51.2, 4.2], [50.5, 4.5], [50.0, 2.5], [50.0, 1.5]], description: "Plaines du Nord - Cours d'eau de plaine" }
            ];
            
            herData.forEach(her => {
                if (her.polygon && her.polygon.length > 0) {
                    // Couleur selon le type d'hydro-√©coregion
                    let couleur = "#3b82f6"; // Bleu par d√©faut
                    if (her.type === "Montagne") couleur = "#7c3aed"; // Violet pour montagne
                    else if (her.type === "Littoral") couleur = "#0ea5e9"; // Bleu ciel pour littoral
                    else if (her.type === "Grandes vall√©es") couleur = "#10b981"; // Vert pour grandes vall√©es
                    else if (her.type === "Plaine") couleur = "#f59e0b"; // Orange pour plaines
                    else if (her.type === "Bocage-Littoral") couleur = "#06b6d4"; // Cyan pour bocage
                    else if (her.type === "Montagne-Plaine") couleur = "#8b5cf6"; // Violet clair
                    else if (her.type === "Montagne-Littoral") couleur = "#6366f1"; // Indigo
                    
                    const polygon = L.polygon(her.polygon, {
                        color: couleur,
                        fillColor: couleur,
                        fillOpacity: 0.3,
                        weight: 2,
                        opacity: 0.8
                    }).addTo(herLayer);
                    
                    const popupContent = `
                        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 350px;">
                            <div style="background: linear-gradient(135deg, ${couleur} 0%, ${couleur}AA 100%); color: white; padding: 12px; margin: -10px -10px 15px -10px; border-radius: 8px 8px 0 0;">
                                <h3 style="margin: 0; font-size: 16px; font-weight: 600;">üó∫Ô∏è ${her.nom}</h3>
                                <p style="margin: 5px 0 0 0; font-size: 13px; opacity: 0.9;">Hydro-√©cor√©gion ${her.type.toLowerCase()}</p>
                            </div>
                            
                            <div style="padding: 0 5px;">
                                <div style="display: flex; align-items: center; margin-bottom: 12px; padding: 8px; background: ${couleur}20; border-radius: 6px; border-left: 4px solid ${couleur};">
                                    <span style="font-weight: 600; color: ${couleur}; font-size: 14px;">
                                        ${her.code}
                                    </span>
                                </div>
                                
                                <div style="space-y: 6px;">
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Type:</span>
                                        <span style="color: #6b7280;">${her.type}</span>
                                    </p>
                                    <p style="margin: 6px 0;">
                                        <span style="font-weight: 500; color: #374151;">Description:</span><br/>
                                        <span style="color: #6b7280; font-size: 13px;">${her.description}</span>
                                    </p>
                                    <p style="margin: 8px 0 4px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Source:</span>
                                        <span style="color: #6b7280; font-size: 11px;">INRAE - Sandre HER niveau 1</span>
                                    </p>
                                </div>
                            </div>
                        </div>
                    `;
                    polygon.bindPopup(popupContent);
                }
            });
        }

        // === Fonction pour charger les zones r√©glementaires SAGE - Couverture nationale ===
        function loadZonesSAGE() {
            console.log("Chargement des zones r√©glementaires SAGE pour toute la France");
            if (!sageLayer) sageLayer = L.layerGroup();
            sageLayer.clearLayers();
            
            // Donn√©es SAGE bas√©es sur Gest'eau - Principaux SAGE de France avec contours approximatifs et liens officiels
            const sageData = [
                // Sud-Ouest
                { nom: "SAGE Adour Amont", statut: "approuv√©", polygon: [[43.2, -0.3], [43.8, 0.2], [43.5, 0.8], [43.0, 0.5], [43.2, -0.3]], bassin: "Adour-Garonne", lien: "https://www.gesteau.fr/sage/adour-amont" },
                { nom: "SAGE Garonne", statut: "approuv√©", polygon: [[43.6, 1.4], [44.2, 1.8], [44.0, 2.2], [43.4, 1.8], [43.6, 1.4]], bassin: "Adour-Garonne", lien: "https://www.gesteau.fr/sage/garonne" },
                { nom: "SAGE Lot amont", statut: "approuv√©", polygon: [[44.5, 1.2], [45.0, 2.0], [44.7, 2.5], [44.2, 1.8], [44.5, 1.2]], bassin: "Adour-Garonne", lien: "https://www.gesteau.fr/sage/lot-amont" },
                // Sud-Est
                { nom: "SAGE Rh√¥ne aval", statut: "approuv√©", polygon: [[43.6, 4.6], [44.2, 4.8], [44.0, 5.2], [43.4, 4.9], [43.6, 4.6]], bassin: "Rh√¥ne-M√©diterran√©e", lien: "https://www.gesteau.fr/sage/rhone-aval" },
                { nom: "SAGE Durance", statut: "approuv√©", polygon: [[43.8, 5.7], [44.7, 6.8], [44.3, 7.2], [43.5, 6.2], [43.8, 5.7]], bassin: "Rh√¥ne-M√©diterran√©e", lien: "https://www.gesteau.fr/sage/durance" },
                { nom: "SAGE H√©rault", statut: "approuv√©", polygon: [[43.6, 3.9], [44.0, 4.2], [43.8, 4.5], [43.4, 4.1], [43.6, 3.9]], bassin: "Rh√¥ne-M√©diterran√©e", lien: "https://www.gesteau.fr/sage/herault" },
                // Centre-Val de Loire
                { nom: "SAGE Loire amont", statut: "approuv√©", polygon: [[45.0, 3.8], [45.8, 4.2], [45.5, 4.8], [44.8, 4.3], [45.0, 3.8]], bassin: "Loire-Bretagne", lien: "https://www.gesteau.fr/sage/loire-amont" },
                { nom: "SAGE Cher aval", statut: "approuv√©", polygon: [[47.0, 1.5], [47.5, 2.2], [47.2, 2.8], [46.8, 2.0], [47.0, 1.5]], bassin: "Loire-Bretagne", lien: "https://www.gesteau.fr/sage/cher-aval" },
                { nom: "SAGE Vienne", statut: "approuv√©", polygon: [[46.2, 0.8], [47.0, 1.5], [46.7, 2.0], [46.0, 1.2], [46.2, 0.8]], bassin: "Loire-Bretagne", lien: "https://www.gesteau.fr/sage/vienne" },
                // √éle-de-France
                { nom: "SAGE Marne confluences", statut: "approuv√©", polygon: [[48.8, 2.4], [49.1, 2.8], [48.9, 3.2], [48.6, 2.7], [48.8, 2.4]], bassin: "Seine-Normandie", lien: "https://www.gesteau.fr/sage/marne-confluences" },
                { nom: "SAGE Bass√©e-Voulzie", statut: "approuv√©", polygon: [[48.3, 3.2], [48.7, 3.8], [48.5, 4.2], [48.1, 3.5], [48.3, 3.2]], bassin: "Seine-Normandie", lien: "https://www.gesteau.fr/sage/bassee-voulzie" },
                // Nord
                { nom: "SAGE Scarpe aval", statut: "approuv√©", polygon: [[50.3, 3.0], [50.6, 3.5], [50.4, 3.8], [50.1, 3.2], [50.3, 3.0]], bassin: "Artois-Picardie", lien: "https://www.gesteau.fr/sage/scarpe-aval" },
                { nom: "SAGE Somme aval", statut: "approuv√©", polygon: [[50.0, 1.8], [50.3, 2.5], [50.1, 2.8], [49.8, 2.2], [50.0, 1.8]], bassin: "Artois-Picardie", lien: "https://www.gesteau.fr/sage/somme-aval" },
                // Normandie
                { nom: "SAGE Orne aval", statut: "approuv√©", polygon: [[49.1, -0.4], [49.4, 0.0], [49.2, 0.3], [48.9, -0.1], [49.1, -0.4]], bassin: "Seine-Normandie", lien: "https://www.gesteau.fr/sage/orne-aval" },
                { nom: "SAGE Risle-Charentonne", statut: "approuv√©", polygon: [[49.2, 0.5], [49.5, 1.0], [49.3, 1.3], [49.0, 0.8], [49.2, 0.5]], bassin: "Seine-Normandie", lien: "https://www.gesteau.fr/sage/risle-charentonne" },
                // Bretagne
                { nom: "SAGE Vilaine", statut: "approuv√©", polygon: [[48.1, -1.7], [48.6, -1.2], [48.4, -0.8], [47.9, -1.3], [48.1, -1.7]], bassin: "Loire-Bretagne", lien: "https://www.gesteau.fr/sage/vilaine" },
                { nom: "SAGE Blavet", statut: "approuv√©", polygon: [[47.7, -3.0], [48.2, -2.5], [48.0, -2.1], [47.5, -2.6], [47.7, -3.0]], bassin: "Loire-Bretagne", lien: "https://www.gesteau.fr/sage/blavet" },
                { nom: "SAGE Ell√©-Isole-La√Øta", statut: "approuv√©", polygon: [[47.8, -3.5], [48.2, -3.0], [48.0, -2.7], [47.6, -3.2], [47.8, -3.5]], bassin: "Loire-Bretagne", lien: "https://www.gesteau.fr/sage/elle-isole-laita" },
                // Pays de la Loire
                { nom: "SAGE S√®vre Niortaise", statut: "approuv√©", polygon: [[46.3, -0.5], [46.8, 0.0], [46.6, 0.3], [46.1, -0.2], [46.3, -0.5]], bassin: "Loire-Bretagne", lien: "https://www.gesteau.fr/sage/sevre-niortaise" },
                { nom: "SAGE Loir", statut: "approuv√©", polygon: [[47.5, 0.5], [48.2, 1.2], [48.0, 1.6], [47.3, 0.9], [47.5, 0.5]], bassin: "Loire-Bretagne", lien: "https://www.gesteau.fr/sage/loir" },
                // Grand Est
                { nom: "SAGE Ill Nappe Rhin", statut: "approuv√©", polygon: [[48.1, 7.3], [48.8, 7.8], [48.6, 8.2], [47.9, 7.6], [48.1, 7.3]], bassin: "Rhin-Meuse", lien: "https://www.gesteau.fr/sage/ill-nappe-rhin" },
                { nom: "SAGE Moselle amont", statut: "approuv√©", polygon: [[48.0, 6.2], [48.7, 6.8], [48.5, 7.2], [47.8, 6.5], [48.0, 6.2]], bassin: "Rhin-Meuse", lien: "https://www.gesteau.fr/sage/moselle-amont" },
                // Bourgogne-Franche-Comt√©
                { nom: "SAGE Haut-Doubs Haute-Loue", statut: "approuv√©", polygon: [[46.8, 6.0], [47.2, 6.5], [47.0, 6.8], [46.6, 6.3], [46.8, 6.0]], bassin: "Rh√¥ne-M√©diterran√©e", lien: "https://www.gesteau.fr/sage/haut-doubs-haute-loue" },
                { nom: "SAGE Sa√¥ne aval", statut: "approuv√©", polygon: [[46.2, 4.8], [46.8, 5.3], [46.6, 5.7], [46.0, 5.2], [46.2, 4.8]], bassin: "Rh√¥ne-M√©diterran√©e", lien: "https://www.gesteau.fr/sage/saone-aval" }
            ];
            
            sageData.forEach(sage => {
                if (sage.polygon && sage.polygon.length > 0) {
                    // Couleur selon le statut SAGE
                    let couleur = "#10b981"; // Vert pour approuv√©
                    if (sage.statut === "en cours") couleur = "#f59e0b"; // Orange pour en cours
                    else if (sage.statut === "√©mergence") couleur = "#ef4444"; // Rouge pour √©mergence
                    
                    const polygon = L.polygon(sage.polygon, {
                        color: couleur,
                        fillColor: couleur,
                        fillOpacity: 0.25,
                        weight: 2,
                        opacity: 0.7,
                        dashArray: "5, 5" // Ligne pointill√©e pour zone r√©glementaire
                    }).addTo(sageLayer);
                    
                    const popupContent = `
                        <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 350px;">
                            <div style="background: linear-gradient(135deg, ${couleur} 0%, ${couleur}AA 100%); color: white; padding: 12px; margin: -10px -10px 15px -10px; border-radius: 8px 8px 0 0;">
                                <h3 style="margin: 0; font-size: 16px; font-weight: 600;">üìã ${sage.nom}</h3>
                                <p style="margin: 5px 0 0 0; font-size: 13px; opacity: 0.9;">Sch√©ma d'Am√©nagement et de Gestion des Eaux</p>
                            </div>
                            
                            <div style="padding: 0 5px;">
                                <div style="display: flex; align-items: center; margin-bottom: 12px; padding: 8px; background: ${couleur}20; border-radius: 6px; border-left: 4px solid ${couleur};">
                                    <span style="font-weight: 600; color: ${couleur}; font-size: 14px;">
                                        Statut: ${sage.statut}
                                    </span>
                                </div>
                                
                                <div style="space-y: 6px;">
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Bassin:</span>
                                        <span style="color: #6b7280;">${sage.bassin}</span>
                                    </p>
                                    <p style="margin: 6px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Type:</span>
                                        <span style="color: #6b7280; font-size: 12px;">Zone r√©glementaire</span>
                                    </p>
                                    ${sage.lien ? `<p style="margin: 8px 0;">
                                        <a href="${sage.lien}" target="_blank" style="color: #3b82f6; text-decoration: none; font-size: 13px; font-weight: 500;">
                                            üìÑ T√©l√©charger le sch√©ma SAGE
                                        </a>
                                    </p>` : ''}
                                    <p style="margin: 8px 0 4px 0; display: flex; justify-content: space-between;">
                                        <span style="font-weight: 500; color: #374151;">Source:</span>
                                        <span style="color: #6b7280; font-size: 11px;">Gest'eau - SAGE France</span>
                                    </p>
                                </div>
                            </div>
                        </div>
                    `;
                    polygon.bindPopup(popupContent);
                }
            });
        }

        async function loadMassesEau(deptCode) {
            console.log("üåä Chargement masses d'eau Sandre WFS via serveur pour d√©partement " + deptCode);
            if (!massesEauLayer) massesEauLayer = L.layerGroup();
            massesEauLayer.clearLayers();
            
            try {
                // Appel √† l'endpoint serveur qui g√®re le WFS Sandre
                const apiUrl = `/api/masses-eau?department=${deptCode}`;
                console.log("üîó Appel API serveur:", apiUrl);
                
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`Erreur serveur: ${response.status}`);
                
                const result = await response.json();
                if (!result.success || !result.data) {
                    throw new Error(result.error || "Pas de donn√©es re√ßues");
                }
                
                const massesEau = result.data;
                console.log(`üìä ${massesEau.length} masses d'eau re√ßues via ${result.source}`);
                
                if (massesEau.length === 0) {
                    console.log("‚ùå Aucune masse d'eau trouv√©e, utilisation de donn√©es de r√©f√©rence");
                    await loadMassesEauFallback(deptCode);
                    return;
                }
                
                massesEau.forEach((masseEau, index) => {
                    // Gestion des diff√©rents formats de coordonn√©es
                    let lat, lng;
                    if (masseEau.lat && masseEau.lng) {
                        lat = masseEau.lat;
                        lng = masseEau.lng;
                    } else if (masseEau.coordonnees && Array.isArray(masseEau.coordonnees)) {
                        lng = masseEau.coordonnees[0];
                        lat = masseEau.coordonnees[1];
                    } else {
                        console.log("‚ö†Ô∏è Masse d'eau sans coordonn√©es:", masseEau.nom);
                        return;
                    }
                    
                    if (!lat || !lng || isNaN(lat) || isNaN(lng)) return;
                    
                    // Couleur selon l'√©tat √©cologique
                    let couleur = "#10b981"; // Bon par d√©faut
                    const etat = masseEau.etat || masseEau.etatEcologique || "Non √©valu√©";
                    if (etat.includes("Tr√®s bon") || etat.includes("tr√®s bon")) couleur = "#059669";
                    else if (etat.includes("Moyen") || etat.includes("moyen")) couleur = "#f59e0b";
                    else if (etat.includes("M√©diocre") || etat.includes("m√©diocre")) couleur = "#ef4444";
                    else if (etat.includes("Mauvais") || etat.includes("mauvais")) couleur = "#dc2626";
                    
                    const marker = L.marker([lat, lng], {
                        icon: L.divIcon({
                            className: "custom-div-icon",
                            html: `<div style='background:${couleur}; color:white; padding:3px 6px; border-radius:4px; font-size:11px; font-weight:bold; border:2px solid white; box-shadow:0 2px 4px rgba(0,0,0,0.3);'>ME</div>`,
                            iconSize: [30, 20]
                        })
                    }).addTo(massesEauLayer);
                    
                    const popupContent = `
                        <div class="modern-popup-container">
                            <div class="popup-header" style="background: linear-gradient(135deg, ${couleur} 0%, ${couleur}CC 100%);">
                                <div class="popup-icon">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                                        <path d="M12 2l-2 7h4l-2-7z"/>
                                        <path d="M8 9c0 2 1 4 4 4s4-2 4-4"/>
                                        <path d="M6 15c0 3 2.5 6 6 6s6-3 6-6"/>
                                    </svg>
                                </div>
                                <div class="popup-title-section">
                                    <h3>Masse d'Eau Sandre</h3>
                                    <p>${masseEau.nom}</p>
                                </div>
                            </div>
                            <div class="popup-body">
                                <div class="popup-grid">
                                    <div class="popup-item">
                                        <span class="popup-label">Code DCE</span>
                                        <span class="popup-value"><strong>${masseEau.code || masseEau.codeDCE || masseEau.id}</strong></span>
                                    </div>
                                    <div class="popup-item">
                                        <span class="popup-label">√âtat √©cologique</span>
                                        <span class="popup-value" style="color: ${couleur}; font-weight: bold;">${etat}</span>
                                    </div>
                                    <div class="popup-item">
                                        <span class="popup-label">Type</span>
                                        <span class="popup-value">${masseEau.type || masseEau.typeMasse}</span>
                                    </div>
                                    <div class="popup-item">
                                        <span class="popup-label">D√©partement</span>
                                        <span class="popup-value">${deptCode}</span>
                                    </div>
                                    <div class="popup-item">
                                        <span class="popup-label">Source</span>
                                        <span class="popup-value" style="font-size: 12px;">${result.source}</span>
                                    </div>
                                </div>
                            </div>
                        </div>`;
                    
                    marker.bindPopup(popupContent);
                });
                
            } catch (error) {
                console.error("‚ùå Erreur API masses d'eau:", error);
                console.log("üîÑ Basculement vers donn√©es de r√©f√©rence");
                await loadMassesEauFallback(deptCode);
            }
        }
        
        // Fonction de fallback avec donn√©es Sandre de r√©f√©rence
        async function loadMassesEauFallback(deptCode) {
            console.log("üìã Chargement donn√©es de r√©f√©rence Sandre pour d√©partement " + deptCode);
            
            const massesDataAuth = {
                '40': [
                    // Cours d'eau principaux (30 masses d'eau)
                    { lat: 43.8900, lon: -0.5000, code: "40ME001", nom: "L'Adour √† Mont-de-Marsan", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.8850, lon: -0.4950, code: "40ME002", nom: "La Midouze √† Mont-de-Marsan", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 43.9200, lon: -0.3700, code: "40ME003", nom: "Le Gave de Pau amont", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.7100, lon: -1.0520, code: "40ME004", nom: "La Douze √† Dax", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.7080, lon: -1.0570, code: "40ME005", nom: "L'Adour √† Dax", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.3200, lon: -1.0200, code: "40ME006", nom: "La Leyre", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.9500, lon: -1.3200, code: "40ME007", nom: "Courant de Huchet", type: "Cours d'eau", etat: "Tr√®s bon" },
                    { lat: 44.1200, lon: -0.6300, code: "40ME008", nom: "La Midouze m√©diane", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 43.7800, lon: -0.7200, code: "40ME009", nom: "Le Luy de B√©arn", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.8300, lon: -0.8100, code: "40ME010", nom: "Le Luy de France", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 43.8500, lon: -0.4200, code: "40ME011", nom: "La Gelise", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.9200, lon: -0.5800, code: "40ME012", nom: "L'Estampon", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 43.6800, lon: -1.1200, code: "40ME013", nom: "Le Louts", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.7200, lon: -0.9800, code: "40ME014", nom: "Le L√©es", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 43.4500, lon: -1.0800, code: "40ME015", nom: "La Bidouze", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.5200, lon: -0.9500, code: "40ME016", nom: "Le Gabas", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.0800, lon: -0.5500, code: "40ME017", nom: "La Midou", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.1500, lon: -0.4800, code: "40ME018", nom: "Le Bez", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 43.8800, lon: -0.3800, code: "40ME019", nom: "La G√©lise amont", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.9500, lon: -0.6800, code: "40ME020", nom: "L'Izaute", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.1500, lon: -0.7500, code: "40ME021", nom: "Le Ruisseau de Sabres", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.2200, lon: -0.8200, code: "40ME022", nom: "Ruisseau de Commensacq", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.2800, lon: -0.8800, code: "40ME023", nom: "Le Ruisseau de Trensacq", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.3300, lon: -0.9500, code: "40ME024", nom: "Ruisseau de Ychoux", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.2900, lon: -0.7900, code: "40ME025", nom: "Le Ruisseau de Moustey", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.1300, lon: -0.9300, code: "40ME026", nom: "Ruisseau de Solf√©rino", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.2000, lon: -0.9800, code: "40ME027", nom: "Le Ruisseau de Liposthey", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.3500, lon: -1.0300, code: "40ME028", nom: "Ruisseau de L√ºe", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.1600, lon: -1.2400, code: "40ME029", nom: "Le Ruisseau de Aureilhan", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.4200, lon: -0.8700, code: "40ME030", nom: "Ruisseau de Bias", type: "Cours d'eau", etat: "Bon" },
                    
                    // Plans d'eau principaux (20 masses d'eau)
                    { lat: 44.4000, lon: -1.2500, code: "40ME031", nom: "√âtang de Biscarrosse", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.5200, lon: -1.1800, code: "40ME032", nom: "√âtang de Cazaux-Sanguinet", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.3500, lon: -1.0700, code: "40ME033", nom: "√âtang de Parentis-en-Born", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.1800, lon: -1.2200, code: "40ME034", nom: "√âtang d'Aureilhan", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.2100, lon: -1.2800, code: "40ME035", nom: "√âtang de Mimizan", type: "Plan d'eau", etat: "Bon" },
                    { lat: 43.8700, lon: -1.3100, code: "40ME036", nom: "√âtang de L√©on", type: "Plan d'eau", etat: "Tr√®s bon" },
                    { lat: 43.8500, lon: -1.3800, code: "40ME037", nom: "√âtang de Moliets", type: "Plan d'eau", etat: "Bon" },
                    { lat: 43.7600, lon: -1.3300, code: "40ME038", nom: "√âtang de Soustons", type: "Plan d'eau", etat: "Bon" },
                    { lat: 43.6600, lon: -1.4000, code: "40ME039", nom: "√âtang d'Hossegor", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 43.7000, lon: -1.2800, code: "40ME040", nom: "√âtang Blanc", type: "Plan d'eau", etat: "Bon" },
                    { lat: 43.7200, lon: -1.2600, code: "40ME041", nom: "√âtang Noir", type: "Plan d'eau", etat: "Bon" },
                    { lat: 42.8800, lon: -0.4300, code: "40ME042", nom: "R√©servoir de Bious-Artigues", type: "Plan d'eau", etat: "Tr√®s bon" },
                    { lat: 43.8900, lon: -0.5000, code: "40ME043", nom: "Lac de Christus", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.1200, lon: -0.4200, code: "40ME044", nom: "Lac de l'Uby", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.2100, lon: -0.9700, code: "40ME045", nom: "√âtang de Liposthey", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.2300, lon: -0.8100, code: "40ME046", nom: "Lac de Commensacq", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.2900, lon: -0.8700, code: "40ME047", nom: "√âtang de Trensacq", type: "Plan d'eau", etat: "Tr√®s bon" },
                    { lat: 43.8600, lon: -1.3300, code: "40ME048", nom: "Petit √âtang de L√©on", type: "Plan d'eau", etat: "Bon" },
                    { lat: 43.8100, lon: -1.3500, code: "40ME049", nom: "Lac de Tosse", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.4500, lon: -0.6800, code: "40ME050", nom: "√âtang de Louchats", type: "Plan d'eau", etat: "Tr√®s bon" }
                ],
                '33': [
                    // Gironde - 50 masses d'eau (30 cours d'eau + 20 plans d'eau)
                    { lat: 44.8378, lon: -0.5792, code: "33ME001", nom: "La Garonne √† Bordeaux", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.8200, lon: -0.6500, code: "33ME002", nom: "La Dordogne √† Libourne", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.7500, lon: -0.7200, code: "33ME003", nom: "L'Isle girondine", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.9000, lon: -0.8000, code: "33ME004", nom: "La Gironde estuarienne", type: "Estuaire", etat: "Moyen" },
                    { lat: 44.6500, lon: -0.9500, code: "33ME005", nom: "Le Ciron", type: "Cours d'eau", etat: "Tr√®s bon" },
                    { lat: 44.5800, lon: -0.4200, code: "33ME006", nom: "La Dronne girondine", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.7200, lon: -0.3500, code: "33ME007", nom: "L'Engranne", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.8500, lon: -0.4500, code: "33ME008", nom: "Le Jallel", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.9200, lon: -0.6800, code: "33ME009", nom: "La Jalle de Blanquefort", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.7800, lon: -0.8200, code: "33ME010", nom: "L'Eau Bourde", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.6800, lon: -0.8800, code: "33ME011", nom: "La Leyre girondine", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.6200, lon: -1.0200, code: "33ME012", nom: "Le Beuve", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.5500, lon: -1.1500, code: "33ME013", nom: "Le Canal des Landes", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.8800, lon: -0.9200, code: "33ME014", nom: "Les Jalles m√©docaines", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.9500, lon: -1.0500, code: "33ME015", nom: "La Jalle du Nord", type: "Cours d'eau", etat: "Bon" },
                    { lat: 45.0200, lon: -0.7800, code: "33ME016", nom: "L'Estuaire amont", type: "Estuaire", etat: "Moyen" },
                    { lat: 44.4500, lon: -0.6500, code: "33ME017", nom: "Le Lot de Garonne", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.3800, lon: -0.4800, code: "33ME018", nom: "La Garonne amont", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.5200, lon: -0.3200, code: "33ME019", nom: "La Lidoire", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.4800, lon: -0.5800, code: "33ME020", nom: "Le Dropt girondin", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.6000, lon: -0.6800, code: "33ME021", nom: "La Garonne m√©diane", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.7000, lon: -0.5500, code: "33ME022", nom: "La Garonne bordelaise", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.8000, lon: -0.4800, code: "33ME023", nom: "Le Peugue", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.8600, lon: -0.5200, code: "33ME024", nom: "La Dev√®ze", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.9100, lon: -0.5800, code: "33ME025", nom: "Le Gua", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.7600, lon: -0.9500, code: "33ME026", nom: "La Leyre moyenne", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.8200, lon: -1.0200, code: "33ME027", nom: "Le Beuve amont", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 44.8800, lon: -1.0800, code: "33ME028", nom: "Les chenaux m√©docains", type: "Cours d'eau", etat: "Bon" },
                    { lat: 44.9500, lon: -1.1500, code: "33ME029", nom: "La Garonne maritime", type: "Estuaire", etat: "Moyen" },
                    { lat: 45.0000, lon: -0.9500, code: "33ME030", nom: "L'estuaire aval", type: "Estuaire", etat: "Moyen" },
                    
                    // Plans d'eau girondins (20 masses d'eau)
                    { lat: 44.8500, lon: -0.6200, code: "33ME031", nom: "Lac de Bordeaux", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.7800, lon: -0.8500, code: "33ME032", nom: "R√©servoirs de Hostens", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.6500, lon: -0.9800, code: "33ME033", nom: "√âtang de la Poujade", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.5800, lon: -1.0500, code: "33ME034", nom: "Lac de Lacanau", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.4200, lon: -1.1800, code: "33ME035", nom: "Bassin d'Arcachon Nord", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.3500, lon: -1.2200, code: "33ME036", nom: "Bassin d'Arcachon Sud", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.7200, lon: -0.7800, code: "33ME037", nom: "Gravi√®res de l'Isle", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.8800, lon: -0.7200, code: "33ME038", nom: "Plans d'eau de Bruges", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.9200, lon: -0.8500, code: "33ME039", nom: "√âtangs m√©docains", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.6800, lon: -0.4500, code: "33ME040", nom: "Lac de Gurson", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.5200, lon: -0.3800, code: "33ME041", nom: "Retenue de Blaignac", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.4800, lon: -0.4200, code: "33ME042", nom: "Plan d'eau de la R√©ole", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.3800, lon: -0.5500, code: "33ME043", nom: "Gravi√®res de Garonne", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.6000, lon: -0.8500, code: "33ME044", nom: "√âtang de Cousseau", type: "Plan d'eau", etat: "Tr√®s bon" },
                    { lat: 44.7500, lon: -1.0800, code: "33ME045", nom: "R√©servoir du Porge", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.8200, lon: -1.1200, code: "33ME046", nom: "Plans d'eau de Hourtin", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 44.8800, lon: -1.1800, code: "33ME047", nom: "Lac d'Hourtin-Carcans", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.9500, lon: -1.2200, code: "33ME048", nom: "√âtang de Hourtin", type: "Plan d'eau", etat: "Moyen" },
                    { lat: 45.0200, lon: -1.1500, code: "33ME049", nom: "Plans d'eau du Verdon", type: "Plan d'eau", etat: "Bon" },
                    { lat: 44.4500, lon: -1.0200, code: "33ME050", nom: "R√©servoir de Cazaux", type: "Plan d'eau", etat: "Moyen" }
                ],
                '64': [
                    { lat: 43.4897, lon: -1.4792, code: "FRFR04", nom: "L'Adour de Bayonne √† la mer", type: "Cours d'eau", etat: "Bon" },
                    { lat: 43.3158, lon: -0.9322, code: "FRFR05", nom: "Les Gaves r√©unis de Peyrehorade √† l'Adour", type: "Cours d'eau", etat: "Moyen" }
                ],
                '31': [
                    { lat: 43.6045, lon: 1.4442, code: "FRFG20", nom: "La Garonne toulousaine", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 43.4833, lon: 1.0333, code: "FRFR45", nom: "L'Ari√®ge", type: "Cours d'eau", etat: "Bon" }
                ],
                '69': [
                    { lat: 45.7640, lon: 4.8357, code: "FRFR60", nom: "Le Rh√¥ne lyonnais", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 45.7167, lon: 4.9500, code: "FRFR61", nom: "La Sa√¥ne confluent", type: "Cours d'eau", etat: "Moyen" }
                ],
                '13': [
                    { lat: 43.6792, lon: 4.6298, code: "FRFR70", nom: "Le Rh√¥ne delta", type: "Cours d'eau", etat: "Moyen" },
                    { lat: 43.3000, lon: 5.4000, code: "FRFR71", nom: "L'Arc", type: "Cours d'eau", etat: "M√©diocre" }
                ],
                '75': [
                    { lat: 48.8566, lon: 2.3522, code: "FRFG25", nom: "La Seine parisienne", type: "Cours d'eau", etat: "Moyen" }
                ]
            };
            
            const masses = massesDataAuth[deptCode] || [];
            console.log(`üìä ${masses.length} masses d'eau de r√©f√©rence trouv√©es`);
            
            if (masses.length === 0) {
                const marker = L.marker([44.1, -1.1]).addTo(massesEauLayer);
                marker.bindPopup(`
                    <div class="modern-popup-container">
                        <div class="popup-header" style="background: linear-gradient(135deg, #6b7280 0%, #6b7280CC 100%);">
                            <div class="popup-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                                    <path d="M12 2l-2 7h4l-2-7z"/>
                                    <path d="M8 9c0 2 1 4 4 4s4-2 4-4"/>
                                    <path d="M6 15c0 3 2.5 6 6 6s6-3 6-6"/>
                                </svg>
                            </div>
                            <div class="popup-title-section">
                                <h3>Masses d'Eau</h3>
                                <p>Aucune r√©f√©renc√©e</p>
                            </div>
                        </div>
                        <div class="popup-body">
                            <p>Aucune masse d'eau r√©f√©renc√©e pour le d√©partement ${deptCode}</p>
                        </div>
                    </div>`);
                return;
            }
            
            masses.forEach(function(masse) {
                // Couleur selon l'√©tat √©cologique
                let couleur = "#10b981"; // Bon par d√©faut
                if (masse.etat === "Tr√®s bon") couleur = "#059669";
                else if (masse.etat === "Moyen") couleur = "#f59e0b";
                else if (masse.etat === "M√©diocre") couleur = "#ef4444";
                else if (masse.etat === "Mauvais") couleur = "#dc2626";
                
                const marker = L.marker([masse.lat, masse.lon], {
                    icon: L.divIcon({
                        className: "custom-div-icon",
                        html: `<div style='background:${couleur}; color:white; padding:3px 6px; border-radius:4px; font-size:11px; font-weight:bold; border:2px solid white; box-shadow:0 2px 4px rgba(0,0,0,0.3);'>ME</div>`,
                        iconSize: [30, 20]
                    })
                }).addTo(massesEauLayer);
                
                const popupContent = `
                    <div class="modern-popup-container">
                        <div class="popup-header" style="background: linear-gradient(135deg, ${couleur} 0%, ${couleur}CC 100%);">
                            <div class="popup-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                                    <path d="M12 2l-2 7h4l-2-7z"/>
                                    <path d="M8 9c0 2 1 4 4 4s4-2 4-4"/>
                                    <path d="M6 15c0 3 2.5 6 6 6s6-3 6-6"/>
                                </svg>
                            </div>
                            <div class="popup-title-section">
                                <h3>Masse d'Eau DCE</h3>
                                <p>${masse.nom}</p>
                            </div>
                        </div>
                        <div class="popup-body">
                            <div class="popup-grid">
                                <div class="popup-item">
                                    <span class="popup-label">Code Sandre</span>
                                    <span class="popup-value"><strong>${masse.code}</strong></span>
                                </div>
                                <div class="popup-item">
                                    <span class="popup-label">√âtat √©cologique</span>
                                    <span class="popup-value" style="color: ${couleur}; font-weight: bold;">${masse.etat}</span>
                                </div>
                                <div class="popup-item">
                                    <span class="popup-label">Type</span>
                                    <span class="popup-value">${masse.type}</span>
                                </div>
                                <div class="popup-item">
                                    <span class="popup-label">D√©partement</span>
                                    <span class="popup-value">${deptCode}</span>
                                </div>
                                <div class="popup-item">
                                    <span class="popup-label">Source</span>
                                    <span class="popup-value" style="font-size: 12px;">Sandre MDO (r√©f√©rentiel)</span>
                                </div>
                            </div>
                        </div>
                    </div>`;
                
                marker.bindPopup(popupContent);
            });
        }

        // Fonctions d'analyse spatio-temporelle ajout√©es pour corr√©lations multi-param√®tres, risque et clustering.

        /**
         * Calcule la matrice de corr√©lation de Pearson pour plusieurs variables √† partir des projections.
         * Les variables analys√©es sont¬†: variation, proportion d√©grad√©e, pluie, temp√©rature, risque projet√© et score de sensibilit√©.
         * @param {Array} projs Liste des objets de projection par station
         * @returns {{variables: string[], matrix: number[][]}} Tableau des noms de variables et matrice 2D des corr√©lations
         */
        function computeCorrelationMatrix(projs) {
            /**
             * Calcule dynamiquement une matrice de corr√©lation de Pearson pour toutes les variables
             * num√©riques disponibles dans l'objet de projection. Seules les variables pr√©sentes
             * (au moins deux stations avec une valeur d√©finie) sont analys√©es. Les groupes sont exclus.
             * @param {Array} projs Liste des projections
             * @returns {{variables: string[], matrix: number[][]}}
             */
            // D√©finir des variables candidates susceptibles d'√™tre corr√©l√©es.  Ces champs
            // correspondent aux principaux param√®tres hydrom√©t√©orologiques et de ressources en eau.
            const candidateVars = [
                'variation',        // Variation du poids moyen des modalit√©s
                'degradedPct',      // Pourcentage de modalit√©s d√©grad√©es
                'rain',             // Pr√©cipitations cumul√©es (mm)
                'temp',             // Temp√©rature moyenne (¬∞C)
                'prelev',           // Volume de pr√©l√®vement (m¬≥) ‚Äì doit √™tre ajout√© sur les projections si disponible
                'nappe',            // Niveau de nappe phr√©atique ‚Äì idem
                'debit',            // D√©bit moyen (m¬≥/s) ‚Äì idem
                'restrictions',     // Nombre ou intensit√© de restrictions d‚Äôeau ‚Äì idem
                'risk',             // Indice de risque projet√©
                'sensitivityScore'  // Score de sensibilit√© calcul√©
            ];
            // D√©terminer quelles variables sont effectivement pr√©sentes dans les projections.
            const variables = [];
            const dataMap = {};
            candidateVars.forEach(v => {
                let count = 0;
                projs.forEach(p => {
                    if (!p.entity.startsWith('Groupe:')) {
                        const val = parseFloat(p[v]);
                        if (!isNaN(val)) count++;
                    }
                });
                if (count > 1) {
                    variables.push(v);
                    dataMap[v] = [];
                }
            });
            // Construire les tableaux de donn√©es align√©s par station
            projs.forEach(p => {
                if (!p.entity.startsWith('Groupe:')) {
                    variables.forEach(v => {
                        const val = parseFloat(p[v]);
                        if (!isNaN(val)) {
                            dataMap[v].push(val);
                        } else {
                            // Utiliser null pour les valeurs manquantes afin de filtrer par la suite
                            dataMap[v].push(null);
                        }
                    });
                }
            });
            // Calculer la matrice de corr√©lation 2D
            const matrix = [];
            for (let i = 0; i < variables.length; i++) {
                const row = [];
                for (let j = 0; j < variables.length; j++) {
                    if (i === j) {
                        row.push(1);
                    } else {
                        // Filtrer les valeurs nulles pour le calcul de corr√©lation
                        const xi = dataMap[variables[i]];
                        const yj = dataMap[variables[j]];
                        const xs = [];
                        const ys = [];
                        for (let k = 0; k < xi.length; k++) {
                            if (xi[k] != null && yj[k] != null) {
                                xs.push(xi[k]);
                                ys.push(yj[k]);
                            }
                        }
                        let corr = 0;
                        if (xs.length > 1) {
                            corr = pearsonCorrelation(xs, ys);
                        }
                        row.push(Math.round(corr * 100) / 100);
                    }
                }
                matrix.push(row);
            }
            return { variables, matrix };
        }

        /**
         * Affiche une heatmap repr√©sentant la matrice de corr√©lation.
         * @param {number[][]} matrix Matrice des corr√©lations
         * @param {string[]} vars Noms des variables √† afficher
         */
        function renderCorrelationHeatmap(matrix, vars) {
            const dom = document.getElementById('corrMatrixChart');
            if (!dom) return;
            // Si aucune variable n'est fournie, afficher un message et quitter
            if (!vars || vars.length === 0 || !matrix || matrix.length === 0) {
                dom.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400">Aucune corr√©lation √† afficher.</p>';
                if (charts.corrMatrix) charts.corrMatrix.dispose();
                return;
            }
            if (charts.corrMatrix) charts.corrMatrix.dispose();
            charts.corrMatrix = echarts.init(dom, null, { renderer: 'canvas' });
            const data = [];
            for (let i = 0; i < vars.length; i++) {
                for (let j = 0; j < vars.length; j++) {
                    data.push([j, i, matrix[i][j]]);
                }
            }
            const axisColor = document.documentElement.classList.contains('dark') ? '#888888' : '#444444';
            charts.corrMatrix.setOption({
                tooltip: {
                    formatter: params => {
                        const xName = vars[params.data[0]];
                        const yName = vars[params.data[1]];
                        return `${xName} ‚Äì ${yName}: <strong>${params.data[2]}</strong>`;
                    }
                },
                xAxis: {
                    type: 'category',
                    data: vars,
                    splitArea: { show: true },
                    axisLabel: { rotate: 30, color: axisColor }
                },
                yAxis: {
                    type: 'category',
                    data: vars,
                    splitArea: { show: true },
                    axisLabel: { color: axisColor }
                },
                visualMap: {
                    min: -1,
                    max: 1,
                    calculable: true,
                    orient: 'horizontal',
                    left: 'center',
                    bottom: '5%',
                    inRange: {
                        color: ['#a5b4fc', '#e5e7eb', '#fca5a5']
                    },
                    text: ['Corr√©lation positive', 'Corr√©lation n√©gative']
                },
                series: [{
                    type: 'heatmap',
                    data: data,
                    label: {
                        show: true,
                        color: document.documentElement.classList.contains('dark') ? '#e5e7eb' : '#374151'
                    },
                    emphasis: {
                        itemStyle: {
                            borderColor: '#333',
                            borderWidth: 1
                        }
                    }
                }]
            });
        }

        /**
         * Calcule un indice de risque pour chaque station et un clustering simple sur les variables standardis√©es.
         * @param {Array} projs Liste des projections
         * @returns {{riskData: Array, clusterData: Array, highRiskStations: Array, clusterCounts: number[]}}
         */
        function computeRiskAndClusters(projs) {
            /**
             * Calcule un indice de risque int√©gr√© et partitionne les stations en clusters.
             * L'indice combine plusieurs facteurs : variation, pourcentage d√©grad√©,
             * pr√©cipitations (faibles pluies augmentent le risque), temp√©rature,
             * pr√©l√®vements d'eau (grands volumes augmentent le risque) et niveau
             * de nappe (niveaux bas augmentent le risque). Certaines variables
             * peuvent √™tre absentes dans les projections ‚Äî seules celles pr√©sentes
             * sont prises en compte et les poids sont renormalis√©s.
             */
            const values = [];
            projs.forEach(p => {
                if (!p.entity.startsWith('Groupe:')) {
                    const obj = { name: p.entity };
                    const v = parseFloat(p.variation);
                    const d = parseFloat(p.degradedPct);
                    const r = parseFloat(p.rain);
                    const t = parseFloat(p.temp);
                    const prel = parseFloat(p.prelev);
                    const nap = parseFloat(p.nappe);
                    const deb = parseFloat(p.debit);
                    const rest = parseFloat(p.restrictions);
                    // Inclure uniquement les variables num√©riques disponibles
                    if (!isNaN(v)) obj.variation = v;
                    if (!isNaN(d)) obj.degraded = d;
                    if (!isNaN(r)) obj.rain = r;
                    if (!isNaN(t)) obj.temp = t;
                    if (!isNaN(prel)) obj.prelev = prel;
                    if (!isNaN(nap)) obj.nappe = nap;
                    if (!isNaN(deb)) obj.debit = deb;
                    if (!isNaN(rest)) obj.restrictions = rest;
                    // Exiger au moins variation et d√©grad√© pour pouvoir calculer un indice
                    if (obj.variation !== undefined && obj.degraded !== undefined) {
                        values.push(obj);
                    }
                }
            });
            if (values.length === 0) {
                return { riskData: [], clusterData: [], highRiskStations: [], clusterCounts: [] };
            }
            // Variables disponibles pour la normalisation
            const numericKeys = Object.keys(values[0]).filter(k => k !== 'name');
            const mins = {}, maxs = {};
            numericKeys.forEach(v => {
                mins[v] = Infinity;
                maxs[v] = -Infinity;
            });
            values.forEach(o => {
                numericKeys.forEach(v => {
                    if (o[v] < mins[v]) mins[v] = o[v];
                    if (o[v] > maxs[v]) maxs[v] = o[v];
                });
            });
            numericKeys.forEach(v => {
                if (mins[v] === maxs[v]) {
                    mins[v] -= 1;
                    maxs[v] += 1;
                }
            });
            const riskData = [];
            const points = [];
            values.forEach(o => {
                // Calcule les composantes normalis√©es entre 0 et 1
                const norm = {};
                numericKeys.forEach(k => {
                    norm[k] = (o[k] - mins[k]) / (maxs[k] - mins[k]);
                });
                // D√©finir les poids des variables ; ajuster dynamiquement selon pr√©sence
                const weights = {
                    variation: 0.30,
                    degraded: 0.20,
                    rain: 0.10,
                    temp: 0.10,
                    prelev: 0.10,
                    nappe: 0.05,
                    debit: 0.10,
                    restrictions: 0.05
                };
                let weightSum = 0;
                let riskIndex = 0;
                Object.keys(weights).forEach(k => {
                    if (norm[k] !== undefined) {
                        const w = weights[k];
                        weightSum += w;
                        // D√©terminer la contribution au risque¬†: certaines variables r√©duisent le risque
                        let riskComponent;
                        if (k === 'rain' || k === 'nappe' || k === 'debit') {
                            // Plus de pluie, de niveau de nappe ou de d√©bit = moins de risque
                            riskComponent = 1 - norm[k];
                        } else if (k === 'restrictions') {
                            // Plus de restrictions = plus de risque
                            riskComponent = norm[k];
                        } else {
                            // Variation, degraded, temp, prelev¬†: un niveau √©lev√© augmente le risque
                            riskComponent = norm[k];
                        }
                        riskIndex += w * riskComponent;
                    }
                });
                if (weightSum > 0) riskIndex = riskIndex / weightSum;
                // Remplacer le nom par le code station pour les graphiques
                const codeName = stationCodesOfb[o.name] || o.name;
                riskData.push({ name: codeName, risk: Math.round(riskIndex * 100) });
                // Construire les points pour k‚Äëmeans : utiliser variation et degraded pour la position (x,y)
                const xVal = norm.variation !== undefined ? norm.variation : 0;
                const yVal = norm.degraded !== undefined ? norm.degraded : 0;
                points.push([xVal, yVal]);
            });
            // D√©terminer k par nombre de stations (maximum 3)
            const k = Math.min(3, points.length);
            const labels = kMeans(points, k);
            const clusterData = [];
            const clusterCounts = new Array(k).fill(0);
            for (let i = 0; i < values.length; i++) {
                const cl = labels[i];
                clusterCounts[cl] = (clusterCounts[cl] || 0) + 1;
                // Remplacer le nom par le code station pour l'affichage cluster
                const cName = stationHubCodes[values[i].name] || values[i].name;
                clusterData.push({ name: cName, x: values[i].variation, y: values[i].degraded, cluster: cl });
            }
            riskData.sort((a, b) => b.risk - a.risk);
            const highRiskStations = riskData.slice(0, Math.min(5, riskData.length)).map(o => o.name);
            return { riskData, clusterData, highRiskStations, clusterCounts };
        }

        /**
         * Algorithme k-means simple pour partitionner des points en k clusters.
         * @param {number[][]} data Tableau de points (features)
         * @param {number} k Nombre de clusters
         * @returns {number[]} Labels de cluster pour chaque point
         */
        function kMeans(data, k) {
            const centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push(data[i].slice());
            }
            let labels = new Array(data.length).fill(0);
            const distance = (a, b) => {
                let sum = 0;
                for (let i = 0; i < a.length; i++) {
                    const diff = a[i] - b[i];
                    sum += diff * diff;
                }
                return Math.sqrt(sum);
            };
            for (let iter = 0; iter < 10; iter++) {
                for (let i = 0; i < data.length; i++) {
                    let bestDist = Infinity;
                    let bestCluster = 0;
                    for (let c = 0; c < k; c++) {
                        const dist = distance(data[i], centroids[c]);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestCluster = c;
                        }
                    }
                    labels[i] = bestCluster;
                }
                const sums = Array.from({ length: k }, () => new Array(data[0].length).fill(0));
                const counts = new Array(k).fill(0);
                for (let i = 0; i < data.length; i++) {
                    const l = labels[i];
                    counts[l]++;
                    for (let j = 0; j < data[i].length; j++) {
                        sums[l][j] += data[i][j];
                    }
                }
                for (let c = 0; c < k; c++) {
                    if (counts[c] === 0) continue;
                    for (let j = 0; j < centroids[c].length; j++) {
                        centroids[c][j] = sums[c][j] / counts[c];
                    }
                }
            }
            return labels;
        }

        /**
         * Affiche un graphique en barres des indices de risque par station et met √† jour la liste de risque.
         * @param {{name: string, risk: number}[]} riskData Donn√©es sur le risque pour chaque station
         */
        function renderRiskChart(riskData) {
            const listEl = document.getElementById('riskList');
            if (!riskData || riskData.length === 0) {
                if (listEl) {
                    listEl.innerHTML = '<li>Aucune donn√©e de risque √† afficher.</li>';
                }
                const dom = document.getElementById('riskChart');
                if (dom) {
                    dom.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400">Aucune donn√©e de risque √† afficher.</p>';
                }
                return;
            }
            if (listEl) {
                listEl.innerHTML = '';
                riskData.slice(0, 5).forEach(o => {
                    const li = document.createElement('li');
                    li.textContent = `${o.name} (${o.risk}%)`;
                    listEl.appendChild(li);
                });
            }
            const dom = document.getElementById('riskChart');
            if (!dom) return;
            if (charts.riskChart) charts.riskChart.dispose();
            charts.riskChart = echarts.init(dom, null, { renderer: 'canvas' });
            const names = riskData.map(o => o.name);
            const values = riskData.map(o => o.risk);
            const colors = riskData.map(o => {
                return o.risk >= 75 ? '#ef4444' : o.risk >= 50 ? '#f59e0b' : '#10b981';
            });
            const axisColor = document.documentElement.classList.contains('dark') ? '#888888' : '#444444';
            const splitLineColor = document.documentElement.classList.contains('dark') ? '#444444' : '#e0e0e0';
            charts.riskChart.setOption({
                grid: { left: '5%', right: '5%', bottom: '12%', top: '10%', containLabel: true },
                xAxis: {
                    type: 'category',
                    data: names,
                    axisLabel: { rotate: 40, color: axisColor },
                    axisLine: { lineStyle: { color: axisColor } },
                    axisTick: { show: false }
                },
                yAxis: {
                    type: 'value',
                    max: 100,
                    axisLine: { lineStyle: { color: axisColor } },
                    axisLabel: { color: axisColor, formatter: '{value}%' },
                    splitLine: { lineStyle: { color: splitLineColor } }
                },
                series: [{
                    type: 'bar',
                    data: values,
                    itemStyle: {
                        color: function(params) {
                            return colors[params.dataIndex];
                        },
                        borderRadius: [4, 4, 0, 0]
                    },
                    label: {
                        show: true,
                        position: 'top',
                        formatter: p => `${p.value}%`,
                        color: document.documentElement.classList.contains('dark') ? '#e5e7eb' : '#374151'
                    }
                }]
            });
        }

        /**
         * Affiche un nuage de points Variation vs D√©grad√© color√© selon le cluster attribu√©.
         * @param {{name:string, x:number, y:number, cluster:number}[]} clusterData Donn√©es clusteris√©es
         */
        function renderClusterChart(clusterData) {
            const dom = document.getElementById('clusterChart');
            if (!dom) return;
            if (!clusterData || clusterData.length === 0) {
                dom.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400">Aucun clustering √† afficher.</p>';
                if (charts.clusterChart) charts.clusterChart.dispose();
                return;
            }
            if (charts.clusterChart) charts.clusterChart.dispose();
            charts.clusterChart = echarts.init(dom, null, { renderer: 'canvas' });
            const axisColor = document.documentElement.classList.contains('dark') ? '#888888' : '#444444';
            const clusters = [...new Set(clusterData.map(d => d.cluster))].sort();
            const colors = ['#6366f1', '#f59e0b', '#10b981', '#ec4899', '#7c3aed'];
            const series = clusters.map(c => {
                return {
                    name: `Groupe ${c + 1}`,
                    type: 'scatter',
                    data: clusterData.filter(d => d.cluster === c).map(d => [d.x, d.y, d.name]),
                    symbolSize: 10,
                    itemStyle: { color: colors[c % colors.length] },
                    label: {
                        show: false,
                        formatter: param => param.data[2],
                        position: 'right'
                    }
                };
            });
            charts.clusterChart.setOption({
                tooltip: {
                    formatter: param => {
                        const [x, y, name] = param.data;
                        return `${name}<br/>Variation: ${x.toFixed(2)}%<br/>D√©grad√©: ${y.toFixed(2)}%`;
                    }
                },
                legend: {
                    data: series.map(s => s.name),
                    top: 0,
                    textStyle: { color: axisColor }
                },
                grid: { left: '8%', right: '4%', bottom: '12%', top: '12%', containLabel: true },
                xAxis: {
                    type: 'value',
                    name: 'Variation (%)',
                    nameLocation: 'middle',
                    nameGap: 25,
                    axisLine: { lineStyle: { color: axisColor } },
                    axisLabel: { color: axisColor }
                },
                yAxis: {
                    type: 'value',
                    name: 'D√©grad√© (%)',
                    nameLocation: 'middle',
                    nameGap: 40,
                    axisLine: { lineStyle: { color: axisColor } },
                    axisLabel: { color: axisColor }
                },
                series: series
            });
        }

        /**
         * Met √† jour dynamiquement l'affichage des √©l√©ments de l√©gende en fonction de l'√©tat des couches.
         * Affiche ou masque les sections √âcoulement, D√©bits, Nappes, Pr√©l√®vements et Restrictions d'eau,
         * ainsi que les l√©gendes de sensibilit√© et de projection selon le mode s√©lectionn√©.
         */
        async function updateLegendVisibility() {
            const showEco = document.getElementById('toggleEcoulement')?.checked;
            const showDeb = document.getElementById('toggleDebits')?.checked;
            const showNap = document.getElementById('toggleNappes')?.checked;
            const showPrel = document.getElementById('togglePrelevements')?.checked;
            const showRest = document.getElementById('toggleRestrictions')?.checked;
            const showQual = document.getElementById('toggleQualite')?.checked;
            const showFlo  = document.getElementById('toggleFlore')?.checked;
            const showObs = document.getElementById('toggleObstacles')?.checked;
            const showBassins = document.getElementById("toggleBassins")?.checked;
            const showMassesEau = document.getElementById("toggleMassesEau")?.checked;
            const showZonesHumides = document.getElementById("toggleZonesHumides")?.checked;
            const showHER = document.getElementById("toggleHER")?.checked;
            const showSAGE = document.getElementById("toggleSAGE")?.checked;
            
            console.log("updateLegendVisibility - Bassins:", showBassins, "Masses d'eau:", showMassesEau, "Zones humides:", showZonesHumides, "HER:", showHER, "SAGE:", showSAGE);
            
            // Charger/d√©charger les nouvelles couches selon les toggles
            if (showBassins) {
                if (!bassinsLayer) bassinsLayer = L.layerGroup();
                loadBassinsVersants(selectedDept);
                if (map && !map.hasLayer(bassinsLayer)) {
                    map.addLayer(bassinsLayer);
                }
            } else if (bassinsLayer && map && map.hasLayer(bassinsLayer)) {
                map.removeLayer(bassinsLayer);
            }

            if (showMassesEau) {
                if (!massesEauLayer) massesEauLayer = L.layerGroup();
                await loadMassesEau(selectedDept);
                if (map && !map.hasLayer(massesEauLayer)) {
                    map.addLayer(massesEauLayer);
                }
            } else if (massesEauLayer && map && map.hasLayer(massesEauLayer)) {
                map.removeLayer(massesEauLayer);
            }

            if (showZonesHumides) {
                if (typeof zonesHumidesLayer === 'undefined') zonesHumidesLayer = L.layerGroup();
                if (!zonesHumidesLayer) zonesHumidesLayer = L.layerGroup();
                loadZonesHumides(selectedDept);
                if (map && !map.hasLayer(zonesHumidesLayer)) {
                    map.addLayer(zonesHumidesLayer);
                }
            } else if (typeof zonesHumidesLayer !== 'undefined' && zonesHumidesLayer && map && map.hasLayer(zonesHumidesLayer)) {
                map.removeLayer(zonesHumidesLayer);
            }
            
            // Gestion des Hydro-√©cor√©gions (HER) - couverture nationale
            if (showHER) {
                if (typeof herLayer === 'undefined') herLayer = L.layerGroup();
                if (!herLayer) herLayer = L.layerGroup();
                loadHydroEcoregions();
                if (map && !map.hasLayer(herLayer)) {
                    map.addLayer(herLayer);
                }
            } else if (typeof herLayer !== 'undefined' && herLayer && map && map.hasLayer(herLayer)) {
                map.removeLayer(herLayer);
            }
            
            // Gestion des zones SAGE - couverture nationale  
            if (showSAGE) {
                if (typeof sageLayer === 'undefined') sageLayer = L.layerGroup();
                if (!sageLayer) sageLayer = L.layerGroup();
                loadZonesSAGE();
                if (map && !map.hasLayer(sageLayer)) {
                    map.addLayer(sageLayer);
                }
            } else if (typeof sageLayer !== 'undefined' && sageLayer && map && map.hasLayer(sageLayer)) {
                map.removeLayer(sageLayer);
            }
            // Afficher/masquer les groupes de l√©gende pour les √©coulements et les restrictions
            const ecoLeg = document.getElementById('legend-ecoulement');
            if (ecoLeg) ecoLeg.style.display = showEco ? '' : 'none';
            const restLeg = document.getElementById('legend-restrictions');
            if (restLeg) restLeg.style.display = showRest ? '' : 'none';
            const obstLeg = document.getElementById('legend-obstacles');
            if (obstLeg) obstLeg.style.display = showObs ? '' : 'none';
            const bassinsLeg = document.getElementById("legend-bassins");
            if (bassinsLeg) bassinsLeg.style.display = showBassins ? "" : "none";
            const massesEauLeg = document.getElementById("legend-masses-eau");
            if (massesEauLeg) massesEauLeg.style.display = showMassesEau ? "" : "none";
            const zonesHumidesLeg = document.getElementById("legend-zones-humides");
            if (zonesHumidesLeg) zonesHumidesLeg.style.display = showZonesHumides ? "" : "none";
            const herLeg = document.getElementById("legend-her");
            if (herLeg) herLeg.style.display = showHER ? "" : "none";
            const sageLeg = document.getElementById("legend-sage");
            if (sageLeg) sageLeg.style.display = showSAGE ? "" : "none";
            // Parcourir les autres √©l√©ments de l√©gende pour les masquer si n√©cessaire
            document.querySelectorAll('#map-legend .map-legend-item').forEach(item => {
              const txt = (item.textContent || '').trim();
              if (txt.startsWith('D√©bits')) {
                item.style.display = showDeb ? '' : 'none';
              } else if (txt.startsWith('Nappes')) {
                item.style.display = showNap ? '' : 'none';
              } else if (txt.startsWith('Pr√©l√®vements')) {
                item.style.display = showPrel ? '' : 'none';
              } else if (txt.startsWith('Qualit√©')) {
                item.style.display = showQual ? '' : 'none';
              } else if (txt.startsWith('Flore')) {
                item.style.display = showFlo ? '' : 'none';
              }
            });
            // L√©gendes de sensibilit√© et projection
            const sensLeg = document.getElementById('sensitivity-legend');
            const projLeg = document.getElementById('projection-legend');
            if (sensLeg) sensLeg.style.display = (sensitiveMode && showEco) ? '' : 'none';
            if (projLeg) projLeg.style.display = (!sensitiveMode && showEco) ? '' : (showEco ? '' : 'none');
        }

// === D√©but int√©gration couche restrictions d‚Äôeau (D√©partement s√©lectionn√©) ===
const couleurNiveau = {
  vigilance: '#f9f871',
  alerte: '#f59e0b',
  alerte_renforcee: '#ef4444',
  crise: '#b91c1c'
};

function makeTextDownloadLink(props) {
  const safeName = props.nom.replace(/[^\w\-]+/g,'_').slice(0,40);
  const filename = `restrictions_${safeName}.txt`;
  let txt = `Zone¬†: ${props.nom}\n`;
  txt += `Type¬†: ${props.type}\n`;
  txt += `Niveau¬†: ${props.niveauGravite}\n\n`;
  txt += `Usages interdits¬†:\n`;
  if (Array.isArray(props.restrictions) && props.restrictions.length) {
    props.restrictions.forEach(item => {
      const desc = (item.description||'').trim().replace(/\r\n|\n/g,' ');
      txt += `‚Ä¢ ${item.nom}¬†: ${desc}\n`;
    });
  } else {
    txt += `‚Äì\n`;
  }
  txt += `\nArr√™t√©¬†: ${props.arreteRestriction || 'aucun'}\n`;
  const uri = 'data:text/plain;charset=utf-8,' + encodeURIComponent(txt);
  return `<a href="${uri}" download="${filename}">T√©l√©charger (texte)</a>`;
}

restrictionsLayer = L.geoJSON(null, {
  renderer: L.canvas(),
  style: feat => {
    const lvl = String(feat.properties.niveauGravite).toLowerCase().trim();
    const c = couleurNiveau[lvl] || '#3388ff';
    return { color: c, fillColor: c, fillOpacity: 0.4, weight: 2 };
  },
  onEachFeature: (feat, lyr) => {
    const p = feat.properties;
    let usages = '<ul style="padding-left:1em;margin:0;">';
    if (Array.isArray(p.restrictions)) {
      p.restrictions.forEach(r => {
        const desc = (r.description||'').trim().replace(/\r\n|\n/g,'<br/>');
        usages += `<li style="margin-bottom:0.5em;"><strong>${r.nom}</strong>:<br/><span style="font-size:0.9em;">${desc}</span></li>`;
      });
    } else {
      usages += '<li>‚Äì</li>';
    }
    usages += '</ul>';
    const lien = p.arreteRestriction
      ? `<a href="#" onclick="ouvrirArrete(p.arreteRestriction, p.nom); return false;" style="color: #005566; text-decoration: underline;">Voir l‚Äôarr√™t√©</a>`
      : '‚Äì';
    const downloadTxt = makeTextDownloadLink(p);

    const html = `
      <div style="max-width:350px;line-height:1.3;">
        <strong>${p.nom}</strong><br/>
        <em>Type :</em> ${p.type}<br/>
        <em>Niveau :</em> ${p.niveauGravite}<br/>
        <em>D√©pt :</em> ${p.departement?.nom||'‚Äì'}<br/>
        <hr style="margin:6px 0;"/>
        <div style="max-height:150px;overflow-y:auto;padding-right:6px;">
          <strong>Usages interdits :</strong>${usages}
        </div>
        <hr style="margin:6px 0;"/>
        ${lien}<br/>
        ${downloadTxt}
      </div>
    `;
    lyr.bindPopup(html, { maxWidth:350, maxHeight:300 });
  }
});
// === Fin int√©gration couche restrictions d‚Äôeau (D√©pt 40) ===

        const trendConfig = {
            criticalThreshold: 40,
            lowThreshold: 30,
            stableThreshold: 60,
            minObservations: 2,
            modalityWeights: {
                'assec': 4,
                'ecoulement non visible': 3,
                'ecoulement visible faible': 2,
                'ecoulement visible acceptable': 1
            },
            lowFlowThreshold: 50,
            degradedModalities: ['assec', 'ecoulement non visible', 'ecoulement visible faible'],
            debitThreshold: 0.1
        };

        const modalityColors = {
            'assec': 'red',
            'ecoulement non visible': '#ff4500',
            'ecoulement visible faible': 'orange',
            'ecoulement visible acceptable': 'green',
            'non observable': 'gray'
        };

        async function fetchViaProxy(url) {
            try {
                const response = await fetch(`/proxy?url=${encodeURIComponent(url)}`, {
                    headers: {
                        // Si l'auth ne passe pas automatiquement (401 errors), d√©commentez et utilisez vos credentials (mais insecure, ne commitez pas en clair !)
                        // 'Authorization': 'Basic ' + btoa('admin:Sri2677+')
                    }
                });
                if (!response.ok) throw new Error(`Erreur proxy ${response.status} pour ${url}`);
                return await response.json();
            } catch (error) {
                console.error(`√âchec de fetchViaProxy:`, error);
                showStatus('Erreur lors de la r√©cup√©ration des donn√©es API : ' + error.message, 'error');
                return null;
            }
        }

        function generateDynamicColors(modalities) {
            return modalities.reduce((acc, modality, index) => {
                acc[modality.toLowerCase()] = modalityColors[modality.toLowerCase()] || `hsl(${index * 60}, 70%, 50%)`;
                return acc;
            }, {});
        }

        /**
         * Lightens or darkens a HEX colour by the given percentage.
         * Positive values lighten the colour, negative values darken it.
         * @param {string} color - Hexadecimal colour (e.g. "#3b82f6").
         * @param {number} percent - Percentage to lighten (positive) or darken (negative).
         * @returns {string} The adjusted hexadecimal colour.
         */
        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#',''), 16);
            const amt = Math.round(2.55 * percent);
            let r = (num >> 16) + amt;
            let g = ((num >> 8) & 0x00FF) + amt;
            let b = (num & 0x0000FF) + amt;
            r = r < 0 ? 0 : (r > 255 ? 255 : r);
            g = g < 0 ? 0 : (g > 255 ? 255 : g);
            b = b < 0 ? 0 : (b > 255 ? 255 : b);
            return '#' + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `p-4 rounded-lg ${type === 'success' ? 'bg-[#e6f2f3] text-[#005566]' : 'bg-red-100 text-red-800'}`;
            status.style.display = 'block';
            if (type === 'success') setTimeout(() => status.style.display = 'none', 3000);
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('dashboard').style.display = show ? 'none' : 'block';
        }

        function loadDataFromFile(input) {
            const file = input.files[0];
            if (!file) return showStatus('Aucun fichier s√©lectionn√©.', 'error');
            showLoading(true);

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    const workbook = XLSX.read(arrayBuffer, { type: 'array', cellDates: true, dateNF: 'yyyy-mm-dd' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, header: 1 });

                    data = parseExcelData(jsonData);
                    if (data.length === 0) throw new Error('Aucune donn√©e valide trouv√©e (toutes les modalit√©s sont vides ou inconnues).');
                    updateStationSelect();
                    updateYearSelect();
                    updateModalitySelect();
                    updateDashboard();
                    showStatus(`${data.length} observations charg√©es !`, 'success');
                    showLoading(false);
                } catch (error) {
                    showStatus('Erreur : ' + error.message, 'error');
                    showLoading(false);
                }
            };
            reader.onerror = () => {
                showStatus('Erreur lors de la lecture du fichier.', 'error');
                showLoading(false);
            };
            reader.readAsArrayBuffer(file);
        }

        function parseExcelData(jsonData) {
            const parsedData = [];
            const findColumn = (searchTerms, headers) => headers.findIndex(header =>
                searchTerms.some(term => header?.toLowerCase().replace(/\s+/g, '').includes(term.toLowerCase().replace(/\s+/g, '')))
            );

            if (!jsonData.length || !Array.isArray(jsonData[0])) throw new Error('Fichier Excel vide ou mal format√©.');
            const headers = jsonData[0].map(h => h ? h.toString().trim() : '');
            const stationCol = findColumn(['station√©coulement', 'station'], headers);
            const modalityCol = findColumn(['modalit√© d\'√©coulement', 'modalit√©'], headers);
            const dateCol = findColumn(['date de l\'observation', 'date'], headers);
            const latCol = findColumn(['latitude'], headers);
            const lonCol = findColumn(['longitude'], headers);
            const codeStationCol = findColumn(['code station', 'code_station', 'code station (hydro)', 'codestation(hydro)', 'codestationhydro'], headers);

            if (stationCol === -1 || modalityCol === -1 || dateCol === -1) {
                throw new Error('Colonnes requises manquantes : Station, Modalit√©, Date.');
            }

            proj4.defs('EPSG:2154', '+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');

            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                const station = row[stationCol]?.toString().trim();
                const modality = row[modalityCol]?.toString().trim().toLowerCase();

                if (!station || !modality || modality === 'inconnu' || modality === 'non observable') continue; // Ignore vide, "Inconnu", or "non observable"

                let date = row[dateCol];
                if (date instanceof Date) {
                    date = date.toISOString().split('T')[0];
                } else if (date && typeof date === 'string') {
                    const parsedDate = new Date(date);
                    if (!isNaN(parsedDate.getTime())) {
                        date = parsedDate.toISOString().split('T')[0];
                    } else if (/^\d+(\.\d+)?$/.test(date)) {
                        const excelEpoch = new Date(1900, 0, 1);
                        const parsedDate = new Date(excelEpoch.getTime() + (parseFloat(date) - 2) * 24 * 60 * 60 * 1000);
                        date = parsedDate.toISOString().split('T')[0];
                    } else {
                        date = new Date().toISOString().split('T')[0];
                    }
                } else {
                    date = new Date().toISOString().split('T')[0];
                }

                parsedData.push({
                    'Station d\'√©coulement': station,
                    'Modalit√© d\'√©coulement': modality,
                    'Date de la campagne': date
                });

                // Stockage des coordonn√©es (uniques par station)
                if (latCol !== -1 && lonCol !== -1) {
                    const x = parseFloat(row[lonCol]);
                    const y = parseFloat(row[latCol]);
                    if (!isNaN(x) && !isNaN(y)) {
                        const [lon, lat] = proj4('EPSG:2154', 'EPSG:4326', [x, y]);
                        stationCoordinates[station] = { lat, lon };
                    }
                }

                // New: Stockage du code station si pr√©sent
                if (codeStationCol !== -1) {
                    const codeStation = row[codeStationCol]?.toString().trim();
                    if (codeStation) {
                        stationHubCodes[station] = codeStation;
                    }
                }
            }

            allModalities = [...new Set(parsedData.map(d => d['Modalit√© d\'√©coulement']))].sort();
            return parsedData;
        }

        /**
         * Charge les donn√©es d'√©coulement via l'API ONDE.  Cette fonction remplace
         * l'importation de fichiers Excel en interrogeant directement l'API
         * Hub'Eau pour r√©cup√©rer les stations et leurs observations pour le
         * d√©partement s√©lectionn√© (40 par d√©faut). Elle met √† jour les
         * variables globales `data`, `stationCoordinates` et `stationHubCodes`,
         * puis met √† jour l'interface (s√©lections, dashboard).
         */
        async function loadDataFromONDE() {
            showLoading(true);
            try {
                // R√©initialiser les tableaux existants
                data = [];
                stationCoordinates = {};
                stationHubCodes = {};

                // R√©cup√©ration des stations ONDE (coordonn√©es et codes)
                const staResp = await fetch(`https://hubeau.eaufrance.fr/api/v1/ecoulement/stations?code_departement=${selectedDept}&format=json&size=5000`);
                if (!staResp.ok) throw new Error(`Erreur API ONDE stations : ${staResp.status}`);
                const staJson = await staResp.json();
                const staData = staJson.data || [];
                const stationByCode = {};
                staData.forEach(sta => {
                    // Utiliser le libell√© de station ou le cours d‚Äôeau comme nom, sinon le code
                    const name = sta.libelle_station || sta.libelle_cours_eau || sta.code_station;
                    let lat = sta.latitude_station ?? sta.latitude;
                    let lon = sta.longitude_station ?? sta.longitude;
                    // Certaines donn√©es ONDE utilisent des coordonn√©es projet√©es (Lambert-93). Si lat/lon absents, essayer de convertir coord_x/coord_y
                    if ((lat == null || lon == null) && sta.coord_x != null && sta.coord_y != null) {
                        try {
                            proj4.defs('EPSG:2154', '+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
                            const [convLon, convLat] = proj4('EPSG:2154', 'EPSG:4326', [parseFloat(sta.coord_x), parseFloat(sta.coord_y)]);
                            lon = convLon;
                            lat = convLat;
                        } catch (e) {
                            // Silencieux : conversion impossible
                        }
                    }
                    if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                        stationCoordinates[name] = { lat: parseFloat(lat), lon: parseFloat(lon) };
                        stationHubCodes[name] = sta.code_station;
                        stationByCode[sta.code_station] = name;
                    }
                });

                // G√©n√©rer les codes OFB pour chaque station. Chaque station se voit attribuer un
                // identifiant construit √† partir du code du d√©partement (selectedDept) suivi d'un
                // num√©ro d'ordre √† 7 chiffres. On trie les noms de station pour assurer la
                // reproductibilit√© de l'indexation.
                stationCodesOfb = {};
                let idxOfb = 1;
                Object.keys(stationCoordinates)
                    .sort()
                    .forEach(nm => {
                        stationCodesOfb[nm] = String(selectedDept) + String(idxOfb).padStart(7, '0');
                        idxOfb++;
                    });

                // R√©cup√©ration des observations ONDE (modalit√©, date) pour le d√©partement
                const obsResp = await fetch(`https://hubeau.eaufrance.fr/api/v1/ecoulement/observations?code_departement=${selectedDept}&format=json&size=20000`);
                if (!obsResp.ok) throw new Error(`Erreur API ONDE observations : ${obsResp.status}`);
                const obsJson = await obsResp.json();
                const obsData = obsJson.data || [];
                obsData.forEach(obs => {
                    const stationName = stationByCode[obs.code_station] || obs.code_station;
                    const date = obs.date_observation ? obs.date_observation.split('T')[0] : '';
                    let modality = obs.libelle_ecoulement || obs.etat_ecoulement || '';
                    // Normaliser la cha√Æne pour correspondre aux cat√©gories attendues (minuscules, sans majuscule)
                    if (modality) {
                        modality = modality.toString().trim().toLowerCase();
                        if (modality === '√©coulement visible faible' || modality === 'ecoulement visible faible') modality = 'ecoulement visible faible';
                        else if (modality === '√©coulement visible acceptable' || modality === 'ecoulement visible acceptable') modality = 'ecoulement visible acceptable';
                        else if (modality === '√©coulement non visible' || modality === 'ecoulement non visible') modality = 'ecoulement non visible';
                        else if (modality === 'assec' || modality === 'assec ') modality = 'assec';
                    }
                    data.push({
                        "Station d'√©coulement": stationName,
                        "Modalit√© d'√©coulement": modality,
                        "Date de la campagne": date
                    });
                });

                // Mettre √† jour la liste globale des modalit√©s en fonction des observations ONDE
                allModalities = [...new Set(data.map(d => d["Modalit√© d'√©coulement"]).filter(m => m))].sort();

                if (data.length === 0) throw new Error('Aucune observation ONDE disponible.');

                updateStationSelect();
                updateYearSelect();
                updateModalitySelect();
                await updateDashboard();
                showStatus(`${data.length} observations ONDE charg√©es !`, 'success');
                showLoading(false);
            } catch (err) {
                console.error(err);
                showStatus('Erreur lors du chargement des donn√©es ONDE : ' + err.message, 'error');
                showLoading(false);
            }
        }

        function updateStationSelect() {
            const select = document.getElementById('stationSelect');
            allStations = [...new Set(data.map(d => d['Station d\'√©coulement']))].sort();
            select.innerHTML = '<option value="">S√©lectionner</option>';
            allStations.forEach(station => {
                const option = document.createElement('option');
                option.value = station;
                option.textContent = stationCodesOfb[station] || station;
                select.appendChild(option);
            });
            updateGroupList();
            initStationSearch();
        }

        function updateYearSelect() {
            const select = document.getElementById('yearSelect');
            allYears = [...new Set(data.map(d => new Date(d['Date de la campagne']).getFullYear()))].sort();
            select.innerHTML = '<option value="">S√©lectionner</option>';
            allYears.forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                select.appendChild(option);
            });
        }

        function initStationSearch() {
            const searchInput = document.getElementById('stationSearch');
            const select = document.getElementById('stationSelect');
            searchInput.addEventListener('input', () => {
                const filter = searchInput.value.toLowerCase();
                Array.from(select.options).forEach(opt => {
                    if (opt.value === '') return;
                    opt.style.display = opt.text.toLowerCase().includes(filter) ? 'block' : 'none';
                });
            });
        }

        function updateModalitySelect() {
            const select = document.getElementById('modalitySelect');
            select.innerHTML = '<option value="">Toutes</option>';
            allModalities.forEach(modality => {
                const option = document.createElement('option');
                option.value = modality;
                option.textContent = modality;
                select.appendChild(option);
            });
        }

        function createStationGroup() {
            const groupName = document.getElementById('groupName').value.trim();
            const selectedStations = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);

            if (!groupName || selectedStations.length === 0 || selectedStations[0] === '') {
                return showStatus('Nom de groupe ou stations non sp√©cifi√©s.', 'error');
            }

            if (stationGroups[groupName]) {
                return showStatus(`Le groupe "${groupName}" existe d√©j√†.`, 'error');
            }

            stationGroups[groupName] = selectedStations;
            document.getElementById('groupName').value = '';
            updateGroupList();
            updateStationSelectWithGroups();
            showStatus(`Groupe "${groupName}" cr√©√© !`, 'success');
        }

        function updateGroupList() {
            const groupList = document.getElementById('groupList');
            groupList.innerHTML = '';
            if (Object.keys(stationGroups).length > 0) {
                groupList.style.display = 'block';
                Object.keys(stationGroups).forEach(group => {
                    const div = document.createElement('div');
                    div.className = 'flex justify-between items-center p-2 border-b border-[#b3d6d8] dark:border-gray-600';
                    div.innerHTML = `
                        <span class="text-gray-800 dark:text-gray-200"><strong>${group}</strong>: ${stationGroups[group].join(', ')}</span>
                        <button onclick="deleteGroup('${group}')" class="bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600">Supprimer</button>
                    `;
                    groupList.appendChild(div);
                });
            } else {
                groupList.style.display = 'none';
            }
            updateStationSelectWithGroups();
        }

        function updateStationSelectWithGroups() {
            const select = document.getElementById('stationSelect');
            select.innerHTML = '<option value="">S√©lectionner</option>';
            allStations.forEach(station => {
                const option = document.createElement('option');
                option.value = station;
                option.textContent = stationCodesOfb[station] || station;
                select.appendChild(option);
            });
            Object.keys(stationGroups).forEach(group => {
                const option = document.createElement('option');
                option.value = `group:${group}`;
                option.textContent = `Groupe: ${group}`;
                select.appendChild(option);
            });
        }

        function deleteGroup(groupName) {
            delete stationGroups[groupName];
            updateGroupList();
            updateDashboard();
            showStatus(`Groupe "${groupName}" supprim√©.`, 'success');
        }

        function getFilteredData() {
            const selections = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);
            const modalities = Array.from(document.getElementById('modalitySelect').selectedOptions).map(opt => opt.value);
            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => parseInt(opt.value));

            let filteredData = [...data];
            let stations = [];

            selections.forEach(selection => {
                if (selection.startsWith('group:')) {
                    const groupName = selection.replace('group:', '');
                    if (stationGroups[groupName]) stations.push(...stationGroups[groupName]);
                } else {
                    stations.push(selection);
                }
            });

            if (stations.length > 0 && stations[0] !== '') {
                filteredData = filteredData.filter(d => stations.includes(d['Station d\'√©coulement']));
            }
            if (modalities.length > 0 && modalities[0] !== '') {
                filteredData = filteredData.filter(d => modalities.includes(d['Modalit√© d\'√©coulement']));
            }
            if (years.length > 0 && years[0] !== NaN) {
                filteredData = filteredData.filter(d => years.includes(new Date(d['Date de la campagne']).getFullYear()));
            }

            // Si la comparaison avec l'ann√©e pr√©c√©dente est activ√©e, inclure l'ann√©e pr√©c√©dente
            if (comparePreviousYear) {
                const currentYears = [...new Set(filteredData.map(d => new Date(d['Date de la campagne']).getFullYear()))];
                const previousYears = currentYears.map(year => year - 1);
                filteredData = [...data].filter(d => {
                    const year = new Date(d['Date de la campagne']).getFullYear();
                    return currentYears.includes(year) || previousYears.includes(year);
                });
                if (stations.length > 0 && stations[0] !== '') {
                    filteredData = filteredData.filter(d => stations.includes(d['Station d\'√©coulement']));
                }
                if (modalities.length > 0 && modalities[0] !== '') {
                    filteredData = filteredData.filter(d => modalities.includes(d['Modalit√© d\'√©coulement']));
                }
            }

            return filteredData;
        }

        function resetFilters() {
            document.getElementById('stationSelect').value = '';
            document.getElementById('modalitySelect').value = '';
            document.getElementById('groupName').value = '';
            document.getElementById('yearSelect').value = '';
            // L‚Äôoption de comparaison N-1 est d√©sactiv√©e d√©finitivement, on ne manipule plus l‚Äô√©l√©ment DOM
            comparePreviousYear = false;
            includeWeather = true;
            sensitiveMode = false;
            document.getElementById('toggleSensitive').textContent = 'Afficher Stations Sensibles';
            document.getElementById('toggleEcoulement').checked = true;
            document.getElementById('toggleDebits').checked = true;
            document.getElementById('toggleNappes').checked = true;
            document.getElementById('togglePrelevements').checked = true;
            // R√©initialiser la couche restrictions d'eau : par d√©faut d√©sactiv√©e
            const toggleRestEl = document.getElementById('toggleRestrictions');
            if (toggleRestEl) {
                toggleRestEl.checked = false;
            }
            // La section d'analyse IA a √©t√© supprim√©e ; plus de masquage n√©cessaire.
            // Hide the analysis panel on reset
            const analysisPanel = document.getElementById('analysis-section');
            if (analysisPanel) analysisPanel.style.display = 'none';
            updateDashboard();
        }

        // ------------------------------------------------------------
        // Analyse Spatio-Temporelle sans IA
        // Ces fonctions calculent des statistiques descriptives et des corr√©lations
        // pour les stations s√©lectionn√©es en utilisant les variables d√©j√† collect√©es
        // (variation, pourcentage de modalit√©s d√©grad√©es, r√©currence des faibles
        // √©coulements). Les r√©sultats alimentent un panneau d'analyse d√©di√©.

        /**
         * Calcule le coefficient de corr√©lation de Pearson entre deux tableaux.
         * @param {number[]} x Tableau des valeurs X
         * @param {number[]} y Tableau des valeurs Y
         * @returns {number} Coefficient de corr√©lation (entre -1 et 1)
         */
        function pearsonCorrelation(x, y) {
            const n = x.length;
            if (n === 0) return 0;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
            for (let i = 0; i < n; i++) {
                sumX += x[i];
                sumY += y[i];
                sumXY += x[i] * y[i];
                sumX2 += x[i] * x[i];
                sumY2 += y[i] * y[i];
            }
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            return denominator === 0 ? 0 : numerator / denominator;
        }

        /**
         * Affiche une carte des zones sensibles en utilisant Leaflet. La carte met en
         * √©vidence les stations identifi√©es comme √©tant √† risque √©lev√©. Chaque station
         * est repr√©sent√©e par un marqueur rouge et un popup indiquant son nom.
         * @param {string[]} highRiskStations Liste des noms des stations √† risque √©lev√©
         */
        /**
         * Cr√©e une carte Leaflet montrant les stations √† risque avec des cercles color√©s.
         * Chaque cercle est dimensionn√© et color√© en fonction du niveau de risque¬†: vert pour faible, orange pour moyen, rouge pour √©lev√©.
         * Une l√©gende est ajout√©e pour aider √† l‚Äôinterpr√©tation.
         * @param {{name:string,risk:number}[]} riskData Donn√©es de risque pour les stations s√©lectionn√©es
         */
        function createSensitiveMap(riskData) {
            const container = document.getElementById('sensitiveMap');
            if (!container) return;
            // R√©initialiser la carte existante
            if (window.sensitiveMap) {
                window.sensitiveMap.remove();
                window.sensitiveMap = null;
            }
            // Cr√©er la carte Leaflet
            const mapInst = L.map('sensitiveMap', {
                attributionControl: false,
                zoomControl: false
            });
            window.sensitiveMap = mapInst;
            // Utiliser une couche de fond vierge afin d'√©viter les appels externes.
            // Cette couche g√©n√®re simplement des tuiles vides pour offrir un fond neutre.
            const blankLayer = L.gridLayer({ attribution: '' });
            blankLayer.createTile = function(coords) {
                const tile = document.createElement('canvas');
                tile.width = 256;
                tile.height = 256;
                return tile;
            };
            blankLayer.addTo(mapInst);
            const latLngs = [];
            // S√©parer les coordonn√©es selon les niveaux de risque afin de dessiner des zones par couleur
            const highCoords = [];
            const mediumCoords = [];
            const lowCoords = [];
            riskData.forEach(item => {
                const coord = stationCoordinates[item.name];
                if (coord) {
                    const riskVal = item.risk;
                    let color;
                    if (riskVal >= 75) {
                        color = '#ef4444';
                        highCoords.push([coord.lat, coord.lon]);
                    } else if (riskVal >= 50) {
                        color = '#f59e0b';
                        mediumCoords.push([coord.lat, coord.lon]);
                    } else {
                        color = '#10b981';
                        lowCoords.push([coord.lat, coord.lon]);
                    }
                    // Rayon en m√®tres¬†: entre 1¬†km et 4¬†km selon le risque
                    const radius = 1000 + (riskVal / 100) * 3000;
                    L.circle([coord.lat, coord.lon], {
                        color: color,
                        fillColor: color,
                        fillOpacity: 0.5,
                        radius: radius
                    }).bindPopup(`${item.name}<br/>Indice de risque¬†: ${riskVal}%`).addTo(mapInst);
                    latLngs.push([coord.lat, coord.lon]);
                }
            });
            // G√©n√©rer des rectangles repr√©sentant les zones sensibles pour chaque groupe de risque
            function addZone(coordsArray, color) {
                if (coordsArray.length < 2) return;
                let minLat = coordsArray[0][0], maxLat = coordsArray[0][0];
                let minLon = coordsArray[0][1], maxLon = coordsArray[0][1];
                coordsArray.forEach(c => {
                    if (c[0] < minLat) minLat = c[0];
                    if (c[0] > maxLat) maxLat = c[0];
                    if (c[1] < minLon) minLon = c[1];
                    if (c[1] > maxLon) maxLon = c[1];
                });
                // Ajouter une marge pour que la zone ne soit pas trop serr√©e
                const latPad = 0.03;
                const lonPad = 0.05;
                const bounds = [
                    [minLat - latPad, minLon - lonPad],
                    [maxLat + latPad, maxLon + lonPad]
                ];
                L.rectangle(bounds, {
                    color: color,
                    weight: 0,
                    fillColor: color,
                    fillOpacity: 0.15
                }).addTo(mapInst);
            }
            // Ajouter les zones pour les risques √©lev√©, moyen et faible
            addZone(highCoords, '#ef4444');
            addZone(mediumCoords, '#f59e0b');
            addZone(lowCoords, '#10b981');
            // Ajuster la vue sur les cercles ou centrer sur le d√©partement
            if (latLngs.length > 0) {
                mapInst.fitBounds(latLngs, { padding: [20, 20] });
            } else {
                // Position centrale du d√©partement des Landes
                mapInst.setView([43.933, -0.9], 8);
            }
            // Ajouter une l√©gende descriptive
            const legend = L.control({ position: 'bottomright' });
            legend.onAdd = function() {
                const div = L.DomUtil.create('div', 'info legend');
                div.style.background = 'rgba(255,255,255,0.8)';
                div.style.padding = '6px 8px';
                div.style.borderRadius = '4px';
                div.innerHTML =
                    '<div style="display:flex;align-items:center;margin-bottom:4px;"><span style="display:inline-block;width:12px;height:12px;background:#ef4444;border-radius:2px;margin-right:4px;"></span>Risque √©lev√© (‚â•75%)</div>' +
                    '<div style="display:flex;align-items:center;margin-bottom:4px;"><span style="display:inline-block;width:12px;height:12px;background:#f59e0b;border-radius:2px;margin-right:4px;"></span>Risque moyen (50‚Äì74%)</div>' +
                    '<div style="display:flex;align-items:center;"><span style="display:inline-block;width:12px;height:12px;background:#10b981;border-radius:2px;margin-right:4px;"></span>Risque faible (&lt;50%)</div>';
                return div;
            };
            legend.addTo(mapInst);
        }

        /**
         * Met √† jour le panneau d'analyse avanc√©e en fonction des projections calcul√©es.
         * Cette fonction identifie les stations pr√©sentant des √©coulements faibles r√©currents,
         * calcule la corr√©lation entre la variation annuelle et la proportion de modalit√©s
         * d√©grad√©es, puis affiche un graphique de dispersion et une synth√®se narrative.
         */
        function updateAnalysisPanel() {
            const analysisSection = document.getElementById('analysis-section');
            // L'analyse est affich√©e dans un modal ; cette fonction ne g√®re plus la visibilit√©.
            if (!analysisSection) return;
            // V√©rifier que les projections existent et contiennent des donn√©es ; sinon, afficher un message d'absence de donn√©es
            if (!projections || projections.length === 0) {
                // Si aucune projection n'est disponible, nettoyer les listes et charts et afficher des messages
                const listEl = document.getElementById('recurringLowFlowList');
                if (listEl) {
                    listEl.innerHTML = '<li>Aucune station r√©currente trouv√©e.</li>';
                }
                // Afficher un message de synth√®se vide
                const summaryEl = document.getElementById('analysisSummary');
                if (summaryEl) {
                    summaryEl.innerHTML = 'Aucune donn√©e d\'analyse disponible avec les param√®tres actuels.';
                }
                // Afficher une conclusion g√©n√©rique
                const conclusionEl = document.getElementById('analysisConclusion');
                if (conclusionEl) {
                    conclusionEl.innerHTML = 'Aucune conclusion g√©n√©r√©e car les donn√©es n√©cessaires sont manquantes. Veuillez s√©lectionner des stations ou charger des donn√©es pour voir l\'analyse.';
                }
                // La carte des zones sensibles a √©t√© retir√©e ; aucune carte n‚Äôest dessin√©e dans ce cas.
                // Dessiner des graphiques vides pour √©viter les erreurs
                renderCorrelationHeatmap([], []);
                renderRiskChart([]);
                renderClusterChart([]);
                return;
            }
            // Extraire les stations avec faibles √©coulements r√©currents (hors groupes)
            const recurring = projections
                .filter(p => p.isRecurring && !p.entity.startsWith('Groupe:'))
                .map(p => p.entity);
            const listEl = document.getElementById('recurringLowFlowList');
            if (listEl) {
                listEl.innerHTML = '';
                if (recurring.length) {
                    recurring.forEach(st => {
                        const li = document.createElement('li');
                        li.textContent = st;
                        listEl.appendChild(li);
                    });
                } else {
                    listEl.innerHTML = '<li>Aucune station r√©currente trouv√©e.</li>';
                }
            }
            // Pr√©parer les donn√©es de corr√©lation (uniquement pour les stations)
            const variations = [];
            const degraded = [];
            const scatterData = [];
            projections.forEach(p => {
                if (!p.entity.startsWith('Groupe:') && !isNaN(p.variation) && !isNaN(p.degradedPct)) {
                    variations.push(p.variation);
                    degraded.push(p.degradedPct);
                    scatterData.push({ value: [p.variation, p.degradedPct], name: p.entity });
                }
            });
            const corr = pearsonCorrelation(variations, degraded);
            // Graphique de dispersion Variation vs D√©grad√©
            const chartDom = document.getElementById('degradeCorrelationChart');
            if (chartDom) {
                if (charts.degradeCorr) charts.degradeCorr.dispose();
                charts.degradeCorr = echarts.init(chartDom, null, { renderer: 'canvas' });
                const axisColor = document.documentElement.classList.contains('dark') ? '#888888' : '#444444';
                charts.degradeCorr.setOption({
                    tooltip: {
                        trigger: 'item',
                        formatter: params => `${params.data.name}<br/>Variation: ${params.data.value[0].toFixed(2)}%<br/>D√©grad√©: ${params.data.value[1].toFixed(2)}%`
                    },
                    xAxis: {
                        type: 'value',
                        name: 'Variation (%)',
                        nameLocation: 'middle',
                        nameGap: 25,
                        axisLine: { lineStyle: { color: axisColor } },
                        axisLabel: { color: axisColor }
                    },
                    yAxis: {
                        type: 'value',
                        name: 'D√©grad√© (%)',
                        nameLocation: 'middle',
                        nameGap: 40,
                        axisLine: { lineStyle: { color: axisColor } },
                        axisLabel: { color: axisColor }
                    },
                    series: [{
                        type: 'scatter',
                        symbolSize: 12,
                        data: scatterData
                    }]
                });
            }
            // Synth√®se et analyses avanc√©es
            const avgVar = variations.length ? (variations.reduce((s, v) => s + v, 0) / variations.length).toFixed(2) : '0';
            const avgDeg = degraded.length ? (degraded.reduce((s, v) => s + v, 0) / degraded.length).toFixed(2) : '0';
            // G√©n√©rer la matrice de corr√©lation et l'afficher
            const corrRes = computeCorrelationMatrix(projections);
            // Mappage des noms de variables vers des libell√©s lisibles
            const displayNameMap = {
                variation: 'Variation',
                degradedPct: 'D√©grad√©',
                rain: 'Pluie',
                temp: 'Temp√©rature',
                prelev: 'Pr√©l√®vement',
                nappe: 'Niveau de nappe',
                debit: 'D√©bit',
                restrictions: 'Restrictions',
                risk: 'Risque projet√©',
                sensitivityScore: 'Sensibilit√©'
            };
            const varLabels = corrRes.variables.map(v => displayNameMap[v] || v);
            renderCorrelationHeatmap(corrRes.matrix, varLabels);
            // Calculer les indices de risque et le clustering
            const riskCluster = computeRiskAndClusters(projections);
            renderRiskChart(riskCluster.riskData);
            renderClusterChart(riskCluster.clusterData);
            // Identifier la corr√©lation la plus marqu√©e (hors diagonale)
            let maxCorr = { value: 0, i: 0, j: 1 };
            for (let i = 0; i < corrRes.matrix.length; i++) {
                for (let j = 0; j < i; j++) {
                    const val = corrRes.matrix[i][j];
                    if (Math.abs(val) > Math.abs(maxCorr.value)) {
                        maxCorr = { value: val, i: i, j: j };
                    }
                }
            }
            const maxPair = [varLabels[maxCorr.i], varLabels[maxCorr.j]];
            let corrDesc;
            if (maxCorr.value > 0.6) corrDesc = 'une corr√©lation fortement positive';
            else if (maxCorr.value > 0.3) corrDesc = 'une corr√©lation positive mod√©r√©e';
            else if (maxCorr.value < -0.6) corrDesc = 'une corr√©lation fortement n√©gative';
            else if (maxCorr.value < -0.3) corrDesc = 'une corr√©lation n√©gative mod√©r√©e';
            else corrDesc = 'une faible corr√©lation';
            // Compter les stations selon leur niveau de risque
            const riskCounts = { eleve: 0, moyen: 0, faible: 0 };
            riskCluster.riskData.forEach(o => {
                if (o.risk >= 75) riskCounts.eleve++;
                else if (o.risk >= 50) riskCounts.moyen++;
                else riskCounts.faible++;
            });

            // Calculer la corr√©lation entre les restrictions et l'indice de risque et identifier les stations √† risque sous restrictions
            let highRiskWithRestrictions = [];
            const restrVals = [];
            const riskVals = [];
            projections.forEach(p => {
                if (!p.entity.startsWith('Groupe:')) {
                    const restr = parseFloat(p.restrictions);
                    const riskVal = parseFloat(p.risk);
                    if (!isNaN(restr) && !isNaN(riskVal)) {
                        restrVals.push(restr);
                        riskVals.push(riskVal);
                        if (riskVal >= 75 && restr > 0) {
                            highRiskWithRestrictions.push(p.entity);
                        }
                    }
                }
            });
            const corrRestrRisk = restrVals.length > 1 ? pearsonCorrelation(restrVals, riskVals) : null;
            let corrRestrDesc = '';
            if (corrRestrRisk !== null) {
                const absVal = Math.abs(corrRestrRisk);
                const stren = absVal > 0.6 ? 'forte' : absVal > 0.3 ? 'mod√©r√©e' : 'faible';
                const sign = corrRestrRisk > 0 ? 'positive' : (corrRestrRisk < 0 ? 'n√©gative' : 'neutre');
                corrRestrDesc = `${stren} ${sign}`;
            }
            const summaryEl = document.getElementById('analysisSummary');
            if (summaryEl) {
                summaryEl.innerHTML = `
                Sur les stations s√©lectionn√©es, la variation moyenne annuelle est de <strong>${avgVar}%</strong> et la proportion moyenne de modalit√©s d√©grad√©es est de <strong>${avgDeg}%</strong>.<br/>
                Parmi ces stations, <strong>${recurring.length}</strong> pr√©sentent un √©coulement faible r√©current.<br/>
                La plus forte corr√©lation est observ√©e entre <strong>${maxPair[0]}</strong> et <strong>${maxPair[1]}</strong> avec un coefficient de Pearson de <strong>${maxCorr.value.toFixed(2)}</strong> (${corrDesc}).<br/>
                Les indices de risque identifient <strong>${riskCluster.highRiskStations.length}</strong> station(s) √† risque √©lev√© : ${riskCluster.highRiskStations.join(', ') || 'aucune'}.<br/>
                Parmi ces stations √† risque √©lev√©, <strong>${highRiskWithRestrictions.length}</strong> sont actuellement sous restriction (station(s) : ${highRiskWithRestrictions.join(', ') || 'aucune'}).<br/>
                ${corrRestrRisk !== null ? `La corr√©lation entre l'indice de risque et les restrictions est de <strong>${corrRestrRisk.toFixed(2)}</strong> (${corrRestrDesc}).<br/>` : `La corr√©lation entre l'indice de risque et les restrictions n'a pas pu √™tre calcul√©e (donn√©es insuffisantes).<br/>`}
                R√©partition du risque¬†: <strong>${riskCounts.eleve}</strong> √©lev√© (‚â•75&nbsp;%), <strong>${riskCounts.moyen}</strong> moyen (50‚Äì74&nbsp;%), <strong>${riskCounts.faible}</strong> faible (&lt;50&nbsp;%).<br/>
                Le clustering a form√© <strong>${riskCluster.clusterCounts.filter(c => c > 0).length}</strong> groupe(s) diff√©renci√©(s).
                `;
            }
            // La repr√©sentation spatiale a √©t√© d√©sactiv√©e √† la demande de l‚Äôutilisateur ; aucune carte n‚Äôest g√©n√©r√©e ici.

            // G√©n√©rer une conclusion synth√©tique et pertinente
            const conclusionEl = document.getElementById('analysisConclusion');
            if (conclusionEl) {
                // D√©terminer un message sur les stations r√©currentes
                const recurMsg = recurring.length > 0
                    ? `${recurring.length} station(s) √† faible √©coulement r√©currente(s)`
                    : `aucune station √† faible √©coulement r√©currente`;
                // D√©terminer un message sur le sens de la corr√©lation principale
                const corrDir = maxCorr.value > 0
                    ? 'positive'
                    : (maxCorr.value < 0 ? 'n√©gative' : 'neutre');
                const absCorr = Math.abs(maxCorr.value);
                const strength = absCorr > 0.6 ? 'forte' : absCorr > 0.3 ? 'mod√©r√©e' : 'faible';
                const corrMsg = `une corr√©lation ${strength} ${corrDir}`;
                // D√©terminer un message sur la corr√©lation avec les restrictions
                let restrMsg = '';
                if (corrRestrRisk !== null) {
                    restrMsg = ` Une corr√©lation ${corrRestrDesc} est observ√©e entre l‚Äôindice de risque et les restrictions (coef. ${corrRestrRisk.toFixed(2)}), `;
                } else {
                    restrMsg = ` Aucune corr√©lation notable n‚Äôa pu √™tre calcul√©e entre l‚Äôindice de risque et les restrictions (donn√©es insuffisantes), `;
                }
                // Construire le texte de conclusion
                conclusionEl.innerHTML =
                    `Les analyses mettent en √©vidence ${recurMsg} dans la s√©lection. ` +
                    `La variation et la proportion de modalit√©s d√©grad√©es pr√©sentent ${corrMsg} entre <strong>${maxPair[0]}</strong> et <strong>${maxPair[1]}</strong> (coef. ${maxCorr.value.toFixed(2)}). ` +
                    `L‚Äôindice de risque identifie ${riskCluster.highRiskStations.length} station(s) √† risque √©lev√©, dont ${highRiskWithRestrictions.length} font l‚Äôobjet de restrictions en cours. ` +
                    restrMsg +
                    `avec une distribution des niveaux de risque de ${riskCounts.eleve} √©lev√©, ${riskCounts.moyen} moyen et ${riskCounts.faible} faible. ` +
                    `Ces √©l√©ments offrent une vision globale, coh√©rente et facilement interpr√©table pour √©clairer la gestion des ressources en eau.`;
            }
        }

        function isRecurringLowFlow(station, records) {
            const yearlyData = {};
            records.forEach(r => {
                const year = new Date(r['Date de la campagne']).getFullYear();
                if (!yearlyData[year]) {
                    yearlyData[year] = { total: 0, low: 0 };
                }
                yearlyData[year].total++;
                if (trendConfig.degradedModalities.some(m => r['Modalit√© d\'√©coulement'].toLowerCase().includes(m))) {
                    yearlyData[year].low++;
                }
            });

            const yearsWithData = Object.keys(yearlyData).length;
            if (yearsWithData < 2) return false;

            const lowFlowYears = Object.values(yearlyData).filter(y => y.total > 0 && (y.low / y.total) * 100 >= trendConfig.lowFlowThreshold).length;
            return lowFlowYears >= Math.max(2, Math.floor(yearsWithData * 0.5));
        }

        function calculateTrend(records, currentYear, previousYear) {
            if (comparePreviousYear) {
                const currentRecords = records.filter(r => new Date(r['Date de la campagne']).getFullYear() === currentYear);
                const previousRecords = records.filter(r => new Date(r['Date de la campagne']).getFullYear() === previousYear);

                if (currentRecords.length === 0 || previousRecords.length === 0) {
                    return {
                        trend: '‚Üî',
                        trendClass: 'trend-stable',
                    };
                }

                const getAverageWeight = (recs) => {
                    const totalWeight = recs.reduce((sum, r) => sum + (trendConfig.modalityWeights[r['Modalit√© d\'√©coulement'].toLowerCase()] || 1.5), 0);
                    return recs.length > 0 ? totalWeight / recs.length : 0;
                };

                const currentWeight = getAverageWeight(currentRecords);
                const previousWeight = getAverageWeight(previousRecords);
                const difference = currentWeight - previousWeight;

                let trend, trendClass;
                if (difference > 0.5) {
                    trend = '‚Üò';
                    trendClass = 'trend-down';
                } else if (difference < -0.5) {
                    trend = '‚Üó';
                    trendClass = 'trend-up';
                } else {
                    trend = '‚Üî';
                    trendClass = 'trend-stable';
                }

                return { trend, trendClass };
            } else {
                const sortedRecords = records.sort((a, b) => new Date(b['Date de la campagne']) - new Date(a['Date de la campagne']));
                if (sortedRecords.length < 2) {
                    return {
                        trend: '‚Üî',
                        trendClass: 'trend-stable',
                    };
                }
                const currentWeight = trendConfig.modalityWeights[sortedRecords[0]['Modalit√© d\'√©coulement'].toLowerCase()] || 1.5;
                const previousWeight = trendConfig.modalityWeights[sortedRecords[1]['Modalit√© d\'√©coulement'].toLowerCase()] || 1.5;
                const difference = currentWeight - previousWeight;

                let trend, trendClass;
                if (difference > 0.5) {
                    trend = '‚Üò';
                    trendClass = 'trend-down';
                } else if (difference < -0.5) {
                    trend = '‚Üó';
                    trendClass = 'trend-up';
                } else {
                    trend = '‚Üî';
                    trendClass = 'trend-stable';
                }

                return { trend, trendClass };
            }
        }

        function getLastTwoObservations(records) {
            const sortedRecords = records.sort((a, b) => new Date(b['Date de la campagne']) - new Date(a['Date de la campagne']));
            const lastTwo = sortedRecords.slice(0, 2);
            return lastTwo.map(r => ({
                date: r['Date de la campagne'],
                modality: r['Modalit√© d\'√©coulement']
            }));
        }

        async function getWeatherForecast(lat, lon) {
            try {
                const cacheKey = `weather_${lat}_${lon}`;
                const cached = localStorage.getItem(cacheKey);
                const cachedTime = localStorage.getItem(`${cacheKey}_time`);
                if (cached && cachedTime && (Date.now() - cachedTime) < 3600000) {
                    return JSON.parse(cached);
                }

                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=temperature_2m_mean,precipitation_sum&timezone=Europe/Paris`);
                if (!response.ok) throw new Error(`Erreur API m√©t√©o : ${response.status}`);
                const weatherData = await response.json();

                const dailyPrecip = weatherData.daily.precipitation_sum;
                const dailyTemp = weatherData.daily.temperature_2m_mean;
                const dailyDates = weatherData.daily.time;

                const rain = dailyPrecip.reduce((sum, v) => sum + v, 0);
                const temp = dailyTemp.reduce((sum, v) => sum + v, 0) / dailyTemp.length;

                const forecast = { rain, temp, dailyPrecip, dailyTemp, dailyDates };
                localStorage.setItem(cacheKey, JSON.stringify(forecast));
                localStorage.setItem(`${cacheKey}_time`, Date.now());
                return forecast;
            } catch (error) {
                console.error(error);
                return { rain: 0, temp: 0, dailyPrecip: [], dailyTemp: [], dailyDates: [] };
            }
        }

        async function getHubEauDebit(station) {
            try {
                const codeStation = stationHubCodes[station];
                if (!codeStation) return { avgDebit: 'N/A' };

                const response = await fetchViaProxy(`https://hubeau.eaufrance.fr/api/v1/hydrometrie/observations_tr?code_entite=${codeStation}&grandeur_hydro=Q&size=30&sort=desc`);
                if (!response || !response.data) return { avgDebit: 'N/A' };

                const debits = response.data.map(d => d.resultat_obs).filter(v => v != null);
                const dates = response.data.map(d => d.date_obs);
                const avgDebit = debits.length > 0 ? debits.reduce((sum, v) => sum + v, 0) / debits.length / 1000 : 'N/A';

                return { avgDebit, debits, dates };
            } catch (error) {
                console.error(error);
                return { avgDebit: 'N/A' };
            }
        }

        function calculateProjection(lastWeight, rain, temp) {
            const risk = (lastWeight * 50) + ((10 - rain) * 5) + ((temp - 15) * 2);
            const clampedRisk = Math.max(0, Math.min(100, risk));

            let projectionText, projectionColor, recommendation;
            if (clampedRisk > 70) {
                projectionText = 'D√©gradation probable';
                projectionColor = '#ef4444';
                recommendation = 'Surveillance accrue recommand√©e.';
            } else if (clampedRisk > 30) {
                projectionText = 'Stable avec vigilance';
                projectionColor = '#f59e0b';
                recommendation = 'V√©rifier r√©guli√®rement.';
            } else {
                projectionText = 'Am√©lioration possible';
                projectionColor = '#22c55e';
                recommendation = 'Situation favorable.';
            }

            return { text: projectionText, color: projectionColor, risk: clampedRisk, recommendation };
        }

        function calculateSpearman(x, y) {
            const n = x.length;
            if (n === 0) return 0;

            const rankX = rankArray(x);
            const rankY = rankArray(y);

            let sumDiffSquared = 0;
            for (let i = 0; i < n; i++) {
                sumDiffSquared += Math.pow(rankX[i] - rankY[i], 2);
            }

            return 1 - (6 * sumDiffSquared) / (n * (n ** 2 - 1));
        }

        function rankArray(arr) {
            const sorted = [...arr].sort((a, b) => a - b);
            return arr.map(v => sorted.indexOf(v) + 1);
        }

        function calculateInterAnnualVariance(filteredData) {
            const yearlyWeights = {};
            filteredData.forEach(d => {
                const year = new Date(d['Date de la campagne']).getFullYear();
                const weight = trendConfig.modalityWeights[d['Modalit√© d\'√©coulement'].toLowerCase()] || 1.5;
                if (!yearlyWeights[year]) yearlyWeights[year] = [];
                yearlyWeights[year].push(weight);
            });

            const yearlyAverages = Object.values(yearlyWeights).map(weights => weights.reduce((sum, w) => sum + w, 0) / weights.length);
            if (yearlyAverages.length < 2) return 0;

            const mean = yearlyAverages.reduce((sum, avg) => sum + avg, 0) / yearlyAverages.length;
            const variance = yearlyAverages.reduce((sum, avg) => sum + Math.pow(avg - mean, 2), 0) / (yearlyAverages.length - 1);
            return variance.toFixed(2);
        }

        function calculateSensitivityScore(degradedPct, variation, isRecurring, spearman) {
            let score = (degradedPct * 0.4) + (variation * 0.3) + (isRecurring ? 30 : 0);
            if (spearman > 0.5) score += spearman * 30;
            return Math.max(0, Math.min(100, score));
        }

        async function updateTrendTable() {
            const tbody = document.querySelector('#trendTable tbody');
            tbody.innerHTML = '';

            const filteredData = getFilteredData();
            const stations = [...new Set(filteredData.map(d => d['Station d\'√©coulement']))];
            const groups = Object.keys(stationGroups).filter(g => Array.from(document.getElementById('stationSelect').selectedOptions).some(opt => opt.value === `group:${g}`));

            projections = [];
            let stationStats = {};

            for (const station of stations) {
                const records = filteredData.filter(d => d['Station d\'√©coulement'] === station);
                if (records.length < trendConfig.minObservations) continue;

                const lastTwoObs = getLastTwoObservations(records);
                const currentYear = new Date(lastTwoObs[0].date).getFullYear();
                const previousYear = comparePreviousYear ? currentYear - 1 : null;

                const { trend, trendClass } = calculateTrend(records, currentYear, previousYear);
                const isRecurring = isRecurringLowFlow(station, records);
                const coord = stationCoordinates[station];
                let weather = { rain: 0, temp: 0, dailyPrecip: [], dailyTemp: [], dailyDates: [] }, projection = { text: 'N/A', color: 'gray', risk: 0, recommendation: 'N/A' };

                if (includeWeather && coord) {
                    weather = await getWeatherForecast(coord.lat, coord.lon);
                    const lastWeight = trendConfig.modalityWeights[lastTwoObs[0].modality.toLowerCase()] || 1.5;
                    projection = calculateProjection(lastWeight, weather.rain, weather.temp);
                }

                const variation = calculateVariationScore(records, []);
                const degradedStats = calculateDegradedPercentage(records, []);
                const degradedPct = degradedStats.percentage;
                const spearman = calculateSpearman([variation], [degradedPct]); // Simplified for single station
                const sensitivityScore = calculateSensitivityScore(degradedPct, variation, isRecurring, spearman);

                projections.push({
                    entity: station,
                    lastModality: lastTwoObs[0].modality,
                    lastDate: lastTwoObs[0].date,
                    trend,
                    ...projection,
                    rain: weather.rain.toFixed(2),
                    temp: weather.temp.toFixed(2),
                    sensitivityScore,
                    isRecurring,
                    variation,
                    degradedPct,
                    weatherDetails: weather
                });

                const displayName = stationCodesOfb[station] || station;
                const row = tbody.insertRow();
                row.classList.toggle('low-flow-flag', isRecurring);
                row.innerHTML = `
                    <td class="p-3 border">${displayName}</td>
                    <td class="p-3 border">${records.length}</td>
                    <td class="p-3 border">${lastTwoObs.map(o => o.date).join(', ')}</td>
                    <td class="p-3 border">${lastTwoObs.map(o => o.modality).join(', ')}</td>
                    <td class="p-3 border"><span class="${trendClass}" data-tooltip="Tendance bas√©e sur les poids moyens">${trend}</span></td>
                    <td class="p-3 border" data-tooltip="Pr√©visions cumul√©es sur 7 jours">${includeWeather ? `Pluie: ${weather.rain.toFixed(2)}mm, Temp: ${weather.temp.toFixed(2)}¬∞C` : 'N/A'}</td>
                    <td class="p-3 border" style="color: ${projection.color};" data-tooltip="Projection bas√©e sur m√©t√©o et derni√®re modalit√©">${projection.text} (${projection.risk.toFixed(0)}%)</td>
                    <td class="p-3 border">${projection.recommendation}</td>
                `;
                row.dataset.weather = JSON.stringify(weather);
                row.addEventListener('click', (e) => {
                    const weatherData = JSON.parse(e.currentTarget.dataset.weather);
                    showForecastModal(weatherData);
                });
            }

            for (const group of groups) {
                const groupStations = stationGroups[group];
                const records = filteredData.filter(d => groupStations.includes(d['Station d\'√©coulement']));
                if (records.length < trendConfig.minObservations) continue;

                const lastTwoObs = getLastTwoObservations(records);
                const currentYear = new Date(lastTwoObs[0].date).getFullYear();
                const previousYear = comparePreviousYear ? currentYear - 1 : null;

                const { trend, trendClass } = calculateTrend(records, currentYear, previousYear);
                const isRecurring = groupStations.some(st => isRecurringLowFlow(st, filteredData.filter(d => d['Station d\'√©coulement'] === st)));
                let weather = { rain: 0, temp: 0, dailyPrecip: [], dailyTemp: [], dailyDates: [] }, projection = { text: 'N/A', color: 'gray', risk: 0, recommendation: 'N/A' };

                const groupCoords = groupStations.map(st => stationCoordinates[st]).filter(coord => coord);
                if (includeWeather && groupCoords.length > 0) {
                    const avgLat = groupCoords.reduce((sum, c) => sum + c.lat, 0) / groupCoords.length;
                    const avgLon = groupCoords.reduce((sum, c) => sum + c.lon, 0) / groupCoords.length;
                    weather = await getWeatherForecast(avgLat, avgLon);
                    const lastWeight = trendConfig.modalityWeights[lastTwoObs[0].modality.toLowerCase()] || 1.5;
                    projection = calculateProjection(lastWeight, weather.rain, weather.temp);
                }

                const variation = calculateVariationScore(records, []);
                const degradedStats = calculateDegradedPercentage(records, []);
                const degradedPct = degradedStats.percentage;
                const spearman = calculateSpearman([variation], [degradedPct]);
                const sensitivityScore = calculateSensitivityScore(degradedPct, variation, isRecurring, spearman);

                projections.push({
                    entity: `Groupe: ${group}`,
                    lastModality: lastTwoObs[0].modality,
                    lastDate: lastTwoObs[0].date,
                    trend,
                    ...projection,
                    rain: weather.rain.toFixed(2),
                    temp: weather.temp.toFixed(2),
                    sensitivityScore,
                    isRecurring,
                    variation,
                    degradedPct,
                    weatherDetails: weather
                });

                const row = tbody.insertRow();
                row.classList.toggle('low-flow-flag', isRecurring);
                row.innerHTML = `
                    <td class="p-3 border">Groupe: ${group}</td>
                    <td class="p-3 border">${records.length}</td>
                    <td class="p-3 border">${lastTwoObs.map(o => o.date).join(', ')}</td>
                    <td class="p-3 border">${lastTwoObs.map(o => o.modality).join(', ')}</td>
                    <td class="p-3 border"><span class="${trendClass}" data-tooltip="Tendance bas√©e sur les poids moyens">${trend}</span></td>
                    <td class="p-3 border" data-tooltip="Pr√©visions cumul√©es sur 7 jours">${includeWeather ? `Pluie: ${weather.rain.toFixed(2)}mm, Temp: ${weather.temp.toFixed(2)}¬∞C` : 'N/A'}</td>
                    <td class="p-3 border" style="color: ${projection.color};" data-tooltip="Projection bas√©e sur m√©t√©o et derni√®re modalit√©">${projection.text} (${projection.risk.toFixed(0)}%)</td>
                    <td class="p-3 border">${projection.recommendation}</td>
                `;
                row.dataset.weather = JSON.stringify(weather);
                row.addEventListener('click', (e) => {
                    const weatherData = JSON.parse(e.currentTarget.dataset.weather);
                    showForecastModal(weatherData);
                });
            }

            if (tbody.innerHTML === '') {
                tbody.innerHTML = `<tr><td colspan="8" class="p-3 text-center border">Aucune donn√©es disponible pour les filtres s√©lectionn√©s.</td></tr>`;
            }
        }

        function showForecastModal(weather) {
            document.getElementById('forecastModal').style.display = 'block';
            const chartDom = document.getElementById('forecastChart');
            if (charts.forecast) charts.forecast.dispose();
            charts.forecast = echarts.init(chartDom);

            const dates = weather.dailyDates || Array(7).fill('').map((_, i) => `J${i+1}`);
            const precip = weather.dailyPrecip || Array(7).fill(0);
            const temp = weather.dailyTemp || Array(7).fill(0);

            charts.forecast.setOption({
                title: { text: 'Pr√©visions Journali√®res', left: 'center' },
                tooltip: { trigger: 'axis' },
                legend: { top: 30 },
                xAxis: { type: 'category', data: dates },
                yAxis: [
                    { type: 'value', name: 'Pluie (mm)', axisLabel: { formatter: '{value} mm' } },
                    { type: 'value', name: 'Temp (¬∞C)', position: 'right', axisLabel: { formatter: '{value} ¬∞C' } }
                ],
                series: [
                    { name: 'Pluie', type: 'bar', data: precip, itemStyle: { color: '#00a3a6' } },
                    { name: 'Temp', type: 'line', yAxisIndex: 1, data: temp, itemStyle: { color: '#ef4444' } }
                ]
            });
        }

        function updateSummaryStats(filteredData) {
            const summaryStats = document.getElementById('summaryStats');
            summaryStats.innerHTML = '';

            const totalObs = filteredData.length;
            const activeStations = [...new Set(filteredData.map(d => d['Station d\'√©coulement']))].length;

            const createStatCard = (title, value, trend = '', tooltip = '') => `
                <div class="stat-card bg-white dark:bg-gray-800 p-6 rounded-2xl shadow-xl border-l-4 border-[#00a3a6]" data-tooltip="${tooltip}">
                    <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-2">${title}</h3>
                    <p class="text-3xl font-bold text-[#005566] dark:text-[#00a3a6]">${value} <span class="${trend}"></span></p>
                </div>
            `;

            summaryStats.innerHTML += createStatCard('Total Observations', totalObs, '', 'Nombre total d\'observations filtr√©es');
            summaryStats.innerHTML += createStatCard('Stations Actives', activeStations, '', 'Nombre de stations uniques avec donn√©es');

            allModalities.forEach(modality => {
                const count = filteredData.filter(d => d['Modalit√© d\'√©coulement'] === modality).length;
                const percent = totalObs > 0 ? Math.round((count / totalObs) * 100) : 0;
                summaryStats.innerHTML += createStatCard(`% ${modality}`, `${percent}%`, '', `Pourcentage de "${modality}" (${count} obs)`);
            });
        }

        function updateCharts(filteredData) {
            updateStationChart(filteredData);
            updateModalityChart(filteredData);
            updateYearlyTrendChart(filteredData);
            updateStationTrendChart(filteredData);
        }

        function updateStationChart(filteredData) {
            const chartDom = document.getElementById('stationChart');
            if (charts.station) charts.station.dispose();
            charts.station = echarts.init(chartDom, null, { renderer: 'canvas' });
            const modalityColors = generateDynamicColors(allModalities);
            // Utiliser des couleurs unies pour chaque modalit√© (pas de d√©grad√©)

            const stations = [...new Set(filteredData.map(d => d['Station d\'√©coulement']))];
            const series = allModalities.map(modality => {
                return {
                    name: modality,
                    type: 'bar',
                    stack: 'total',
                    barGap: '20%',
                    // Couleur unie et coins subtilement arrondis
                    itemStyle: {
                        color: modalityColors[modality.toLowerCase()],
                        borderRadius: [2, 2, 0, 0]
                    },
                    label: {
                        show: true,
                        position: 'inside',
                        fontSize: 12,
                        color: document.documentElement.classList.contains('dark') ? '#fff' : '#fff',
                        formatter: params => params.value > 0 ? `${params.value}%` : ''
                    },
                    data: stations.map(station => {
                        const stationData = filteredData.filter(d => d['Station d\'√©coulement'] === station);
                        const count = stationData.filter(d => d['Modalit√© d\'√©coulement'] === modality).length;
                        const percent = stationData.length > 0 ? Math.round((count / stationData.length) * 100) : 0;
                        return { value: percent };
                    })
                };
            });

            // Define axis and grid colours based on theme
            const axisColor = document.documentElement.classList.contains('dark') ? '#888888' : '#444444';
            const splitLineColor = document.documentElement.classList.contains('dark') ? '#444444' : '#e0e0e0';

            charts.station.setOption({
                animationDuration: 700,
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: document.documentElement.classList.contains('dark') ? '#1f2937' : '#ffffff',
                    borderColor: document.documentElement.classList.contains('dark') ? '#374151' : '#d1d5db',
                    textStyle: { color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937' },
                    axisPointer: {
                        type: 'shadow'
                    },
                    formatter: params => {
                        return params.map(p => p.value > 0 ? `<strong>${p.seriesName}</strong>: ${p.value}%` : '').filter(Boolean).join('<br/>');
                    }
                },
                legend: {
                    top: '0',
                    orient: 'horizontal',
                    itemWidth: 12,
                    itemHeight: 12,
                    textStyle: { color: axisColor },
                    data: allModalities.map(modality => ({
                        name: modality,
                        icon: 'circle',
                        itemStyle: { color: modalityColors[modality.toLowerCase()] }
                    }))
                },
                grid: { left: '5%', right: '3%', bottom: '18%', top: '20%', containLabel: true },
                xAxis: {
                    type: 'category',
                    // Afficher les codes station OFB (d√©partement + index) au lieu des noms
                    data: stations.map(st => stationCodesOfb[st] || st),
                    axisLine: { lineStyle: { color: axisColor } },
                    axisTick: { show: false },
                    axisLabel: { rotate: 45, color: axisColor }
                },
                yAxis: {
                    type: 'value',
                    max: 100,
                    axisLine: { lineStyle: { color: axisColor } },
                    axisTick: { show: false },
                    axisLabel: { formatter: '{value}%', color: axisColor },
                    splitLine: { lineStyle: { color: splitLineColor, type: 'dashed' } }
                },
                series: series,
                toolbox: {
                    feature: {
                        saveAsImage: {},
                        dataZoom: {}
                    }
                }
            });

            // Redimensionner le graphique pour occuper toute la largeur disponible apr√®s un rendu initial
            // Certains navigateurs calculent la largeur de l'√©l√©ment apr√®s la construction, ce qui peut entra√Æner un rendu miniature.
            setTimeout(() => {
                if (charts.station && typeof charts.station.resize === 'function') {
                    charts.station.resize();
                }
            }, 50);
        }

        function updateModalityChart(filteredData) {
            const chartDom = document.getElementById('modalityChart');
            if (charts.modality) charts.modality.dispose();
            charts.modality = echarts.init(chartDom, null, { renderer: 'canvas' });
            const modalityColors = generateDynamicColors(allModalities);

            // Compute counts for each modality
            const modalityCounts = {};
            allModalities.forEach(modality => {
                modalityCounts[modality] = filteredData.filter(d => d['Modalit√© d\'√©coulement'] === modality).length;
            });
            const total = filteredData.length;
            if (total === 0) return;

            // Pr√©parer les donn√©es de la s√©rie pour un diagramme en anneau sans d√©grad√©
            const seriesData = allModalities.map(modality => {
                const value = modalityCounts[modality];
                if (value <= 0) return null;
                const colour = modalityColors[modality.toLowerCase()];
                return {
                    value: value,
                    name: modality,
                    itemStyle: { color: colour }
                };
            }).filter(Boolean);

            const axisColor = document.documentElement.classList.contains('dark') ? '#888888' : '#444444';

            charts.modality.setOption({
                animationDuration: 700,
                tooltip: {
                    trigger: 'item',
                    backgroundColor: document.documentElement.classList.contains('dark') ? '#1f2937' : '#ffffff',
                    borderColor: document.documentElement.classList.contains('dark') ? '#374151' : '#d1d5db',
                    textStyle: { color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937' },
                    formatter: params => params.value > 0 ? `<strong>${params.name}</strong><br/>${params.value} observations (${Math.round(params.percent)}%)` : ''
                },
                legend: {
                    orient: 'horizontal',
                    top: '0',
                    textStyle: { color: axisColor },
                    itemWidth: 12,
                    itemHeight: 12,
                    data: seriesData.map(d => d.name)
                },
                series: [{
                    name: 'Modalit√©s',
                    type: 'pie',
                    radius: ['40%', '65%'],
                    center: ['50%', '60%'],
                    data: seriesData,
                    avoidLabelOverlap: false,
                    itemStyle: {
                        borderRadius: 5,
                        borderColor: '#fff',
                        borderWidth: 2
                    },
                    label: {
                        show: false,
                        position: 'center'
                    },
                    emphasis: {
                        label: {
                            show: true,
                            fontSize: 16,
                            fontWeight: 'bold'
                        }
                    },
                    labelLine: {
                        show: false
                    }
                }],
                toolbox: {
                    feature: {
                        saveAsImage: {},
                        dataZoom: {}
                    }
                }
            });
        }

        function updateYearlyTrendChart(filteredData) {
            const chartDom = document.getElementById('yearlyTrendChart');
            if (charts.yearlyTrend) charts.yearlyTrend.dispose();
            charts.yearlyTrend = echarts.init(chartDom, null, { renderer: 'canvas' });
            const modalityColors = generateDynamicColors(allModalities);

            const yearlyData = {};
            filteredData.forEach(d => {
                const year = new Date(d['Date de la campagne']).getFullYear();
                const modality = d['Modalit√© d\'√©coulement'];
                if (!yearlyData[year]) {
                    yearlyData[year] = { Total: 0, modalities: {} };
                    allModalities.forEach(modality => yearlyData[year].modalities[modality] = 0);
                }
                yearlyData[year].Total++;
                yearlyData[year].modalities[modality]++;
            });

            const sortedYears = Object.keys(yearlyData).sort();
            if (sortedYears.length === 0) return;

            // Build series with gradient areas for each modality
            const series = allModalities.map(modality => {
                const base = modalityColors[modality.toLowerCase()];
                const gradient = new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                    { offset: 0, color: lightenColor(base, 45) },
                    { offset: 1, color: base }
                ]);
                return {
                    name: modality,
                    type: 'line',
                    stack: 'total',
                    smooth: true,
                    symbol: 'circle',
                    symbolSize: 5,
                    lineStyle: {
                        width: 3,
                        color: base
                    },
                    itemStyle: {
                        color: base
                    },
                    areaStyle: {
                        color: gradient,
                        opacity: 0.4
                    },
                    label: {
                        show: true,
                        position: 'top',
                        fontSize: 12,
                        color: document.documentElement.classList.contains('dark') ? '#e5e7eb' : '#374151',
                        formatter: params => params.value > 0 ? `${params.value}%` : ''
                    },
                    data: sortedYears.map(year => {
                        const percent = yearlyData[year].Total > 0 ? Math.round((yearlyData[year].modalities[modality] / yearlyData[year].Total) * 100) : 0;
                        return { value: percent };
                    })
                };
            });

            // Axis and grid styling based on theme
            const axisColor = document.documentElement.classList.contains('dark') ? '#888888' : '#444444';
            const splitLineColor = document.documentElement.classList.contains('dark') ? '#444444' : '#e0e0e0';

            charts.yearlyTrend.setOption({
                animationDuration: 700,
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: document.documentElement.classList.contains('dark') ? '#1f2937' : '#ffffff',
                    borderColor: document.documentElement.classList.contains('dark') ? '#374151' : '#d1d5db',
                    textStyle: { color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937' },
                    formatter: params => {
                        const year = params[0].axisValue;
                        let result = `<strong>${year}</strong><br/>`;
                        params.forEach(p => {
                            if (p.value > 0) result += `${p.seriesName}: ${p.value}%<br/>`;
                        });
                        return result;
                    }
                },
                legend: {
                    top: '0',
                    orient: 'horizontal',
                    itemWidth: 12,
                    itemHeight: 12,
                    textStyle: { color: axisColor },
                    data: allModalities.map(modality => ({
                        name: modality,
                        icon: 'circle',
                        itemStyle: { color: modalityColors[modality.toLowerCase()] }
                    }))
                },
                grid: { left: '5%', right: '4%', bottom: '10%', containLabel: true, top: '20%' },
                xAxis: {
                    type: 'category',
                    data: sortedYears,
                    axisLine: { lineStyle: { color: axisColor } },
                    axisTick: { show: false },
                    axisLabel: { color: axisColor }
                },
                yAxis: {
                    type: 'value',
                    max: 100,
                    axisLine: { lineStyle: { color: axisColor } },
                    axisTick: { show: false },
                    axisLabel: { formatter: '{value}%', color: axisColor },
                    splitLine: { lineStyle: { color: splitLineColor, type: 'dashed' } }
                },
                series: series,
                toolbox: {
                    feature: {
                        saveAsImage: {},
                        dataZoom: {}
                    }
                }
            });
        }

        function updateStationTrendChart(filteredData) {
            const chartDom = document.getElementById('stationTrendChart');
            if (charts.stationTrend) charts.stationTrend.dispose();
            charts.stationTrend = echarts.init(chartDom, null, { renderer: 'canvas' });
            const modalityColors = generateDynamicColors(allModalities);

            const selections = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);
            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => parseInt(opt.value));
            const modality = document.getElementById('modalitySelect').value;

            let stations = [];
            selections.forEach(selection => {
                if (selection.startsWith('group:')) {
                    const groupName = selection.replace('group:', '');
                    if (stationGroups[groupName]) stations.push(...stationGroups[groupName]);
                } else {
                    stations.push(selection);
                }
            });

            let filtered = [...filteredData];
            if (stations.length > 0 && stations[0] !== '') {
                filtered = filtered.filter(d => stations.includes(d['Station d\'√©coulement']));
            }
            if (years.length > 0 && years[0] !== NaN) {
                filtered = filtered.filter(d => years.includes(new Date(d['Date de la campagne']).getFullYear()));
            }

            const yearlyData = {};
            filtered.forEach(d => {
                const year = new Date(d['Date de la campagne']).getFullYear();
                const station = d['Station d\'√©coulement'];
                const modality = d['Modalit√© d\'√©coulement'];
                if (!yearlyData[station]) yearlyData[station] = {};
                if (!yearlyData[station][year]) {
                    yearlyData[station][year] = { Total: 0, modalities: {} };
                    allModalities.forEach(modality => yearlyData[station][year].modalities[modality] = 0);
                }
                yearlyData[station][year].Total++;
                yearlyData[station][year].modalities[modality]++;
            });

            const groupData = {};
            Object.keys(stationGroups).forEach(group => {
                groupData[group] = {};
                const groupStations = stationGroups[group];
                filtered.forEach(d => {
                    if (groupStations.includes(d['Station d\'√©coulement'])) {
                        const year = new Date(d['Date de la campagne']).getFullYear();
                        const modality = d['Modalit√© d\'√©coulement'];
                        if (!groupData[group][year]) {
                            groupData[group][year] = { Total: 0, modalities: {} };
                            allModalities.forEach(modality => groupData[group][year].modalities[modality] = 0);
                        }
                        groupData[group][year].Total++;
                        groupData[group][year].modalities[modality]++;
                    }
                });
            });

            const sortedYears = [...new Set([
                ...Object.values(yearlyData).flatMap(s => Object.keys(s)),
                ...Object.values(groupData).flatMap(g => Object.keys(g))
            ])].sort();

            if (sortedYears.length === 0) return;

            const series = [];
            if (modality && modality !== '') {
                stations.forEach((station, index) => {
                    series.push({
                        // Utiliser le code station OFB comme libell√©
                        name: stationCodesOfb[station] || station,
                        type: 'line',
                        smooth: true,
                        data: sortedYears.map(year => {
                            const percent = yearlyData[station]?.[year]?.Total > 0 ? Math.round((yearlyData[station][year].modalities[modality] / yearlyData[station][year].Total) * 100) : 0;
                            return { value: percent, itemStyle: { color: modalityColors[modality.toLowerCase()] } };
                        }),
                        label: {
                            show: true,
                            position: 'top',
                            formatter: params => params.value > 0 ? `${params.value}%` : ''
                        }
                    });
                });
                Object.keys(groupData).forEach((group, index) => {
                    if (selections.includes(`group:${group}`)) {
                        series.push({
                            name: `Groupe: ${group}`,
                            type: 'line',
                            smooth: true,
                            lineStyle: { width: 4, type: 'dashed' },
                            data: sortedYears.map(year => {
                                const percent = groupData[group][year]?.Total > 0 ? Math.round((groupData[group][year].modalities[modality] / groupData[group][year].Total) * 100) : 0;
                                return { value: percent, itemStyle: { color: `hsl(${index * 60 + 30}, 70%, 50%)` } };
                            }),
                            label: {
                                show: true,
                                position: 'top',
                                formatter: params => params.value > 0 ? `${params.value}%` : ''
                            }
                        });
                    }
                });
            } else {
                allModalities.forEach((modality, index) => {
                    series.push({
                        name: modality,
                        type: 'bar',
                        stack: 'total',
                        data: sortedYears.map(year => {
                            let total = 0;
                            let count = 0;
                            stations.forEach(station => {
                                const stats = yearlyData[station]?.[year];
                                if (stats) {
                                    total += (stats.modalities[modality] / stats.Total) * 100;
                                    count++;
                                }
                            });
                            Object.keys(groupData).forEach(group => {
                                if (selections.includes(`group:${group}`)) {
                                    const stats = groupData[group][year];
                                    if (stats) {
                                        total += (stats.modalities[modality] / stats.Total) * 100;
                                        count++;
                                    }
                                }
                            });
                            const percent = count > 0 ? Math.round(total / count) : 0;
                            return { value: percent, itemStyle: { color: modalityColors[modality.toLowerCase()] } };
                        }),
                        label: {
                            show: true,
                            position: 'inside',
                            formatter: params => params.value > 0 ? `${params.value}%` : ''
                        },
                        itemStyle: { color: modalityColors[modality.toLowerCase()] }
                    });
                });
            }

            // Create gradient colours for bar series when no modality is selected
            const gradientColors = {};
            Object.keys(modalityColors).forEach(mod => {
                const base = modalityColors[mod];
                gradientColors[mod] = new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                    { offset: 0, color: lightenColor(base, 35) },
                    { offset: 1, color: base }
                ]);
            });

            // Apply gradient to bar series and style lines
            series.forEach(s => {
                if (s.type === 'bar') {
                    const modKey = s.name.toLowerCase();
                    s.itemStyle = {
                        color: gradientColors[modKey],
                        borderRadius: [4, 4, 0, 0]
                    };
                    s.barGap = '20%';
                } else if (s.type === 'line') {
                    // For line series, ensure consistent styling
                    const colourKey = s.name.toLowerCase().replace(/^groupe: /, '');
                    const base = modalityColors[colourKey] || s.lineStyle?.color || s.itemStyle?.color;
                    s.lineStyle = { width: s.lineStyle?.width || 3, type: s.lineStyle?.type || 'solid', color: base };
                    s.itemStyle = { color: base };
                    s.symbol = 'circle';
                    s.symbolSize = 5;
                    s.areaStyle = undefined;
                }
                s.label = {
                    show: true,
                    position: s.type === 'bar' ? 'inside' : 'top',
                    fontSize: 12,
                    color: document.documentElement.classList.contains('dark') ? '#e5e7eb' : '#374151',
                    formatter: params => params.value > 0 ? `${params.value}%` : ''
                };
            });

            // Determine axis and split line colours based on theme
            const axisColor = document.documentElement.classList.contains('dark') ? '#888888' : '#444444';
            const splitLineColor = document.documentElement.classList.contains('dark') ? '#444444' : '#e0e0e0';

            charts.stationTrend.setOption({
                animationDuration: 700,
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: document.documentElement.classList.contains('dark') ? '#1f2937' : '#ffffff',
                    borderColor: document.documentElement.classList.contains('dark') ? '#374151' : '#d1d5db',
                    textStyle: { color: document.documentElement.classList.contains('dark') ? '#f3f4f6' : '#1f2937' },
                    formatter: params => {
                        const year = params[0].axisValue;
                        let result = `<strong>${year}</strong><br/>`;
                        params.forEach(p => {
                            if (p.value > 0) result += `${p.seriesName}: ${p.value}%<br/>`;
                        });
                        return result;
                    }
                },
                legend: {
                    top: '0',
                    orient: 'horizontal',
                    itemWidth: 12,
                    itemHeight: 12,
                    textStyle: { color: axisColor },
                    data: series.map(s => s.name)
                },
                grid: { left: '5%', right: '4%', bottom: '10%', containLabel: true, top: '20%' },
                xAxis: {
                    type: 'category',
                    data: sortedYears,
                    axisLine: { lineStyle: { color: axisColor } },
                    axisTick: { show: false },
                    axisLabel: { color: axisColor }
                },
                yAxis: {
                    type: 'value',
                    max: 100,
                    axisLine: { lineStyle: { color: axisColor } },
                    axisTick: { show: false },
                    axisLabel: { formatter: '{value}%', color: axisColor },
                    splitLine: { lineStyle: { color: splitLineColor, type: 'dashed' } }
                },
                series: series,
                toolbox: {
                    feature: {
                        saveAsImage: {},
                        dataZoom: {}
                    }
                }
            });
        }

        function calculateVariationScore(records, years) {
            const yearlyData = {};
            records.forEach(r => {
                const year = new Date(r['Date de la campagne']).getFullYear();
                if (years.length > 0 && !years.includes(year)) return;
                if (!yearlyData[year]) {
                    yearlyData[year] = { total: 0, modalities: {} };
                    allModalities.forEach(modality => yearlyData[year].modalities[modality] = 0);
                }
                yearlyData[year].total++;
                yearlyData[year].modalities[r['Modalit√© d\'√©coulement']]++;
            });

            const sortedYears = Object.keys(yearlyData).sort().map(Number);
            if (sortedYears.length < 2) return 0;

            let totalVariation = 0;
            for (let i = 1; i < sortedYears.length; i++) {
                const prevYear = sortedYears[i - 1];
                const currYear = sortedYears[i];
                let variation = 0;
                allModalities.forEach(modality => {
                    const prevPercent = yearlyData[prevYear].total > 0 ? (yearlyData[prevYear].modalities[modality] / yearlyData[prevYear].total) * 100 : 0;
                    const currPercent = yearlyData[currYear].total > 0 ? (yearlyData[currYear].modalities[modality] / yearlyData[currYear].total) * 100 : 0;
                    variation += Math.abs(currPercent - prevPercent);
                });
                totalVariation += variation / allModalities.length;
            }

            return totalVariation / (sortedYears.length - 1);
        }

        function calculateDegradedPercentage(records, years) {
            const filteredRecords = records.filter(r => {
                const year = new Date(r['Date de la campagne']).getFullYear();
                return years.length === 0 || years.includes(year);
            });

            const total = filteredRecords.length;
            if (total === 0) return { percentage: 0, modalities: [] };

            const degradedCount = filteredRecords.filter(r =>
                trendConfig.degradedModalities.some(m => r['Modalit√© d\'√©coulement'].toLowerCase().includes(m))
            ).length;

            const modalities = {};
            allModalities.forEach(modality => {
                modalities[modality] = filteredRecords.filter(r => r['Modalit√© d\'√©coulement'] === modality).length;
            });

            return {
                percentage: total > 0 ? Math.round((degradedCount / total) * 100) : 0,
                modalities: Object.entries(modalities)
                    .filter(([_, count]) => count > 0)
                    .map(([modality, count]) => `${modality} (${count})`)
                    .join(', ')
            };
        }

        function updateVariationTable(filteredData) {
            const tbody = document.querySelector('#variationTable tbody');
            tbody.innerHTML = '';

            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => parseInt(opt.value));
            const stationStats = {};
            filteredData.forEach(d => {
                const station = d['Station d\'√©coulement'];
                if (!stationStats[station]) {
                    stationStats[station] = [];
                }
                stationStats[station].push(d);
            });

            const groupStats = {};
            Object.keys(stationGroups).forEach(group => {
                groupStats[group] = filteredData.filter(d => stationGroups[group].includes(d['Station d\'√©coulement']));
            });

            const variations = [];
            Object.keys(stationStats).forEach(station => {
                const variation = calculateVariationScore(stationStats[station], years);
                const modalities = [...new Set(stationStats[station].map(d => d['Modalit√© d\'√©coulement']))].join(', ');
                variations.push({ name: station, variation, modalities });
            });

            Object.keys(groupStats).forEach(group => {
                const variation = calculateVariationScore(groupStats[group], years);
                const modalities = [...new Set(groupStats[group].map(d => d['Modalit√© d\'√©coulement']))].join(', ');
                variations.push({ name: `Groupe: ${group}`, variation, modalities });
            });

            variations.sort((a, b) => b.variation - a.variation).slice(0, 10).forEach(item => {
                const row = tbody.insertRow();
                // Utiliser des conteneurs avec retour √† la ligne pour √©viter que les listes longues ne cassent la mise en page
                const displayName = item.name.startsWith('Groupe') ? item.name : (stationCodesOfb[item.name] || item.name);
                row.innerHTML = `
                    <td class="p-3 border">${displayName}</td>
                    <td class="p-3 border">${item.variation.toFixed(2)}%</td>
                    <td class="p-3 border" style="white-space: normal; word-break: break-word;">${item.modalities}</td>
                `;
            });

            if (tbody.innerHTML === '') {
                tbody.innerHTML = `<tr><td colspan="3" class="p-3 text-center border">Aucune donn√©es disponible.</td></tr>`;
            }
        }

        function updateDegradedTable(filteredData) {
            const tbody = document.querySelector('#degradedTable tbody');
            tbody.innerHTML = '';

            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => parseInt(opt.value));
            const stationStats = {};
            filteredData.forEach(d => {
                const station = d['Station d\'√©coulement'];
                if (!stationStats[station]) {
                    stationStats[station] = [];
                }
                stationStats[station].push(d);
            });

            const groupStats = {};
            Object.keys(stationGroups).forEach(group => {
                groupStats[group] = filteredData.filter(d => stationGroups[group].includes(d['Station d\'√©coulement']));
            });

            const degraded = [];
            Object.keys(stationStats).forEach(station => {
                const stats = calculateDegradedPercentage(stationStats[station], years);
                if (stats.percentage > 0) {
                    degraded.push({ name: station, percentage: stats.percentage, modalities: stats.modalities });
                }
            });

            Object.keys(groupStats).forEach(group => {
                const stats = calculateDegradedPercentage(groupStats[group], years);
                if (stats.percentage > 0) {
                    degraded.push({ name: `Groupe: ${group}`, percentage: stats.percentage, modalities: stats.modalities });
                }
            });

            degraded.sort((a, b) => b.percentage - a.percentage).slice(0, 10).forEach(item => {
                const row = tbody.insertRow();
                const displayName = item.name.startsWith('Groupe') ? item.name : (stationCodesOfb[item.name] || item.name);
                row.innerHTML = `
                    <td class="p-3 border">${displayName}</td>
                    <td class="p-3 border">${item.percentage}%</td>
                    <td class="p-3 border" style="white-space: normal; word-break: break-word;">${item.modalities}</td>
                `;
            });

            if (tbody.innerHTML === '') {
                tbody.innerHTML = `<tr><td colspan="3" class="p-3 text-center border">Aucune donn√©es disponible.</td></tr>`;
            }
        }

        async function captureElement(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return '';
            await new Promise(resolve => setTimeout(resolve, 500));
            const canvas = await html2canvas(element, { scale: 2, useCORS: true });
            return canvas.toDataURL('image/png');
        }

        async function exportToWordRisk() {
            const filteredData = getFilteredData();
            if (filteredData.length === 0) {
                showStatus('Aucune donn√©e disponible pour g√©n√©rer le rapport.', 'error');
                return;
            }

            const selections = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);
            const modalities = Array.from(document.getElementById('modalitySelect').selectedOptions).map(opt => opt.value);
            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => opt.value);

            const variance = calculateInterAnnualVariance(filteredData);
            const variationData = [];
            const variationRows = document.querySelectorAll('#variationTable tbody tr');
            variationRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                variationData.push(parseFloat(cells[1].textContent) || 0);
            });

            const degradedData = [];
            const degradedRows = document.querySelectorAll('#degradedTable tbody tr');
            degradedRows.forEach(row => {
                const cells = row.querySelectorAll('td');
                degradedData.push(parseFloat(cells[1].textContent) || 0);
            });

            const spearman = calculateSpearman(variationData, degradedData);

            const stationChartImage = await captureElement('stationChart');
            const modalityChartImage = await captureElement('modalityChart');
            const yearlyTrendChartImage = await captureElement('yearlyTrendChart');
            const stationTrendChartImage = await captureElement('stationTrendChart');

            // Pr√©parer l'analyse spatio‚Äëtemporelle pour le rapport. Calcul des risques et corr√©lation avec les restrictions.
            // On utilise les projections d√©j√† calcul√©es pour √©viter un recalcul lourd.
            const riskCluster = computeRiskAndClusters(projections || []);
            const riskCountsRpt = { eleve: 0, moyen: 0, faible: 0 };
            riskCluster.riskData.forEach(o => {
                if (o.risk >= 75) riskCountsRpt.eleve++;
                else if (o.risk >= 50) riskCountsRpt.moyen++;
                else riskCountsRpt.faible++;
            });
            let highRiskWithRestrictionsRpt = [];
            const restrValsRpt = [];
            const riskValsRpt = [];
            (projections || []).forEach(p => {
                if (p && !p.entity.startsWith('Groupe:')) {
                    const restr = parseFloat(p.restrictions);
                    const rsk = parseFloat(p.risk);
                    if (!isNaN(restr) && !isNaN(rsk)) {
                        restrValsRpt.push(restr);
                        riskValsRpt.push(rsk);
                        if (rsk >= 75 && restr > 0) highRiskWithRestrictionsRpt.push(p.entity);
                    }
                }
            });
            const corrRestrRiskRpt = restrValsRpt.length > 1 ? pearsonCorrelation(restrValsRpt, riskValsRpt) : null;
            let corrRestrDescRpt = '';
            if (corrRestrRiskRpt !== null) {
                const absVal = Math.abs(corrRestrRiskRpt);
                const stren = absVal > 0.6 ? 'forte' : absVal > 0.3 ? 'mod√©r√©e' : 'faible';
                const sign = corrRestrRiskRpt > 0 ? 'positive' : (corrRestrRiskRpt < 0 ? 'n√©gative' : 'neutre');
                corrRestrDescRpt = `${stren} ${sign}`;
            }

            let htmlContent = `
                <html>
                <head>
                    <title>Rapport d'Analyse D√©taill√©e des √âcoulements</title>
                    <style>
                        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; margin: 20px; }
                        h1 { color: #005566; text-align: center; }
                        h2 { color: #00a3a6; border-bottom: 2px solid #00a3a6; padding-bottom: 10px; }
                        h3 { color: #005566; }
                        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
                        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                        th { background-color: #005566; color: white; }
                        img { max-width: 100%; height: auto; margin-bottom: 20px; display: block; }
                        .page-break { page-break-before: always; }
                        ul { list-style-type: disc; padding-left: 20px; }
                        .toc { margin-bottom: 40px; }
                        .toc a { color: #00a3a6; text-decoration: none; }
                        .toc a:hover { text-decoration: underline; }
                    </style>
                </head>
                <body>
                    <h1>Rapport d'Analyse D√©taill√©e des √âcoulements</h1>
                    <p style="text-align: center; font-style: italic;">Office Fran√ßais de la Biodiversit√© - Date : ${new Date().toLocaleDateString('fr-FR')}</p>
                    <p style="text-align: center;">Version 1.0 - G√©n√©r√© par l'outil d'analyse avanc√©e</p>

                    <div class="page-break"></div>

                    <h2>Table des Mati√®res</h2>
                    <div class="toc">
                        <ul>
                            <li><a href="#introduction">Introduction</a></li>
                            <li><a href="#resume-statistique">R√©sum√© Statistique</a></li>
                            <li><a href="#analyse-tendances">Analyse des Tendances</a></li>
                            <li><a href="#classements">Classements</a></li>
                            <li><a href="#visualisations">Visualisations</a></li>
                            <li><a href="#analyse-spatio-temporelle">Analyse Spatio‚Äëtemporelle</a></li>
                        </ul>
                    </div>

                    <div class="page-break"></div>

                    <h2 id="introduction">Introduction</h2>
                    <p>Ce rapport pr√©sente une analyse d√©taill√©e des donn√©es d‚Äô√©coulement charg√©es, incluant ${data.length} observations au total. Les filtres appliqu√©s sont¬†: Stations/Groupes : ${selections.join(', ') || 'Tous'}, Ann√©es : ${years.join(', ') || 'Toutes'}, Modalit√©s : ${modalities.join(', ') || 'Toutes'}, Inclusion des pr√©visions m√©t√©o : ${includeWeather ? 'Oui' : 'Non'}.</p>
                    <p>M√©thodologie : Les tendances sont calcul√©es en utilisant des pond√©rations pour les modalit√©s (assec: 4, ecoulement non visible: 3, ecoulement visible faible: 2, ecoulement visible acceptable: 1). La tendance est d√©termin√©e par la diff√©rence de poids moyen entre les relev√©s (am√©lioration si < -0.5, d√©gradation si > 0.5). Les projections m√©t√©o sont bas√©es sur Open-Meteo, avec risque = (poids * 50) + ((10 - pluie) * 5) + (temp - 15) * 2.</p>

                    <h2 id="resume-statistique">R√©sum√© Statistique</h2>
                    <p>Statistiques globales des donn√©es filtr√©es. Variance inter-annuelle des poids moyens : ${variance}.</p>
                    <table>
                        <tr><th>Statistique</th><th>Valeur</th></tr>
                        <tr><td>Total Observations</td><td>${filteredData.length}</td></tr>
                        <tr><td>Stations Actives</td><td>${[...new Set(filteredData.map(d => d['Station d\'√©coulement']))].length}</td></tr>
                        ${allModalities.map(modality => {
                            const count = filteredData.filter(d => d['Modalit√© d\'√©coulement'] === modality).length;
                            const percent = filteredData.length > 0 ? Math.round((count / filteredData.length) * 100) : 0;
                            return `<tr><td>% ${modality}</td><td>${percent}% (${count})</td></tr>`;
                        }).join('')}
                    </table>
                    <h2 id="analyse-tendances">Analyse des Tendances</h2>
                    <p>Tableau des tendances avec sous-sections par entit√©.</p>
                    <table>
                        ${document.querySelector('#trendTable').outerHTML.replace(/class="table-header"/g, 'style="background-color: #005566; color: white;"').replace(/data-tooltip="[^"]*"/g, '').replace(/onclick="[^"]*"/g, '').replace(/class="[^"]*"/g, '').replace(/data-forecast="[^"]*"/g, '')}
                    </table>
                    <p>Analyse : Les tendances montrent une d√©gradation g√©n√©rale si le poids moyen augmente, avec focus sur les stations √† risque √©lev√©.</p>

                    <div class="page-break"></div>

                    <h2 id="classements">Classements</h2>
                    <h3>Variations Importantes</h3>
                    <table>
                        ${document.querySelector('#variationTable').outerHTML.replace(/class="table-header"/g, 'style="background-color: #005566; color: white;"').replace(/class="[^"]*"/g, '')}
                    </table>
                    <h3>Stations D√©grad√©es</h3>
                    <table>
                        ${document.querySelector('#degradedTable').outerHTML.replace(/class="table-header"/g, 'style="background-color: #005566; color: white;"').replace(/class="[^"]*"/g, '')}
                    </table>
                    <p>Analyse : Coefficient de Spearman entre variations et d√©gradations : ${spearman}. Une valeur proche de 1 indique une forte corr√©lation, sugg√©rant que les stations avec hautes variations sont souvent d√©grad√©es.</p>

                    <div class="page-break"></div>

                    <h2 id="visualisations">Visualisations</h2>
                    <h3>R√©partition par Station</h3>
                    <img src="${stationChartImage || ''}" alt="R√©partition par Station" />
                    <p>L√©gende : Pourcentage des modalit√©s par station, avec code couleur.</p>

                    <h3>R√©partition des Modalit√©s</h3>
                    <img src="${modalityChartImage || ''}" alt="Modalit√©s d'√âcoulement" />
                    <p>L√©gende : Pie chart de la r√©partition globale.</p>

                    <h3>√âvolution Annuelle</h3>
                    <img src="${yearlyTrendChartImage || ''}" alt="√âvolution Annuelle" />
                    <p>L√©gende : Lignes d'√©volution des pourcentages par ann√©e.</p>

                    <h3>Tendances par Station/Groupe</h3>
                    <img src="${stationTrendChartImage || ''}" alt="Tendances par Station/Groupe" />
                    <p>L√©gende : Tendances filtr√©es, avec lignes pour groupes en pointill√©.</p>

                    <div class="page-break"></div>
                    <h2 id="analyse-spatio-temporelle">Analyse Spatio‚Äëtemporelle et Multi‚Äëparam√®tres</h2>
                    <p>Cette section pr√©sente une synth√®se des calculs d'indice de sensibilit√©, des corr√©lations multivari√©es et du clustering effectu√©s pour les stations s√©lectionn√©es.</p>
                    <p>
                        R√©partition des niveaux de risque :
                        <strong>${riskCountsRpt.eleve}</strong> station(s) √† risque √©lev√© (‚â•75&nbsp;%),
                        <strong>${riskCountsRpt.moyen}</strong> station(s) √† risque moyen (50‚Äì74&nbsp;%),
                        <strong>${riskCountsRpt.faible}</strong> station(s) √† risque faible (&lt;50&nbsp;%).
                    </p>
                    <p>
                        Station(s) √† risque √©lev√© : ${riskCluster.highRiskStations.join(', ') || 'aucune'}.<br/>
                        Parmi elles, ${highRiskWithRestrictionsRpt.length} station(s) sont actuellement sous restrictions : ${highRiskWithRestrictionsRpt.join(', ') || 'aucune'}.
                    </p>
                    <p>
                        Corr√©lation entre l'indice de risque et les restrictions :
                        ${corrRestrRiskRpt !== null ? `<strong>${corrRestrRiskRpt.toFixed(2)}</strong> (${corrRestrDescRpt})` : 'Non calculable (donn√©es insuffisantes)'}. Cette corr√©lation aide √† comprendre si les zones soumises √† des restrictions actuelles correspondent aux stations pr√©sentant un risque accru.
                    </p>
                    <p>
                        Le clustering a form√© ${riskCluster.clusterCounts.filter(c => c > 0).length} groupe(s) distinct(s) de stations pr√©sentant des comportements similaires. Ces groupes correspondent √† des zones critiques, interm√©diaires ou pr√©serv√©es selon leur dynamique hydrologique.
                    </p>
                </body>
                </html>
            `;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            saveAs(blob, 'Rapport_Analyse_Detailee.html');
            showStatus('Exportation du rapport d√©taill√© en HTML r√©ussie ! Ouvrez-le dans Word.', 'success');
        }

        async function exportToPDF() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const filteredData = getFilteredData();
            if (filteredData.length === 0) {
                showStatus('Aucune donn√©e disponible pour g√©n√©rer le rapport PDF.', 'error');
                return;
            }

            // G√©n√©ration des images des graphiques
            const stationChartImage = await captureElement('stationChart');
            const modalityChartImage = await captureElement('modalityChart');
            const yearlyTrendChartImage = await captureElement('yearlyTrendChart');
            const stationTrendChartImage = await captureElement('stationTrendChart');

            // Construire un r√©sum√© coh√©rent des filtres et statistiques de base
            const selections = Array.from(document.getElementById('stationSelect').selectedOptions).map(opt => opt.value);
            const modalities = Array.from(document.getElementById('modalitySelect').selectedOptions).map(opt => opt.value);
            const years = Array.from(document.getElementById('yearSelect').selectedOptions).map(opt => opt.value);

            const variance = calculateInterAnnualVariance(filteredData);
            const activeStationsCount = [...new Set(filteredData.map(d => d['Station d\'√©coulement']))].length;

            // Prem√®re page : titre et r√©sum√©
            pdf.setFontSize(16);
            pdf.text("Rapport d'Analyse D√©taill√©e des √âcoulements", 105, 15, { align: 'center' });
            pdf.setFontSize(10);
            let y = 25;
            pdf.text(`Date : ${new Date().toLocaleDateString('fr-FR')}`, 10, y);
            y += 6;
            pdf.text(`Total d'observations : ${filteredData.length}`, 10, y);
            y += 6;
            pdf.text(`Stations actives : ${activeStationsCount}`, 10, y);
            y += 6;
            pdf.text(`Filtres : Stations/Groupes : ${selections.join(', ') || 'Tous'}; Ann√©es : ${years.join(', ') || 'Toutes'}; Modalit√©s : ${modalities.join(', ') || 'Toutes'}`, 10, y, { maxWidth: 190 });
            y += 6;
            pdf.text(`Pr√©visions m√©t√©o : ${includeWeather ? 'Oui' : 'Non'}`, 10, y);
            y += 6;
            pdf.text(`Variance inter-annuelle : ${variance}`, 10, y);

            // Nouvelle page pour les graphiques
            pdf.addPage();
            // R√©partition par station
            pdf.setFontSize(12);
            pdf.text('R√©partition par Station', 10, 10);
            if (stationChartImage) pdf.addImage(stationChartImage, 'PNG', 10, 15, 190, 90);
            // Nouvelle page pour modalit√©
            pdf.addPage();
            pdf.text('R√©partition des Modalit√©s', 10, 10);
            if (modalityChartImage) pdf.addImage(modalityChartImage, 'PNG', 10, 15, 190, 90);
            // Nouvelle page pour √©volution annuelle
            pdf.addPage();
            pdf.text('√âvolution Annuelle', 10, 10);
            if (yearlyTrendChartImage) pdf.addImage(yearlyTrendChartImage, 'PNG', 10, 15, 190, 90);
            // Nouvelle page pour tendances station/groupe
            pdf.addPage();
            pdf.text('Tendances par Station/Groupe', 10, 10);
            if (stationTrendChartImage) pdf.addImage(stationTrendChartImage, 'PNG', 10, 15, 190, 90);

            pdf.save('Rapport_Analyse_Detailee.pdf');
            showStatus('Exportation du rapport en PDF r√©ussie !', 'success');
        }

        function drawMiniChart(id, labels, values, unit) {
          const ctx = document.getElementById(id).getContext('2d');
          new Chart(ctx, {
            type:'line',
            data:{ labels, datasets:[{ data:values, borderWidth:1.5, fill:false, pointRadius:0 }] },
            options:{
              responsive:false,
              scales:{
                x:{ type:'time', time:{ unit:'month', tooltipFormat:'dd/MM/yyyy' }, ticks:{ maxTicksLimit:4 }},
                y:{ title:{ display:true, text:unit }}
              },
              plugins:{ legend:{display:false}, tooltip:{mode:'index', intersect:false} }
            }
          });
        }

     async function updateMapAndWeather() {
    const mapContainer = document.getElementById('map-container');
    if (Object.keys(stationCoordinates).length === 0) {
        mapContainer.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400">Aucune coordonn√©e disponible pour les stations.</p>';
        return;
    }

    if (map) map.remove();
    // Centrer la carte sur la moyenne des coordonn√©es des stations du d√©partement s√©lectionn√©.
    let latSum = 0, lonSum = 0, cnt = 0;
    Object.values(stationCoordinates).forEach(coord => {
        if (coord && !isNaN(coord.lat) && !isNaN(coord.lon)) {
            latSum += coord.lat;
            lonSum += coord.lon;
            cnt++;
        }
    });
    const avgLat = cnt > 0 ? latSum / cnt : 43.7;
    const avgLon = cnt > 0 ? lonSum / cnt : -0.26;
    map = L.map('map-container').setView([avgLat, avgLon], 9);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    let overlays = {};

    // Palette couleurs niveau (utilis√© pour restrictions)
    const couleurNiveau = {
        vigilance: '#f9f871',
        alerte: '#f59e0b',
        alerte_renforcee: '#ef4444',
        crise: '#b91c1c'
    };

    // G√©n√®re lien TXT √† t√©l√©charger (pour restriction)
    function makeTextDownloadLink(props) {
        const safeName = (props.nom || '').replace(/[^\w\-]+/g, '_').slice(0, 40);
        const filename = `restrictions_${safeName}.txt`;
        let txt = `Zone : ${props.nom}\n`;
        txt += `Type : ${props.type}\n`;
        txt += `Niveau : ${props.niveauGravite}\n\n`;
        txt += `Usages interdits :\n`;
        if (Array.isArray(props.restrictions) && props.restrictions.length) {
            props.restrictions.forEach(item => {
                const desc = (item.description || '').trim().replace(/\r\n|\n/g, ' ');
                txt += `‚Ä¢ ${item.nom} : ${desc}\n`;
            });
        } else {
            txt += `‚Äì\n`;
        }
        txt += `\nArr√™t√© : ${props.arreteRestriction || 'aucun'}\n`;
        const uri = 'data:text/plain;charset=utf-8,' + encodeURIComponent(txt);
        return `<a href="${uri}" download="${filename}">T√©l√©charger (texte)</a>`;
    }

    // === Couche restrictions d‚Äôeau (dynamique selon le d√©partement s√©lectionn√©)
    restrictionsLayer = L.geoJSON(null, {
        renderer: L.canvas(),
        style: feat => {
            const lvl = String(feat.properties.niveauGravite).toLowerCase().trim();
            const c = couleurNiveau[lvl] || '#3388ff';
            return { color: c, fillColor: c, fillOpacity: 0.4, weight: 2 };
        },
        onEachFeature: (feat, lyr) => {
            const p = feat.properties;
            // Usages interdits
            let usages = '<ul style="padding-left:1em;margin:0;">';
            if (Array.isArray(p.restrictions)) {
                p.restrictions.forEach(r => {
                    const desc = (r.description || '').trim().replace(/\r\n|\n/g, '<br/>');
                    usages += `<li style="margin-bottom:0.5em;"><strong>${r.nom}</strong>:<br/><span style="font-size:0.9em;">${desc}</span></li>`;
                });
            } else {
                usages += '<li>‚Äì</li>';
            }
            usages += '</ul>';
            // Lien arr√™t√© si dispo
            const lien = p.arreteRestriction
                ? `<a href="#" onclick="ouvrirArrete(p.arreteRestriction, p.nom); return false;" style="color: #005566; text-decoration: underline;">Voir l‚Äôarr√™t√©</a>`
                : '‚Äì';
            // Bouton t√©l√©chargement TXT
            const downloadTxt = makeTextDownloadLink(p);

            const html = `
                <div style="max-width:350px;line-height:1.3;">
                    <strong>${p.nom}</strong><br/>
                    <em>Type :</em> ${p.type}<br/>
                    <em>Niveau :</em> ${p.niveauGravite}<br/>
                    <em>D√©pt :</em> ${p.departement?.nom || '‚Äì'}<br/>
                    <hr style="margin:6px 0;"/>
                    <div style="max-height:150px;overflow-y:auto;padding-right:6px;">
                        <strong>Usages interdits :</strong>${usages}
                    </div>
                    <hr style="margin:6px 0;"/>
                    ${lien}<br/>
                    ${downloadTxt}
                </div>
            `;
            lyr.bindPopup(html, { maxWidth: 350, maxHeight: 300 });
        }
    });
    // On n'ajoute pas automatiquement la couche des restrictions d'eau ; elle sera
    // ajout√©e ou retir√©e en fonction de l'√©tat du bouton glissant associ√©.
    // La cl√© de l'overlay est mise √† jour dynamiquement avec le d√©partement s√©lectionn√©.
    overlays[`Rest. d‚Äôeau (${selectedDept})`] = restrictionsLayer;

    // Chargement des donn√©es restrictions d‚Äôeau pour le d√©partement s√©lectionn√©.
    (async function () {
        try {
            const resp = await fetch('https://www.data.gouv.fr/api/1/datasets/r/bfba7898-aed3-40ec-aa74-abb73b92a363');
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const gj = await resp.json();
            const feats = gj.features.filter(f => String(f.properties.departement?.code) === String(selectedDept));
            restrictionsLayer.addData({ type: 'FeatureCollection', features: feats });
        } catch (e) {
            console.error('Erreur fetch restrictions :', e);
        }
    })();

    // --- Heatmap (inchang√©e) ---
    const heatPoints = [];
    projections.forEach(p => {
        const coord = stationCoordinates[p.entity];
        if (coord) {
            const intensity = sensitiveMode ? p.sensitivityScore / 100 : p.risk / 100;
            heatPoints.push([coord.lat, coord.lon, intensity]);
        }
    });
    heatLayer = L.heatLayer(heatPoints, { radius: 25, blur: 15 }).addTo(map);

    let tempStations = [];

    // 1) Pr√©charge stations temp√©rature
    fetch(`https://hubeau.eaufrance.fr/api/v1/temperature/station?code_departement=${selectedDept}&size=500&format=json`)
      .then(r=>r.json()).then(js=> tempStations = js.data)
      .catch(console.error);

    // Couche pour Stations √âcoulement
    ecoulementLayer = L.layerGroup();
    if (document.getElementById('toggleEcoulement').checked) ecoulementLayer.addTo(map);
    projections.forEach(p => {
        const coord = stationCoordinates[p.entity];
        if (coord) {
            let fillColor;
            if (sensitiveMode) {
                if (p.sensitivityScore > 70) fillColor = 'red';
                else if (p.sensitivityScore > 40) fillColor = 'orange';
                else fillColor = 'green';
            } else {
                fillColor = modalityColors[p.lastModality.toLowerCase()] || 'gray';
            }
            const projectionBorder = p.color === '#ef4444' ? 'red' : p.color === '#f59e0b' ? 'orange' : 'green';
            const marker = L.circleMarker([coord.lat, coord.lon], { color: projectionBorder, fillColor: fillColor, fillOpacity: 0.7, radius: 8, weight: 1 }).addTo(ecoulementLayer);
            let popupContent = `<b>${p.entity}</b><br> Dernier relev√©: ${p.lastModality}<br>Date dernier relev√©: ${p.lastDate}<br>Tendance: ${p.trend}<br>Projection: ${p.text} (${p.risk}%)<br>Pr√©visions m√©t√©o (7j): Pluie ${p.rain}mm, Temp ${p.temp}¬∞C`;
            if (sensitiveMode) {
                popupContent += `<br>Sensibilit√©: ${p.sensitivityScore.toFixed(0)}% (R√©current: ${p.isRecurring ? 'Oui' : 'Non'}, Variation: ${p.variation.toFixed(2)}%, D√©grad√©: ${p.degradedPct}%)`;
            }
            marker.bindPopup(popupContent);
        }
    });
    overlays["Stations √âcoulement"] = ecoulementLayer;

    // 2) HYDROM√âTRIE (D√©bits)
    hydroLayer = L.layerGroup();
    if (document.getElementById('toggleDebits').checked) hydroLayer.addTo(map);
    (async()=>{
      try {
        const resH = await fetch(
          `https://hubeau.eaufrance.fr/api/v2/hydrometrie/referentiel/stations?code_departement=${selectedDept}&en_service=true&size=200&format=json`
        );
        if (!resH.ok) throw new Error(`Erreur API hydrom√©trie stations : ${resH.status}`);
        const { data } = await resH.json();

        for (const sta of data) {
          // D√©terminer le niveau d'alerte et la couleur associ√©e en fonction des projections (risque ou couleur)
          let alertColor = '#1D4ED8';
          let alertString = 'Vigilance';
          // Trouver le nom de station d'√©coulement correspondant au code station hydro pour r√©cup√©rer la projection
          const stationName = Object.keys(stationHubCodes).find(k => stationHubCodes[k] === sta.code_station);
          if (stationName) {
            const proj = projections.find(p => p.entity === stationName);
            if (proj) {
              if (proj.color === '#ef4444') {
                alertColor = '#ef4444';
                alertString = 'Crise';
              } else if (proj.color === '#f59e0b') {
                alertColor = '#f59e0b';
                alertString = 'Alerte';
              } else {
                alertColor = '#22c55e';
                alertString = 'Vigilance';
              }
            }
          }
          const hydroIcon = L.divIcon({
            className: 'custom-div-icon',
            html: `<svg width="30" height="30" viewBox="0 0 24 24" fill="${alertColor}">
              <path d="M12 2C8.5 6 7 9.5 7 13c0 3.31 2.69 6 5 6s5-2.69 5-6c0-3.5-1.5-7-5-11z"></path>
              <path d="M9 13c1.5-1.5 4-1.5 6 0" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path>
              <path d="M12 16v3" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path>
              <path d="M12 19l-1-1m1 1l1-1" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"></path>
            </svg>`,
            iconSize: [30, 30],
            iconAnchor: [15, 30]
          });
          // Cr√©ation du marqueur
          const m = L.marker([sta.latitude_station, sta.longitude_station], { icon: hydroIcon }).addTo(hydroLayer);

          // Gestion du clic sur marqueur pour afficher popup et graphique
          m.on('click', async () => {
            try {
              // D√©bit Q
              const oQ = await (await fetch(
                `https://hubeau.eaufrance.fr/api/v2/hydrometrie/observations_tr?code_entite=${sta.code_station}&grandeur_hydro=Q&size=1&fields=date_obs,resultat_obs&format=json`
              )).json();
              const obsQ = oQ.data[0] || {};
              const lastQ = obsQ.resultat_obs != null ? (obsQ.resultat_obs / 1000).toFixed(3) + ' m¬≥/s' : 'N/A';
              const dQ = obsQ.date_obs ? new Date(obsQ.date_obs).toLocaleDateString('fr-FR') : '';

              // Hauteur H
              const oH = await (await fetch(
                `https://hubeau.eaufrance.fr/api/v2/hydrometrie/observations_tr?code_entite=${sta.code_station}&grandeur_hydro=H&size=1&fields=date_obs,resultat_obs&format=json`
              )).json();
              const obsH = oH.data[0] || {};
              const lastH = obsH.resultat_obs != null ? (obsH.resultat_obs / 1000).toFixed(3) + ' m' : 'N/A';
              const dH = obsH.date_obs ? new Date(obsH.date_obs).toLocaleDateString('fr-FR') : '';

              // Temp√©rature station la plus proche
              let tempInfo = { value: 'N/A', date: '' };
              if (tempStations.length) {
                const toRad = d => d * Math.PI / 180, R = 6371;
                let nearest = tempStations[0], dMin = Infinity;
                for (const ts of tempStations) {
                  const d = R * 2 * Math.atan2(
                    Math.sqrt(
                      Math.sin((ts.latitude - sta.latitude_station) * Math.PI / 360) ** 2 +
                      Math.cos(ts.latitude * Math.PI / 180) * Math.cos(sta.latitude_station * Math.PI / 180) *
                      Math.sin((ts.longitude - sta.longitude_station) * Math.PI / 360) ** 2
                    ),
                    Math.sqrt(1 - (
                      Math.sin((ts.latitude - sta.latitude_station) * Math.PI / 360) ** 2 +
                      Math.cos(ts.latitude * Math.PI / 180) * Math.cos(sta.latitude_station * Math.PI / 180) *
                      Math.sin((ts.longitude - sta.longitude_station) * Math.PI / 360) ** 2
                    ))
                  );
                  if (d < dMin) { dMin = d; nearest = ts; }
                }
                const tJ = await (await fetch(
                  `https://hubeau.eaufrance.fr/api/v1/temperature/chronique?code_station=${nearest.code_station}&size=1&sort=desc&fields=date_mesure_temp,heure_mesure_temp,resultat&format=json`
                )).json();
                const to = tJ.data[0] || {};
                if (to.resultat != null) {
                  tempInfo.value = to.resultat.toFixed(2) + ' ¬∞C';
                  tempInfo.date = `${to.date_mesure_temp} ${to.heure_mesure_temp}`;
                }
              }

              // Historique Q (3 mois)
              const since = new Date(); since.setMonth(since.getMonth() - 3);
              const hQ = await (await fetch(
                `https://hubeau.eaufrance.fr/api/v2/hydrometrie/obs_elab?code_entite=${sta.code_station}&grandeur_hydro_elab=QmnJ&date_debut_obs_elab=${since.toISOString().slice(0, 10)}&size=92&format=json`
              )).json();
              const hist = hQ.data || [];

              // Affichage popup + mini-graph
              const pid = `chart-hydro-${sta.code_station}`;
              const popupContent = `
                <div class="modern-popup-container">
                  <div class="popup-header" style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);">
                    <div class="popup-icon">
                      <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                        <path d="M12 2C8.5 6 7 9.5 7 13c0 3.31 2.69 6 5 6s5-2.69 5-6c0-3.5-1.5-7-5-11z"></path>
                        <path d="M9 13c1.5-1.5 4-1.5 6 0" stroke="#1e40af" stroke-width="1.5" stroke-linecap="round"></path>
                      </svg>
                    </div>
                    <div class="popup-title-section">
                      <h3>Station Hydrom√©trique</h3>
                      <p>${sta.libelle_cours_eau}</p>
                    </div>
                  </div>
                  <div class="popup-body">
                    <div class="popup-grid">
                      <div class="popup-item">
                        <span class="popup-label">Code station</span>
                        <span class="popup-value">${sta.code_station}</span>
                      </div>
                      <div class="popup-item">
                        <span class="popup-label">D√©bit</span>
                        <span class="popup-value">${lastQ} <small class="popup-date">(${dQ})</small></span>
                      </div>
                      <div class="popup-item">
                        <span class="popup-label">Hauteur</span>
                        <span class="popup-value">${lastH} <small class="popup-date">(${dH})</small></span>
                      </div>
                      <div class="popup-item">
                        <span class="popup-label">Temp√©rature</span>
                        <span class="popup-value">${tempInfo.value} <small class="popup-date">(${tempInfo.date})</small></span>
                      </div>
                      <div class="popup-item">
                        <span class="popup-label">Niveau d'alerte</span>
                        <span class="popup-value" style="color:${alertColor}; font-weight: 600;">${alertString}</span>
                      </div>
                    </div>
                    <div class="popup-chart-container">
                      <canvas id="${pid}" class="popup-chart"></canvas>
                    </div>
                  </div>
                </div>
              `;
              m.bindPopup(popupContent).openPopup();
              setTimeout(() => drawMiniChart(
                pid,
                hist.map(d => new Date(d.date_obs_elab || d.date_obs)),
                hist.map(d => (d.resultat_obs_elab || d.resultat_obs) / 1000),
                'm¬≥/s'
              ), 100);
            } catch (err) {
              console.error(err);
              m.bindPopup('<div class="popup-content">Erreur lors de la r√©cup√©ration des donn√©es hydrom√©triques.</div>').openPopup();
            }
          });
        }
        overlays["D√©bits (Hydrom√©trie)"] = hydroLayer;
      } catch (err) {
        console.error('Erreur chargement hydrom√©trie :', err);
      }
    })();

    // 3) PI√âZOM√âTRIE (Nappes)
    piezoLayer = L.layerGroup();
    if (document.getElementById('toggleNappes').checked) piezoLayer.addTo(map);
    (async()=>{
      const { data } = await (await fetch(
        `https://hubeau.eaufrance.fr/api/v1/niveaux_nappes/stations?code_departement=${selectedDept}&size=200&format=json`
      )).json();

      const piezoIcon = L.divIcon({
        className: 'custom-div-icon',
        // Icon representing groundwater levels: a water drop atop stratified layers.
        html: `<svg width="30" height="30" viewBox="0 0 24 24" fill="none">
          <defs>
            <linearGradient id="nappeGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#059669" />
              <stop offset="100%" stop-color="#10B981" />
            </linearGradient>
          </defs>
          <path d="M12 2C9 5 8 9 8 12c0 3.86 3.14 7 4 8 0 0 4-4.14 4-8 0-3-1-7-4-10z" fill="url(#nappeGrad)"/>
          <path d="M6 17h12" stroke="#059669" stroke-width="1.5" stroke-linecap="round"/>
          <path d="M7 19h10" stroke="#059669" stroke-width="1.5" stroke-linecap="round"/>
          <path d="M8 21h8" stroke="#059669" stroke-width="1.5" stroke-linecap="round"/>
        </svg>`,
        iconSize: [30, 30],
        iconAnchor: [15, 30]
      });

      for(const sta of data){
        const [lon,lat] = sta.geometry.coordinates;
        const m = L.marker([lat,lon], { icon: piezoIcon }).addTo(piezoLayer);

        m.on('click', async ()=>{
          const name = sta.libelle_pe||sta.nom_commune||sta.code_bss;
          const tr = await (await fetch(
            `https://hubeau.eaufrance.fr/api/v1/niveaux_nappes/chroniques_tr?`+
            `code_bss=${encodeURIComponent(sta.code_bss)}&size=5&sort=desc&fields=date_mesure,niveau_nappe_eau&format=json`
          )).json();

          let series = [], lastOb;
          if(tr.data.length){
            series = tr.data.map(d=>({ date:new Date(d.date_mesure), value:d.niveau_nappe_eau })).reverse();
            lastOb = series[series.length-1];
          } else {
            const h = await (await fetch(
              `https://hubeau.eaufrance.fr/api/v1/niveaux_nappes/chroniques?`+
              `code_bss=${encodeURIComponent(sta.code_bss)}`+
              `&date_debut_niveaux_nappes_chroniques=${sta.date_debut_mesure}`+
              `&size=20000&sort=asc&fields=date_mesure,niveau_nappe_eau&format=json`
            )).json();
            series = (h.data || []).map(d=>({ date:new Date(d.date_mesure), value:d.niveau_nappe_eau }));
            lastOb = series[series.length-1] || null;
          }

          if(series.length && lastOb){
            const pid = `chart-piezo-${sta.code_bss.replace(/\W/g,'-')}`;
            m.bindPopup(`
              <div class="modern-popup-container">
                <div class="popup-header" style="background: linear-gradient(135deg, #059669 0%, #10B981 100%);">
                  <div class="popup-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                      <path d="M12 2C9 5 8 9 8 12c0 3.86 3.14 7 4 8 0 0 4-4.14 4-8 0-3-1-7-4-10z"/>
                      <path d="M6 17h12M7 19h10M8 21h8" stroke="#059669" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                  </div>
                  <div class="popup-title-section">
                    <h3>Station Pi√©zom√©trique</h3>
                    <p>${name}</p>
                  </div>
                </div>
                <div class="popup-body">
                  <div class="popup-grid">
                    <div class="popup-item">
                      <span class="popup-label">Code BSS</span>
                      <span class="popup-value">${sta.code_bss}</span>
                    </div>
                    <div class="popup-item">
                      <span class="popup-label">Niveau nappe</span>
                      <span class="popup-value">${lastOb.value.toFixed(2)} m <small class="popup-date">(${lastOb.date.toLocaleDateString('fr-FR')})</small></span>
                    </div>
                  </div>
                  <div class="popup-chart-container">
                    <canvas id="${pid}" class="popup-chart"></canvas>
                  </div>
                </div>
              </div>
            `).openPopup();
            setTimeout(()=>drawMiniChart(
              pid,
              series.map(p=>p.date),
              series.map(p=>p.value),
              'm'
            ),100);
          } else {
            m.bindPopup(`
              <div class="modern-popup-container">
                <div class="popup-header" style="background: linear-gradient(135deg, #059669 0%, #10B981 100%);">
                  <div class="popup-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                      <path d="M12 2C9 5 8 9 8 12c0 3.86 3.14 7 4 8 0 0 4-4.14 4-8 0-3-1-7-4-10z"/>
                      <path d="M6 17h12M7 19h10M8 21h8" stroke="#059669" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                  </div>
                  <div class="popup-title-section">
                    <h3>Station Pi√©zom√©trique</h3>
                    <p>${name}</p>
                  </div>
                </div>
                <div class="popup-body">
                  <div class="popup-grid">
                    <div class="popup-item">
                      <span class="popup-label">Code BSS</span>
                      <span class="popup-value">${sta.code_bss}</span>
                    </div>
                    <div class="popup-item">
                      <span class="popup-label">Statut</span>
                      <span class="popup-value" style="color: #ef4444;">Pas de donn√©es disponibles</span>
                    </div>
                  </div>
                </div>
              </div>
            `).openPopup();
          }
        });
      }

      overlays["Nappes (Pi√©zom√©trie)"] = piezoLayer;
    })();

    // 4) PR√âL√àVEMENTS‚ÄëEAU
    prelLayer = L.layerGroup();
    if (document.getElementById('togglePrelevements').checked) prelLayer.addTo(map);
    (async()=>{
      const { data } = await (await fetch(
        `https://hubeau.eaufrance.fr/api/v1/prelevements/referentiel/ouvrages?code_departement=${selectedDept}&size=200&format=json`
      )).json();

      const prelIcon = L.divIcon({
        className: 'custom-div-icon',
        // Icon representing water withdrawals: a water drop with an extraction bar and arrow.
        html: `<svg width="30" height="30" viewBox="0 0 24 24" fill="none">
          <defs>
            <linearGradient id="prelGrad" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#EA580C" />
              <stop offset="100%" stop-color="#FB923C" />
            </linearGradient>
          </defs>
          <path d="M12 2C8.5 6 7 9.5 7 13c0 3.31 2.69 6 5 6s5-2.69 5-6c0-3.5-1.5-7-5-11z" fill="url(#prelGrad)"/>
          <rect x="11" y="12" width="2" height="5" rx="1" fill="#ffffff"/>
          <path d="M12 17v3" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"/>
          <path d="M12 20l-1-1m1 1l1-1" stroke="#ffffff" stroke-width="1.5" stroke-linecap="round"/>
        </svg>`,
        iconSize: [30, 30],
        iconAnchor: [15, 30]
      });

      for(const ov of data){
        if(!ov.latitude||!ov.longitude) continue;
        const m = L.marker([ov.latitude,ov.longitude], { icon: prelIcon }).addTo(prelLayer);

        m.on('click', async ()=>{
          const jh = await (await fetch(
            `https://hubeau.eaufrance.fr/api/v1/prelevements/chroniques?`+
            `code_ouvrage=${ov.code_ouvrage}&size=5&sort=desc&fields=annee,volume&format=json`
          )).json();
          const series = (jh.data || []).slice().reverse();
          const last   = series[series.length-1] || {};
          const vol    = last.volume != null ? last.volume.toLocaleString()+' m¬≥' : 'N/A';
          const yr     = last.annee || 'N/A';
          const pid    = `chart-prel-${ov.code_ouvrage}`;

          m.bindPopup(`
            <div class="modern-popup-container">
              <div class="popup-header" style="background: linear-gradient(135deg, #EA580C 0%, #FB923C 100%);">
                <div class="popup-icon">
                  <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                    <path d="M12 2C8.5 6 7 9.5 7 13c0 3.31 2.69 6 5 6s5-2.69 5-6c0-3.5-1.5-7-5-11z"/>
                    <rect x="11" y="12" width="2" height="5" rx="1" fill="#EA580C"/>
                    <path d="M12 17v3M12 20l-1-1m1 1l1-1" stroke="#EA580C" stroke-width="1.5" stroke-linecap="round"/>
                  </svg>
                </div>
                <div class="popup-title-section">
                  <h3>Ouvrage de Pr√©l√®vement</h3>
                  <p>${ov.nom_ouvrage}</p>
                </div>
              </div>
              <div class="popup-body">
                <div class="popup-grid">
                  <div class="popup-item">
                    <span class="popup-label">Code ouvrage</span>
                    <span class="popup-value">${ov.code_ouvrage}</span>
                  </div>
                  <div class="popup-item">
                    <span class="popup-label">Volume ${yr}</span>
                    <span class="popup-value">${vol}</span>
                  </div>
                </div>
                <div class="popup-chart-container">
                  <canvas id="${pid}" class="popup-chart"></canvas>
                </div>
              </div>
            </div>
          `).openPopup();

          setTimeout(()=>drawMiniChart(
            pid,
            series.map(d=>new Date(d.annee,0,1)),
            series.map(d=>d.volume),
            'm¬≥'
          ),100);
        });
      }

      overlays["Pr√©l√®vements"] = prelLayer;
    })();

    // 5) QUALIT√â D'EAU (Physico-chimique)
    qualiteLayer = L.layerGroup();
    // Ajouter la couche si l'interrupteur est actif
    if (document.getElementById('toggleQualite') && document.getElementById('toggleQualite').checked) qualiteLayer.addTo(map);
    (async () => {
      try {
        const resQ = await fetch(`https://hubeau.eaufrance.fr/api/v2/qualite_rivieres/station_pc?code_departement=${selectedDept}&size=2000&format=json`);
        if (!resQ.ok) throw new Error(`Erreur API qualit√© stations : ${resQ.status}`);
        const jsQ = await resQ.json();
        const qualStations = jsQ.data || [];
        // Ic√¥ne pour la qualit√© d'eau : b√©cher/√©prouvette
        const qualIcon = L.divIcon({
          className: 'custom-div-icon',
          html: `<svg width="30" height="30" viewBox="0 0 24 24" fill="none">
            <rect x="8" y="2" width="8" height="12" rx="1" stroke="#0EA5E9" stroke-width="1.5" fill="#CFFAFE"></rect>
            <path d="M8 6h8" stroke="#0EA5E9" stroke-width="1.5"></path>
            <path d="M10 12h4" stroke="#0EA5E9" stroke-width="1.5"></path>
          </svg>`,
          iconSize: [30, 30],
          iconAnchor: [15, 30]
        });
        for (const sta of qualStations) {
          const lat = sta.latitude_station || sta.latitude || (sta.geometry && sta.geometry.coordinates && sta.geometry.coordinates[1]);
          const lon = sta.longitude_station || sta.longitude || (sta.geometry && sta.geometry.coordinates && sta.geometry.coordinates[0]);
          if (lat == null || lon == null) continue;
          const m = L.marker([parseFloat(lat), parseFloat(lon)], { icon: qualIcon }).addTo(qualiteLayer);
          m.on('click', async () => {
            let popupHtml = `
              <div class="modern-popup-container">
                <div class="popup-header" style="background: linear-gradient(135deg, #0EA5E9 0%, #38BDF8 100%);">
                  <div class="popup-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                      <rect x="8" y="2" width="8" height="12" rx="1" stroke="#0EA5E9" stroke-width="1.5"/>
                      <path d="M8 6h8M10 12h4" stroke="#0EA5E9" stroke-width="1.5"/>
                    </svg>
                  </div>
                  <div class="popup-title-section">
                    <h3>Station Qualit√© d'Eau</h3>
                    <p>${sta.libelle_station || sta.code_station}</p>
                  </div>
                </div>
                <div class="popup-body">
                  <div class="popup-grid">`;
            try {
              // R√©cup√©rer les trois derni√®res analyses physico-chimiques pour cette station
              const aResp = await fetch('https://hubeau.eaufrance.fr/api/v2/qualite_rivieres/analyse_pc?code_station=' + encodeURIComponent(sta.code_station) + '&size=3&sort=desc&format=json');
              const aj = await aResp.json();
              const analyses = aj.data || [];
              if (analyses.length) {
                analyses.forEach(a => {
                  // Trouver le libell√© de la grandeur (param√®tre) avec fallback
                  const paramName = a.libelle_grandeur || a.libelle_parametre || a.parametre || a.grandeur_analyse || a.code_parametre || 'Param√®tre';
                  const value = a.resultat || a.resultat_analyse || a.valeur || a.valeur_analyse || '‚Äî';
                  const unit = a.unite || a.libelle_unite || a.code_unite || '';
                  const dateStr = a.date_prelevement || a.date_analyse || a.date || '';
                  popupHtml += `
                    <div class="popup-item">
                      <span class="popup-label">${paramName}</span>
                      <span class="popup-value"><strong>${value}</strong> ${unit} <small class="popup-date">(${dateStr})</small></span>
                    </div>`;
                });
              } else {
                popupHtml += 'Pas d‚Äôanalyse r√©cente';
              }
            } catch (e) {
              popupHtml += `
                <div class="popup-item">
                  <span class="popup-label">Erreur</span>
                  <span class="popup-value" style="color: #ef4444;">Impossible de r√©cup√©rer les analyses</span>
                </div>`;
              console.error(e);
            }
            popupHtml += `
                  </div>
                </div>
              </div>`;
            m.bindPopup(popupHtml).openPopup();
          });
        }
        overlays["Qualit√© d'eau"] = qualiteLayer;
      } catch (e) {
        console.error('Erreur chargement qualit√©', e);
      }
    })();

    // 6) HYDROBIOLOGIE (Flore/Faune)
    floraLayer = L.layerGroup();
    if (document.getElementById('toggleFlore') && document.getElementById('toggleFlore').checked) floraLayer.addTo(map);
    (async () => {
      try {
        const resF = await fetch(`https://hubeau.eaufrance.fr/api/v1/hydrobio/stations_hydrobio?code_departement=${selectedDept}&size=2000&format=json`);
        if (!resF.ok) throw new Error(`Erreur API hydrobio stations : ${resF.status}`);
        const jsF = await resF.json();
        const floraStations = jsF.data || [];
        const floraIcon = L.divIcon({
          className: 'custom-div-icon',
          html: `<svg width="30" height="30" viewBox="0 0 24 24" fill="none">
            <path d="M12 2c-3 4-5 6.5-5 10 0 4 3 7 5 9 2-2 5-5 5-9 0-3.5-2-6-5-10z" fill="#22C55E"></path>
            <path d="M12 13l-2-2m2 2l2-2" stroke="#FFFFFF" stroke-width="1.5" stroke-linecap="round"></path>
          </svg>`,
          iconSize: [30, 30],
          iconAnchor: [15, 30]
        });
        for (const sta of floraStations) {
          const lat = sta.latitude_station || sta.latitude || (sta.geometry && sta.geometry.coordinates && sta.geometry.coordinates[1]);
          const lon = sta.longitude_station || sta.longitude || (sta.geometry && sta.geometry.coordinates && sta.geometry.coordinates[0]);
          if (lat == null || lon == null) continue;
          const m = L.marker([parseFloat(lat), parseFloat(lon)], { icon: floraIcon }).addTo(floraLayer);
          m.on('click', async () => {
            let popupHtml = `
              <div class="modern-popup-container">
                <div class="popup-header" style="background: linear-gradient(135deg, #22C55E 0%, #4ADE80 100%);">
                  <div class="popup-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                      <path d="M12 2c-3 4-5 6.5-5 10 0 4 3 7 5 9 2-2 5-5 5-9 0-3.5-2-6-5-10z"/>
                      <path d="M12 13l-2-2m2 2l2-2" stroke="#22C55E" stroke-width="1.5" stroke-linecap="round"/>
                    </svg>
                  </div>
                  <div class="popup-title-section">
                    <h3>Station Hydrobiologique</h3>
                    <p>${sta.libelle_station || sta.code_station || sta.code_station_hydrobio || sta.code}</p>
                  </div>
                </div>
                <div class="popup-body">
                  <div class="popup-grid">`;
            try {
              // D√©terminer le code de station pour l'appel √† l'API des indices. Certains jeux utilisent code_station_hydrobio ou code_station ou code.
              const codeStation = sta.code_station_hydrobio || sta.code_station || sta.code;
              const idxResp = await fetch('https://hubeau.eaufrance.fr/api/v1/hydrobio/indices?code_station_hydrobio=' + encodeURIComponent(codeStation) + '&size=1&sort=desc&format=json');
              const idxJson = await idxResp.json();
              const idx = (idxJson.data || [])[0];
              if (idx) {
                // D√©terminer l'intitul√© et la valeur de l'indice biologique
                const indiceCode = idx.code_indice || idx.code || 'Indice';
                const indiceLabel = idx.libelle_indice || idx.libelle || '';
                const value = idx.resultat_indice || idx.valeur_indice || idx.valeur || idx.resultat || '‚Äî';
                const dateStr = idx.date_prelevement || idx.date || '';
                popupHtml += `
                  <div class="popup-item">
                    <span class="popup-label">Indice ${indiceCode}${indiceLabel ? ' ‚Äì ' + indiceLabel : ''}</span>
                    <span class="popup-value"><strong>${value}</strong> <small class="popup-date">(${dateStr})</small></span>
                  </div>`;
              } else {
                popupHtml += 'Pas d‚Äôindice disponible';
              }
            } catch (e) {
              popupHtml += 'Impossible de r√©cup√©rer l‚Äôindice.';
              console.error(e);
            }
            popupHtml += '</div>';
            m.bindPopup(popupHtml).openPopup();
          });
        }
        overlays["Hydrobiologie"] = floraLayer;
      } catch (e) {
        console.error('Erreur chargement hydrobio', e);
      }
    })();

    // 7) OBSTACLES √Ä L'√âCOULEMENT
    obstaclesLayer = L.layerGroup();
    bassinsLayer = L.layerGroup();
    massesEauLayer = L.layerGroup();
    zonesHumidesLayer = L.layerGroup();
    console.log("Couches initialis√©es:", { obstaclesLayer, bassinsLayer, massesEauLayer, zonesHumidesLayer });
    // Ajouter la couche si l'interrupteur est actif
    if (document.getElementById('toggleObstacles')?.checked) {
        obstaclesLayer.addTo(map);
    }

    // Chargement initial des obstacles selon le d√©partement s√©lectionn√© avec donn√©es Sandre WFS
    updateObstaclesLayer().catch(error => console.error('Erreur chargement initial obstacles:', error));
    overlays["Obstacles √† l'√©coulement"] = obstaclesLayer;
    // Supprimer le contr√¥le de couches par d√©faut de Leaflet pour √©viter des cases √† cocher suppl√©mentaires
    // layerControl = L.control.layers(null, overlays, { collapsed: false }).addTo(map);

    // Mettre √† jour l'affichage des l√©gendes de sensibilit√© et de projection en fonction du mode sensible et de l'√©tat de la couche √©coulement
    document.getElementById('sensitivity-legend').style.display = (sensitiveMode && document.getElementById('toggleEcoulement').checked) ? 'block' : 'none';
    document.getElementById('projection-legend').style.display = (!sensitiveMode && document.getElementById('toggleEcoulement').checked) ? 'block' : 'none';

    setTimeout(() => map.invalidateSize(), 100);

    // Synchroniser les commutateurs (boutons glissants) avec les couches et mettre √† jour la l√©gende dynamiquement
    document.getElementById('toggleEcoulement').addEventListener('change', (e) => {
        if (e.target.checked) {
            map.addLayer(ecoulementLayer);
        } else {
            map.removeLayer(ecoulementLayer);
        }
        updateLegendVisibility();
    });
    document.getElementById('toggleDebits').addEventListener('change', (e) => {
        if (e.target.checked) {
            map.addLayer(hydroLayer);
        } else {
            map.removeLayer(hydroLayer);
        }
        updateLegendVisibility();
    });
    document.getElementById('toggleNappes').addEventListener('change', (e) => {
        if (e.target.checked) {
            map.addLayer(piezoLayer);
        } else {
            map.removeLayer(piezoLayer);
        }
        updateLegendVisibility();
    });
    document.getElementById('togglePrelevements').addEventListener('change', (e) => {
        if (e.target.checked) {
            map.addLayer(prelLayer);
        } else {
            map.removeLayer(prelLayer);
        }
        updateLegendVisibility();
    });

    // Toggle for restrictions d'eau (dynamique). Adds or removes the layer on change.
    const toggleRest = document.getElementById('toggleRestrictions');
    if (toggleRest) {
        // Initialize layer visibility based on initial toggle state
        if (toggleRest.checked) {
            map.addLayer(restrictionsLayer);
        } else {
            map.removeLayer(restrictionsLayer);
        }
        toggleRest.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(restrictionsLayer);
            } else {
                map.removeLayer(restrictionsLayer);
            }
            updateLegendVisibility();
        });
    }

    // Toggle pour la qualit√© d'eau
    const toggleQual = document.getElementById('toggleQualite');
    if (toggleQual) {
        if (toggleQual.checked && qualiteLayer) {
            map.addLayer(qualiteLayer);
        }
        toggleQual.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(qualiteLayer);
            } else {
                map.removeLayer(qualiteLayer);
            }
            updateLegendVisibility();
        });
    }

    // Toggle pour la flore/hydrobiologie
    const toggleFlo = document.getElementById('toggleFlore');
    if (toggleFlo) {
        if (toggleFlo.checked && floraLayer) {
            map.addLayer(floraLayer);
        }
        toggleFlo.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(floraLayer);
            } else {
                map.removeLayer(floraLayer);
            }
            updateLegendVisibility();
        });
    }

    // Toggle pour les obstacles √† l'√©coulement
    const toggleObs = document.getElementById('toggleObstacles');
    if (toggleObs) {
        if (toggleObs.checked && obstaclesLayer) {
            map.addLayer(obstaclesLayer);
        }
        toggleObs.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(obstaclesLayer);
            } else {
                map.removeLayer(obstaclesLayer);
            }
            updateLegendVisibility();
        });
    }
    
    // Ajouter les √©v√©nements pour les nouveaux toggles
    const toggleBassins = document.getElementById('toggleBassins');
    if (toggleBassins) {
        if (toggleBassins.checked && bassinsLayer) {
            map.addLayer(bassinsLayer);
        }
        toggleBassins.addEventListener('change', (e) => {
            if (e.target.checked) {
                if (bassinsLayer) map.addLayer(bassinsLayer);
            } else {
                if (bassinsLayer) map.removeLayer(bassinsLayer);
            }
            updateLegendVisibility();
        });
    }
    
    const toggleMassesEau = document.getElementById('toggleMassesEau');
    if (toggleMassesEau) {
        if (toggleMassesEau.checked && massesEauLayer) {
            map.addLayer(massesEauLayer);
        }
        toggleMassesEau.addEventListener('change', async (e) => {
            if (e.target.checked) {
                await loadMassesEau(selectedDept);
                if (massesEauLayer) map.addLayer(massesEauLayer);
            } else {
                if (massesEauLayer) map.removeLayer(massesEauLayer);
            }
            updateLegendVisibility();
        });
    }

    const toggleZonesHumides = document.getElementById('toggleZonesHumides');
    if (toggleZonesHumides) {
        if (toggleZonesHumides.checked && zonesHumidesLayer) {
            map.addLayer(zonesHumidesLayer);
        }
        toggleZonesHumides.addEventListener('change', (e) => {
            if (e.target.checked) {
                if (zonesHumidesLayer) map.addLayer(zonesHumidesLayer);
            } else {
                if (zonesHumidesLayer) map.removeLayer(zonesHumidesLayer);
            }
            updateLegendVisibility();
        });
    }

    // Gestionnaire pour les Hydro-√©cor√©gions (HER) - couverture nationale
    const toggleHER = document.getElementById('toggleHER');
    if (toggleHER) {
        if (toggleHER.checked && herLayer) {
            map.addLayer(herLayer);
        }
        toggleHER.addEventListener('change', (e) => {
            if (e.target.checked) {
                if (herLayer) map.addLayer(herLayer);
            } else {
                if (herLayer) map.removeLayer(herLayer);
            }
            updateLegendVisibility();
        });
    }

    // Gestionnaire pour les zones SAGE - couverture nationale
    const toggleSAGE = document.getElementById('toggleSAGE');
    if (toggleSAGE) {
        if (toggleSAGE.checked && sageLayer) {
            map.addLayer(sageLayer);
        }
        toggleSAGE.addEventListener('change', (e) => {
            if (e.target.checked) {
                if (sageLayer) map.addLayer(sageLayer);
            } else {
                if (sageLayer) map.removeLayer(sageLayer);
            }
            updateLegendVisibility();
        });
    }
    // Initialiser la l√©gende dynamique en fonction de l‚Äô√©tat initial des commutateurs
    updateLegendVisibility();
}

        /**
         * Renvoie une couleur selon la hauteur d'un obstacle.  
         * Les obstacles de petite hauteur (<0.5 m) sont verts, ceux de hauteur interm√©diaire (0.5‚Äì2 m) sont orange et les plus hauts (>2 m) sont rouges.  
         * Lorsque la hauteur est absente ou invalide, une teinte neutre est utilis√©e.
         * @param {number|string} height Hauteur de chute en m√®tres
         * @returns {string} Couleur hexad√©cimale
         */
        function getObstacleColor(height) {
            const h = parseFloat(height);
            if (isNaN(h)) return '#6b7280';
            if (h < 0.5) return '#22c55e';
            if (h < 2) return '#f59e0b';
            return '#ef4444';
        }

        /**
         * Charge dynamiquement la liste des d√©partements depuis geo.api.gouv.fr et la
         * renseigne dans le s√©lecteur HTML.  Si la requ√™te √©choue (probl√®mes r√©seau
         * ou politique de m√™me origine), une liste de codes courants est ajout√©e en
         * secours.  Le champ selectedDept est utilis√© pour s√©lectionner la valeur
         * par d√©faut.
         */
        async function populateDepartments() {
            try {
                const res = await fetch('https://geo.api.gouv.fr/departements?fields=code,nom');
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const depts = await res.json();
                const select = document.getElementById('deptSelect');
                if (!select) return;
                // Supprimer les anciennes options (sauf la premi√®re "Choisir")
                select.querySelectorAll('option:not([value=""])').forEach(opt => opt.remove());
                depts.sort((a,b) => a.code.localeCompare(b.code)).forEach(dep => {
                    const opt = document.createElement('option');
                    opt.value = dep.code;
                    opt.textContent = `${dep.code} - ${dep.nom}`;
                    select.appendChild(opt);
                });
                // S√©lectionner la valeur actuelle
                select.value = selectedDept;
            } catch (err) {
                console.error('Erreur chargement d√©partements :', err);
                // En secours, ajouter quelques codes manuels si le s√©lecteur est vide
                const select = document.getElementById('deptSelect');
                if (select && select.querySelectorAll('option').length <= 1) {
                    ['01','02','03','10','11','12','13','14','15','16','17','18','19','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50','51','52','53','54','55','56','57','58','59','60','61','62','63','64','65','66','67','68','69','70','71','72','73','74','75','76','77','78','79','80','81','82','83','84','85','86','87','88','89','90','91','92','93','94','95'].forEach(code => {
                        const opt = document.createElement('option');
                        opt.value = code;
                        opt.textContent = code;
                        select.appendChild(opt);
                    });
                    select.value = selectedDept;
                }
            }
        }



        async function updateDashboard() {
            const filteredData = getFilteredData();
            if (filteredData.length === 0) {
                showStatus('Aucune donn√©es avec ces filtres.', 'error');
                document.getElementById('dashboard').style.display = 'none';
                document.querySelector('#trendTable tbody').innerHTML = `<tr><td colspan="8" class="p-3 text-center border">Aucune donn√©es disponible pour les filtres s√©lectionn√©s.</td></tr>`;
                document.querySelector('#variationTable tbody').innerHTML = `<tr><td colspan="3" class="p-3 text-center border">Aucune donn√©es disponible.</td></tr>`;
                document.querySelector('#degradedTable tbody').innerHTML = `<tr><td colspan="3" class="p-3 text-center border">Aucune donn√©es disponible.</td></tr>`;
                const analysisPanel = document.getElementById('analysis-section');
                if (analysisPanel) analysisPanel.style.display = 'none';
                return;
            }
            document.getElementById('dashboard').style.display = 'block';
            updateSummaryStats(filteredData);
            updateCharts(filteredData);
            await updateTrendTable();
            updateVariationTable(filteredData);
            updateDegradedTable(filteredData);
            updateMapAndWeather();
            // Redimensionner les graphiques apr√®s la mise √† jour pour √©viter un affichage miniature
            setTimeout(() => {
                if (typeof charts !== 'undefined') {
                    Object.keys(charts).forEach(key => {
                        const ch = charts[key];
                        if (ch && typeof ch.resize === 'function') {
                            ch.resize();
                        }
                    });
                }
            }, 100);
            // La section d'analyse spatio‚Äëtemporelle est d√©sormais accessible via un modal.
            // Les graphiques et calculs seront mis √† jour lors de l'ouverture du modal
            // pour √©viter un recalcul inutile √† chaque mise √† jour du tableau de bord.
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Charger la liste des d√©partements et initialiser la valeur par d√©faut
            populateDepartments();
            const deptSelect = document.getElementById('deptSelect');
            if (deptSelect) {
                // Pr√©selectionner le d√©partement par d√©faut
                deptSelect.value = selectedDept;
                // Mettre √† jour la variable globale lorsqu'un d√©partement est choisi
                deptSelect.addEventListener('change', (e) => {
                    const newDept = e.target.value || selectedDept;
                    // Si le d√©partement change, mettre √† jour et recharger les donn√©es
                    if (newDept !== selectedDept) {
                        selectedDept = newDept;
                        // Recharger toutes les donn√©es ONDE et mettre √† jour le tableau de bord et la carte
                        loadDataFromONDE();
                        // Mettre √† jour les obstacles selon le nouveau d√©partement avec donn√©es Sandre WFS
                        updateObstaclesLayer().catch(error => console.error('Erreur mise √† jour obstacles d√©partement:', error));
                    }
                });
            }

            // Le chargement de fichier Excel est remplac√© par l'API ONDE.
            // Si un √©l√©ment 'excelFile' existe encore dans le DOM (ancien code), on ignore son √©v√©nement.
            document.getElementById('stationSelect').addEventListener('change', updateDashboard);
            document.getElementById('modalitySelect').addEventListener('change', updateDashboard);
            document.getElementById('yearSelect').addEventListener('change', updateDashboard);
            document.getElementById('includeWeather').addEventListener('change', (e) => {
                includeWeather = e.target.checked;
                updateDashboard();
            });
            document.getElementById('toggleSensitive').addEventListener('click', () => {
                sensitiveMode = !sensitiveMode;
                document.getElementById('toggleSensitive').textContent = sensitiveMode ? 'Revenir au Mode Normal' : 'Afficher Stations Sensibles';
                updateMapAndWeather();
            });
            // L'√©couteur pour l'analyse IA a √©t√© retir√© avec la suppression de ce bouton.
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                document.documentElement.classList.toggle('dark', e.matches);
                updateCharts(getFilteredData());
            });
            // Add event for opening the explicative modal
            document.getElementById('openExplicativeModal').addEventListener('click', () => {
                document.getElementById('explicativeModal').style.display = 'block';
            });
            // √âcouteur pour ouvrir le modal d'analyse spatio‚Äëtemporelle et multi‚Äëparam√®tres
            const analysisBtn = document.getElementById('openAnalysisModal');
            if (analysisBtn) {
                analysisBtn.addEventListener('click', () => {
                    // Afficher d'abord le modal afin que les √©l√©ments aient une taille
                    const modalEl = document.getElementById('analysisModal');
                    if (modalEl) modalEl.style.display = 'block';
                    // Mettre √† jour le contenu analytique ensuite
                    if (typeof updateAnalysisPanel === 'function') {
                        updateAnalysisPanel();
                    }
                    // Apr√®s un court d√©lai, ajuster la taille des graphiques et de la carte pour √©viter un rendu miniature
                    setTimeout(() => {
                        // Redimensionner toutes les instances ECharts pour occuper toute la largeur disponible
                        if (typeof charts !== 'undefined') {
                            Object.keys(charts).forEach(key => {
                                const ch = charts[key];
                                if (ch && typeof ch.resize === 'function') {
                                    ch.resize();
                                }
                            });
                        }
                        // Aucune carte sensible n‚Äôest utilis√©e ; aucune invalidation √† effectuer.
                    }, 300);
                });
            }

            // Redimensionner les graphiques lors du redimensionnement de la fen√™tre
            window.addEventListener('resize', () => {
                if (typeof charts !== 'undefined') {
                    Object.keys(charts).forEach(key => {
                        const ch = charts[key];
                        if (ch && typeof ch.resize === 'function') {
                            ch.resize();
                        }
                    });
                }
            });
            // √âcouteur pour fermer le modal d'analyse
            const closeAnalysisBtn = document.getElementById('closeAnalysisModal');
            if (closeAnalysisBtn) {
                closeAnalysisBtn.addEventListener('click', () => {
                    document.getElementById('analysisModal').style.display = 'none';
                });
            }
            // Fermer le modal lorsque l'utilisateur clique √† l'ext√©rieur de la zone de contenu
            window.addEventListener('click', event => {
                const modal = document.getElementById('analysisModal');
                if (modal && event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        });
    </script>
    
    <!-- Script pour le mode plein √©cran et t√©l√©chargement de carte -->
    <script>
        // Fonctions pour le mode plein √©cran et t√©l√©chargement de carte
        window.toggleFullscreen = function() {
            const mapContainer = document.getElementById('map-container');
            const controlsOverlay = document.getElementById('map-controls-overlay');
            const fullscreenBtn = document.querySelector('.fullscreen-btn');
            const exitBtn = document.querySelector('.exit-fullscreen-btn');
            
            if (mapContainer) mapContainer.classList.add('fullscreen-map');
            if (controlsOverlay) controlsOverlay.classList.add('show');
            if (fullscreenBtn) fullscreenBtn.style.display = 'none';
            if (exitBtn) exitBtn.style.display = 'flex';
            
            // Synchroniser les √©tats des contr√¥les avec les boutons principaux
            syncLayerControls();
            
            // Redimensionner la carte
            setTimeout(() => {
                if (window.map) {
                    window.map.invalidateSize();
                }
            }, 100);
        };
        
        window.exitFullscreen = function() {
            const mapContainer = document.getElementById('map-container');
            const controlsOverlay = document.getElementById('map-controls-overlay');
            const fullscreenBtn = document.querySelector('.fullscreen-btn');
            const exitBtn = document.querySelector('.exit-fullscreen-btn');
            
            if (mapContainer) mapContainer.classList.remove('fullscreen-map');
            if (controlsOverlay) controlsOverlay.classList.remove('show');
            if (fullscreenBtn) fullscreenBtn.style.display = 'flex';
            if (exitBtn) exitBtn.style.display = 'none';
            
            // Redimensionner la carte
            setTimeout(() => {
                if (window.map) {
                    window.map.invalidateSize();
                }
            }, 100);
        };
        
        // Synchroniser les contr√¥les de couches
        function syncLayerControls() {
            const togglePairs = [
                ['toggleEcoulement', 'fs-ecoulement-toggle'],
                ['toggleDebits', 'fs-debits-toggle'],
                ['toggleNappes', 'fs-nappes-toggle'],
                ['togglePrelevements', 'fs-prelevements-toggle'],
                ['toggleRestrictions', 'fs-restrictions-toggle'],
                ['toggleQualite', 'fs-qualite-toggle'],
                ['toggleFlore', 'fs-flore-toggle'],
                ['toggleObstacles', 'fs-obstacles-toggle'],
                ['toggleBassins', 'fs-bassins-toggle'],
                ['toggleMassesEau', 'fs-masses-toggle'],
                ['toggleZonesHumides', 'fs-zones-toggle'],
                ['toggleHER', 'fs-her-toggle'],
                ['toggleSAGE', 'fs-sage-toggle']
            ];
            
            togglePairs.forEach(([mainId, fsId]) => {
                const mainToggle = document.getElementById(mainId);
                const fsToggle = document.getElementById(fsId);
                if (mainToggle && fsToggle) {
                    fsToggle.checked = mainToggle.checked;
                }
            });
        }
        
        // Fonctions de contr√¥le des couches depuis le mode plein √©cran
        window.toggleEcoulementFromFullscreen = function() {
            const toggle = document.getElementById('toggleEcoulement');
            const fsToggle = document.getElementById('fs-ecoulement-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleDebitsFromFullscreen = function() {
            const toggle = document.getElementById('toggleDebits');
            const fsToggle = document.getElementById('fs-debits-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleNappesFromFullscreen = function() {
            const toggle = document.getElementById('toggleNappes');
            const fsToggle = document.getElementById('fs-nappes-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.togglePrelevementsFromFullscreen = function() {
            const toggle = document.getElementById('togglePrelevements');
            const fsToggle = document.getElementById('fs-prelevements-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleRestrictionsFromFullscreen = function() {
            const toggle = document.getElementById('toggleRestrictions');
            const fsToggle = document.getElementById('fs-restrictions-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleQualiteFromFullscreen = function() {
            const toggle = document.getElementById('toggleQualite');
            const fsToggle = document.getElementById('fs-qualite-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleFloreFromFullscreen = function() {
            const toggle = document.getElementById('toggleFlore');
            const fsToggle = document.getElementById('fs-flore-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleObstaclesFromFullscreen = function() {
            const toggle = document.getElementById('toggleObstacles');
            const fsToggle = document.getElementById('fs-obstacles-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleBassinsFromFullscreen = function() {
            const toggle = document.getElementById('toggleBassins');
            const fsToggle = document.getElementById('fs-bassins-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleMassesFromFullscreen = function() {
            const toggle = document.getElementById('toggleMassesEau');
            const fsToggle = document.getElementById('fs-masses-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleZonesFromFullscreen = function() {
            const toggle = document.getElementById('toggleZonesHumides');
            const fsToggle = document.getElementById('fs-zones-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleHerFromFullscreen = function() {
            const toggle = document.getElementById('toggleHER');
            const fsToggle = document.getElementById('fs-her-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        window.toggleSageFromFullscreen = function() {
            const toggle = document.getElementById('toggleSAGE');
            const fsToggle = document.getElementById('fs-sage-toggle');
            if (toggle && fsToggle) {
                toggle.checked = fsToggle.checked;
                toggle.dispatchEvent(new Event('change'));
            }
        };
        
        // Fonction de t√©l√©chargement de carte
        window.downloadMap = function() {
            if (!window.map) {
                alert('La carte n\'est pas encore charg√©e');
                return;
            }
            
            const mapElement = document.getElementById('map-container');
            const controlBtns = mapElement.querySelectorAll('.map-control-btn');
            const controlsOverlay = document.getElementById('map-controls-overlay');
            
            // Masquer temporairement les boutons pour la capture
            controlBtns.forEach(btn => btn.style.display = 'none');
            if (controlsOverlay) controlsOverlay.style.display = 'none';
            
            // Capturer la carte avec html2canvas
            html2canvas(mapElement, {
                useCORS: true,
                allowTaint: true,
                scale: 2,
                width: mapElement.offsetWidth,
                height: mapElement.offsetHeight
            }).then(canvas => {
                // Restaurer les boutons
                controlBtns.forEach(btn => btn.style.display = 'flex');
                if (controlsOverlay && controlsOverlay.classList.contains('show')) {
                    controlsOverlay.style.display = 'block';
                }
                
                // T√©l√©charger l'image
                const link = document.createElement('a');
                link.download = 'carte_OFB_' + new Date().toISOString().split('T')[0] + '.png';
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }).catch(error => {
                console.error('Erreur capture carte:', error);
                alert('Erreur lors du t√©l√©chargement de la carte');
                
                // Restaurer les boutons en cas d'erreur
                controlBtns.forEach(btn => btn.style.display = 'flex');
                if (controlsOverlay && controlsOverlay.classList.contains('show')) {
                    controlsOverlay.style.display = 'block';
                }
            });
        };
        
        // √âchapper du mode plein √©cran avec √âchap
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const mapContainer = document.getElementById('map-container');
                if (mapContainer && mapContainer.classList.contains('fullscreen-map')) {
                    exitFullscreen();
                }
            }
        });

        // Fonction pour g√©rer l'ouverture des arr√™t√©s avec gestion d'erreur
        window.ouvrirArrete = function(url, nomZone) {
            if (!url || url === 'aucun' || url === 'null' || url.trim() === '') {
                alert('Aucun arr√™t√© disponible pour cette zone de restriction.');
                return;
            }
            
            // Tentative d'ouverture du lien
            try {
                const newWindow = window.open(url, '_blank');
                
                // V√©rifier si le popup a √©t√© bloqu√©
                if (!newWindow) {
                    throw new Error('Popup bloqu√© par le navigateur');
                }
                
                // D√©lai pour v√©rifier si la page s'est bien charg√©e
                setTimeout(() => {
                    try {
                        // Test basique pour voir si la page est accessible
                        if (newWindow.closed) {
                            return; // L'utilisateur a ferm√© la fen√™tre
                        }
                        
                        // V√©rifier si l'URL est toujours about:blank apr√®s un d√©lai
                        if (newWindow.location.href === 'about:blank') {
                            throw new Error('Page non accessible');
                        }
                    } catch (e) {
                        // Erreur d'acc√®s (CORS ou page inaccessible)
                        const message = `Le lien de l'arr√™t√© semble inaccessible pour "${nomZone}".\n\nRaisons possibles:\n- Lien temporairement indisponible\n- Authentification requise\n- Lien d√©plac√© ou supprim√©\n\nVoulez-vous copier le lien pour l'ouvrir manuellement ?`;
                        
                        if (confirm(message)) {
                            // Copier le lien dans le presse-papier
                            if (navigator.clipboard) {
                                navigator.clipboard.writeText(url).then(() => {
                                    alert('Lien copi√© dans le presse-papier !\n\nVous pouvez maintenant le coller dans votre navigateur.');
                                }).catch(() => {
                                    // Fallback pour navigateurs anciens
                                    promptForManualCopy(url);
                                });
                            } else {
                                promptForManualCopy(url);
                            }
                        }
                    }
                }, 2000);
                
            } catch (error) {
                alert(`Impossible d'ouvrir le lien: ${error.message}\n\nLien: ${url}\n\nVeuillez copier ce lien et l'ouvrir manuellement dans votre navigateur.`);
            }
        };

        function promptForManualCopy(url) {
            const message = `Voici le lien √† copier manuellement:\n\n${url}`;
            alert(message);
        }
    </script>
    <!-- Modal d'Analyse spatio‚Äëtemporelle et multi‚Äëparam√®tres -->
    <div id="analysisModal" style="display:none; position: fixed; z-index:60; left:0; top:0; width:100%; height:100%; overflow:auto; background-color: rgba(0,0,0,0.4);">
      <div class="modal-content dark:bg-gray-800 dark:text-gray-200" style="background-color:#ffffff; margin:3% auto; padding:24px; border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,0.15); width:95%; max-width:1600px; max-height:90vh; overflow-y:auto;">
        <span id="closeAnalysisModal" class="cursor-pointer float-right text-2xl">√ó</span>
        <h3 class="text-xl font-semibold mb-4">Analyse spatio‚Äëtemporelle et multi‚Äëparam√®tres</h3>
        <p class="text-sm text-gray-600 dark:text-gray-300 mb-4">
          Cette analyse approfondie croise les informations spatiales et temporelles des stations s√©lectionn√©es afin de mettre en √©vidence les corr√©lations entre les √©coulements, les pr√©l√®vements, les niveaux de nappes, les pr√©cipitations, la temp√©rature et les restrictions. Les indices et graphiques facilitent l‚Äôidentification des zones sensibles et la compr√©hension des ph√©nom√®nes observ√©s.
        </p>
        <div id="analysis-section" class="p-4">
          <div class="mb-6">
            <h4 class="text-lg font-semibold mb-2">Stations √† faible √©coulement r√©current</h4>
            <p class="text-sm mb-2 text-gray-500 dark:text-gray-400">Cette liste recense les stations qui pr√©sentent des √©pisodes r√©p√©t√©s de faible √©coulement, indiquant des zones susceptibles d'√™tre en tension hydrique.</p>
            <ul id="recurringLowFlowList" class="list-disc pl-5 text-sm text-gray-800 dark:text-gray-200"></ul>
          </div>
          <div class="mb-6">
            <h4 class="text-lg font-semibold mb-2">Corr√©lation Variation / D√©grad√©</h4>
            <p class="text-sm mb-2 text-gray-500 dark:text-gray-400">Ce nuage de points met en relation la variation du poids moyen des modalit√©s et la proportion de modalit√©s d√©grad√©es. Il permet d‚Äôappr√©cier l‚Äôinfluence des variations sur la d√©gradation et de rep√©rer les comportements atypiques.</p>
            <div id="degradeCorrelationChart" class="chart-container" style="height:400px; width:100%;"></div>
          </div>
          <div class="mb-6">
            <h4 class="text-lg font-semibold mb-2">R√©sum√© analytique</h4>
            <p id="analysisSummary" class="text-sm text-gray-700 dark:text-gray-300"></p>
          </div>
          <div class="mb-6">
            <h4 class="text-lg font-semibold mb-2">Corr√©lations multivari√©es</h4>
            <p class="text-sm mb-2 text-gray-500 dark:text-gray-400">Cette carte de chaleur montre la corr√©lation lin√©aire entre chaque couple de variables (variation, d√©grad√©, pluviom√©trie, temp√©rature, pr√©l√®vement, niveau de nappe, d√©bit, restrictions, etc.). Une valeur proche de 1 indique une relation positive forte tandis qu‚Äôune valeur proche de -1 signale une relation inverse. Les cases neutres (pr√®s de 0) traduisent l‚Äôabsence de relation lin√©aire.</p>
            <div id="corrMatrixChart" class="chart-container" style="height:420px; width:100%;"></div>
          </div>
          <div class="mb-6">
            <h4 class="text-lg font-semibold mb-2">Indice de sensibilit√© et clustering</h4>
            <p class="text-sm mb-2 text-gray-500 dark:text-gray-400">L‚Äôindice de sensibilit√© synth√©tise plusieurs facteurs pour chaque station et permet de classer les risques de mani√®re simple (faible, moyen ou √©lev√©). Le clustering regroupe les stations selon leurs comportements similaires. Les stations apparaissant dans le groupe √† risque √©lev√© doivent faire l‚Äôobjet d‚Äôune attention particuli√®re.</p>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
              <div>
                <div id="riskChart" class="chart-container" style="height:400px; width:100%;"></div>
                <ul id="riskList" class="list-disc pl-5 text-sm text-gray-800 dark:text-gray-200 mt-2"></ul>
              </div>
              <div>
                <div id="clusterChart" class="chart-container" style="height:400px; width:100%;"></div>
              </div>
            </div>
          </div>
          <div class="mb-6">
            <h4 class="text-lg font-semibold mb-2">Conclusion g√©n√©rale</h4>
            <p id="analysisConclusion" class="text-sm text-gray-700 dark:text-gray-300"></p>
          </div>
          <!-- Bouton d'export Word pour l'analyse spatio-temporelle -->
          <div class="mb-8 text-right">
            <button onclick="exportToWordRisk()" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-all" data-tooltip="Exporter l'analyse en Word">Exporter au format Word</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Modal ASPE Complet et Fonctionnel -->
<div id="aspeModal" style="display:none; position: fixed; z-index:99999; left:0; top:0; width:100%; height:100%; overflow:auto; background-color: rgba(0,0,0,0.8);">
  <div style="background-color:#ffffff; margin:1% auto; padding:25px; border-radius:15px; width:98%; max-width:1500px; max-height:95vh; overflow-y:auto; box-shadow: 0 8px 32px rgba(0,0,0,0.5); border: 3px solid #3b82f6;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #e5e7eb; padding-bottom: 15px;">
      <h2 style="font-size: 24px; font-weight: bold; color: #1f2937;">üêü Analyse Piscicole ASPE - Hub'Eau Officiel</h2>
      <span onclick="closeAspeModal()" style="cursor: pointer; font-size: 28px; color: #6b7280; font-weight: bold;">&times;</span>
    </div>
    
    <div style="margin-bottom: 20px;">
      <div style="background-color: #f9fafb; padding: 15px; border-radius: 8px; border: 1px solid #e5e7eb;">
        <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 15px; color: #374151;">üìç Stations ASPE Authentiques</h3>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 15px;">
          <div style="display: flex; align-items: center; gap: 10px;">
            <span style="color: #6b7280; font-size: 14px;">D√©partement:</span>
            <select id="departmentSelector" onchange="filterByDepartment()" style="padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 14px; background: white; color: #374151;">
              <option value="">Tous les d√©partements</option>
              <option value="01">01 - Ain</option>
              <option value="02">02 - Aisne</option>
              <option value="03">03 - Allier</option>
              <option value="04">04 - Alpes-de-Haute-Provence</option>
              <option value="05">05 - Hautes-Alpes</option>
              <option value="06">06 - Alpes-Maritimes</option>
              <option value="07">07 - Ard√®che</option>
              <option value="08">08 - Ardennes</option>
              <option value="09">09 - Ari√®ge</option>
              <option value="10">10 - Aube</option>
              <option value="11">11 - Aude</option>
              <option value="12">12 - Aveyron</option>
              <option value="13">13 - Bouches-du-Rh√¥ne</option>
              <option value="14">14 - Calvados</option>
              <option value="15">15 - Cantal</option>
              <option value="16">16 - Charente</option>
              <option value="17">17 - Charente-Maritime</option>
              <option value="18">18 - Cher</option>
              <option value="19">19 - Corr√®ze</option>
              <option value="21">21 - C√¥te-d'Or</option>
              <option value="22">22 - C√¥tes-d'Armor</option>
              <option value="23">23 - Creuse</option>
              <option value="24">24 - Dordogne</option>
              <option value="25">25 - Doubs</option>
              <option value="26">26 - Dr√¥me</option>
              <option value="27">27 - Eure</option>
              <option value="28">28 - Eure-et-Loir</option>
              <option value="29">29 - Finist√®re</option>
              <option value="30">30 - Gard</option>
              <option value="31">31 - Haute-Garonne</option>
              <option value="32">32 - Gers</option>
              <option value="33">33 - Gironde</option>
              <option value="34">34 - H√©rault</option>
              <option value="35">35 - Ille-et-Vilaine</option>
              <option value="36">36 - Indre</option>
              <option value="37">37 - Indre-et-Loire</option>
              <option value="38">38 - Is√®re</option>
              <option value="39">39 - Jura</option>
              <option value="40" selected>40 - Landes</option>
              <option value="41">41 - Loir-et-Cher</option>
              <option value="42">42 - Loire</option>
              <option value="43">43 - Haute-Loire</option>
              <option value="44">44 - Loire-Atlantique</option>
              <option value="45">45 - Loiret</option>
              <option value="46">46 - Lot</option>
              <option value="47">47 - Lot-et-Garonne</option>
              <option value="48">48 - Loz√®re</option>
              <option value="49">49 - Maine-et-Loire</option>
              <option value="50">50 - Manche</option>
              <option value="51">51 - Marne</option>
              <option value="52">52 - Haute-Marne</option>
              <option value="53">53 - Mayenne</option>
              <option value="54">54 - Meurthe-et-Moselle</option>
              <option value="55">55 - Meuse</option>
              <option value="56">56 - Morbihan</option>
              <option value="57">57 - Moselle</option>
              <option value="58">58 - Ni√®vre</option>
              <option value="59">59 - Nord</option>
              <option value="60">60 - Oise</option>
              <option value="61">61 - Orne</option>
              <option value="62">62 - Pas-de-Calais</option>
              <option value="63">63 - Puy-de-D√¥me</option>
              <option value="64">64 - Pyr√©n√©es-Atlantiques</option>
              <option value="65">65 - Hautes-Pyr√©n√©es</option>
              <option value="66">66 - Pyr√©n√©es-Orientales</option>
              <option value="67">67 - Bas-Rhin</option>
              <option value="68">68 - Haut-Rhin</option>
              <option value="69">69 - Rh√¥ne</option>
              <option value="70">70 - Haute-Sa√¥ne</option>
              <option value="71">71 - Sa√¥ne-et-Loire</option>
              <option value="72">72 - Sarthe</option>
              <option value="73">73 - Savoie</option>
              <option value="74">74 - Haute-Savoie</option>
              <option value="75">75 - Paris</option>
              <option value="76">76 - Seine-Maritime</option>
              <option value="77">77 - Seine-et-Marne</option>
              <option value="78">78 - Yvelines</option>
              <option value="79">79 - Deux-S√®vres</option>
              <option value="80">80 - Somme</option>
              <option value="81">81 - Tarn</option>
              <option value="82">82 - Tarn-et-Garonne</option>
              <option value="83">83 - Var</option>
              <option value="84">84 - Vaucluse</option>
              <option value="85">85 - Vend√©e</option>
              <option value="86">86 - Vienne</option>
              <option value="87">87 - Haute-Vienne</option>
              <option value="88">88 - Vosges</option>
              <option value="89">89 - Yonne</option>
              <option value="90">90 - Territoire de Belfort</option>
              <option value="91">91 - Essonne</option>
              <option value="92">92 - Hauts-de-Seine</option>
              <option value="93">93 - Seine-Saint-Denis</option>
              <option value="94">94 - Val-de-Marne</option>
              <option value="95">95 - Val-d'Oise</option>
            </select>
          </div>
          <div style="display: flex; align-items: center; gap: 10px;">
            <div>
              <span style="color: #6b7280; font-size: 14px;">Stations: </span>
              <span id="aspeStationsCount" style="font-weight: bold; color: #3b82f6; font-size: 16px;">0</span>
            </div>
            <button onclick="loadAspeStations()" style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; padding: 8px 15px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 14px;">
              üì° Charger Stations
            </button>
          </div>
        </div>
        <div id="aspeMapContainer" style="height: 600px; width: 100%; border-radius: 8px; border: 2px solid #d1d5db; background-color: #f3f4f6; position: relative;">
          <div id="aspeMap" style="height: 100%; width: 100%; border-radius: 6px;"></div>
          <div id="aspeStationsList" style="display: none; height: 100%; width: 100%; overflow-y: auto; padding: 10px; background: #f9fafb; border-radius: 6px;">
            <div style="text-align: center; color: #6b7280; padding: 20px;">
              <div style="font-size: 24px; margin-bottom: 10px;">üó∫Ô∏è</div>
              <p>Chargez les stations pour voir la carte</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    


    <div style="background-color: #f0f9ff; padding: 20px; border-radius: 12px; border: 2px solid #0284c7; margin-bottom: 20px;">
      <h3 style="font-size: 20px; font-weight: 700; margin-bottom: 20px; color: #0c4a6e; text-align: center;">üìä ANALYSES ASPE AVANC√âES - TOUJOURS DISPONIBLES</h3>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
        <button onclick="executeAspeAnalysis('ipr')" style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; padding: 15px 12px; border: none; border-radius: 10px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">üìä √âvolution IPR</button>
        <button onclick="executeAspeAnalysis('species')" style="background: linear-gradient(135deg, #16a34a, #15803d); color: white; padding: 15px 12px; border: none; border-radius: 10px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">üêü √âvolution Esp√®ces</button>
        <button onclick="executeAspeAnalysis('geolocation')" style="background: linear-gradient(135deg, #9333ea, #7c3aed); color: white; padding: 15px 12px; border: none; border-radius: 10px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">üó∫Ô∏è G√©olocalisation</button>
        <button onclick="executeAspeAnalysis('physicochemistry')" style="background: linear-gradient(135deg, #ea580c, #dc2626); color: white; padding: 15px 12px; border: none; border-radius: 10px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">‚öóÔ∏è Physico-chimie</button>
        <button onclick="executeAspeAnalysis('biodiversity')" style="background: linear-gradient(135deg, #0d9488, #0f766e); color: white; padding: 15px 12px; border: none; border-radius: 10px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">üåø Biodiversit√©</button>
        <button onclick="executeAspeAnalysis('trends')" style="background: linear-gradient(135deg, #dc2626, #b91c1c); color: white; padding: 15px 12px; border: none; border-radius: 10px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">üìà Tendances</button>
      </div>
      <div style="background-color: #dbeafe; padding: 12px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #3b82f6;">
        <p style="font-size: 14px; color: #1e40af; margin: 0; font-weight: 500;">üí° Toutes les analyses utilisent des donn√©es authentiques Hub'Eau ASPE et fonctionnent sans s√©lection de station pr√©alable</p>
      </div>
    </div>
    
    <!-- Zone d'affichage des r√©sultats d'analyse ASPE -->
    <div id="aspeAnalysisResult" style="display: none; background: #f8fafc; padding: 20px; border-radius: 12px; border: 2px solid #e2e8f0; margin-top: 20px;">
      <!-- Les r√©sultats d'analyse s'afficheront ici -->
    </div>
  </div>
</div>

<script>
// Variables globales ASPE
window.aspeMap = null;
window.aspeStationsData = [];
window.aspeFilteredStationsData = []; // Stations filtr√©es par d√©partement
window.selectedAspeStation = null;
window.aspeStationsLayer = null;
window.currentDepartment = '40'; // D√©partement par d√©faut (Landes)

// Coordonn√©es centrales par d√©partement fran√ßais
window.departmentCoordinates = {
    '01': [46.2, 5.2], // Ain
    '02': [49.4, 3.4], // Aisne  
    '03': [46.3, 3.3], // Allier
    '04': [44.1, 6.2], // Alpes-de-Haute-Provence
    '05': [44.7, 6.5], // Hautes-Alpes
    '06': [43.7, 7.3], // Alpes-Maritimes
    '07': [44.8, 4.6], // Ard√®che
    '08': [49.8, 4.7], // Ardennes
    '09': [42.9, 1.6], // Ari√®ge
    '10': [48.3, 4.1], // Aube
    '11': [43.2, 2.4], // Aude
    '12': [44.4, 2.6], // Aveyron
    '13': [43.5, 5.4], // Bouches-du-Rh√¥ne
    '14': [49.2, -0.4], // Calvados
    '15': [45.0, 2.5], // Cantal
    '16': [45.7, 0.2], // Charente
    '17': [45.8, -0.8], // Charente-Maritime
    '18': [47.1, 2.4], // Cher
    '19': [45.3, 1.8], // Corr√®ze
    '21': [47.3, 5.0], // C√¥te-d'Or
    '22': [48.5, -2.8], // C√¥tes-d'Armor
    '23': [46.1, 2.1], // Creuse
    '24': [45.2, 0.7], // Dordogne
    '25': [47.2, 6.1], // Doubs
    '26': [44.7, 5.0], // Dr√¥me
    '27': [49.2, 0.9], // Eure
    '28': [48.4, 1.5], // Eure-et-Loir
    '29': [48.1, -4.1], // Finist√®re
    '30': [44.0, 4.4], // Gard
    '31': [43.6, 1.4], // Haute-Garonne
    '32': [43.7, 0.6], // Gers
    '33': [44.8, -0.6], // Gironde
    '34': [43.6, 3.9], // H√©rault
    '35': [48.1, -1.7], // Ille-et-Vilaine
    '36': [46.8, 1.7], // Indre
    '37': [47.4, 0.7], // Indre-et-Loire
    '38': [45.2, 5.7], // Is√®re
    '39': [46.7, 5.8], // Jura
    '40': [44.0, -0.8], // Landes
    '41': [47.6, 1.3], // Loir-et-Cher
    '42': [45.4, 4.4], // Loire
    '43': [45.0, 3.9], // Haute-Loire
    '44': [47.2, -1.6], // Loire-Atlantique
    '45': [47.9, 2.3], // Loiret
    '46': [44.4, 1.4], // Lot
    '47': [44.2, 0.6], // Lot-et-Garonne
    '48': [44.5, 3.5], // Loz√®re
    '49': [47.5, -0.9], // Maine-et-Loire
    '50': [49.1, -1.3], // Manche
    '51': [49.0, 4.0], // Marne
    '52': [48.1, 5.2], // Haute-Marne
    '53': [48.1, -0.8], // Mayenne
    '54': [48.7, 6.2], // Meurthe-et-Moselle
    '55': [49.2, 5.4], // Meuse
    '56': [47.7, -2.8], // Morbihan
    '57': [49.1, 6.7], // Moselle
    '58': [47.0, 3.5], // Ni√®vre
    '59': [50.6, 3.1], // Nord
    '60': [49.4, 2.5], // Oise
    '61': [48.6, 0.1], // Orne
    '62': [50.5, 2.8], // Pas-de-Calais
    '63': [45.8, 3.1], // Puy-de-D√¥me
    '64': [43.3, -0.7], // Pyr√©n√©es-Atlantiques
    '65': [43.2, 0.1], // Hautes-Pyr√©n√©es
    '66': [42.7, 2.9], // Pyr√©n√©es-Orientales
    '67': [48.6, 7.8], // Bas-Rhin
    '68': [47.8, 7.3], // Haut-Rhin
    '69': [45.8, 4.9], // Rh√¥ne
    '70': [47.6, 6.2], // Haute-Sa√¥ne
    '71': [46.8, 4.8], // Sa√¥ne-et-Loire
    '72': [48.0, 0.2], // Sarthe
    '73': [45.6, 6.4], // Savoie
    '74': [46.1, 6.1], // Haute-Savoie
    '75': [48.9, 2.3], // Paris
    '76': [49.4, 1.1], // Seine-Maritime
    '77': [48.5, 2.9], // Seine-et-Marne
    '78': [48.8, 2.0], // Yvelines
    '79': [46.3, -0.5], // Deux-S√®vres
    '80': [49.9, 2.3], // Somme
    '81': [43.9, 2.1], // Tarn
    '82': [44.0, 1.4], // Tarn-et-Garonne
    '83': [43.1, 6.1], // Var
    '84': [44.0, 5.1], // Vaucluse
    '85': [46.7, -1.4], // Vend√©e
    '86': [46.6, 0.3], // Vienne
    '87': [45.8, 1.3], // Haute-Vienne
    '88': [48.2, 6.5], // Vosges
    '89': [47.8, 3.6], // Yonne
    '90': [47.6, 6.9], // Territoire de Belfort
    '91': [48.6, 2.4], // Essonne
    '92': [48.8, 2.2], // Hauts-de-Seine
    '93': [48.9, 2.4], // Seine-Saint-Denis
    '94': [48.8, 2.5], // Val-de-Marne
    '95': [49.0, 2.1]  // Val-d'Oise
};

// Fonction pour ouvrir le modal ASPE
window.openAspeModal = function() {
    console.log("‚úÖ Modal ASPE ouvert");
    const modal = document.getElementById('aspeModal');
    if (modal) {
        // Forcer l'affichage avec un style plus agressif
        modal.style.display = 'block';
        modal.style.position = 'fixed';
        modal.style.zIndex = '99999';
        modal.style.left = '0';
        modal.style.top = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
        
        document.body.style.overflow = 'hidden';
        
        // Message de confirmation supprim√© pour une exp√©rience plus fluide
        
        setTimeout(function() {
            setupAspeInterface();
            // Forcer le redimensionnement de la carte si elle existe
            if (window.aspeMap) {
                setTimeout(function() {
                    window.aspeMap.invalidateSize();
                    console.log("üîÑ Carte ASPE redimensionn√©e apr√®s ouverture modal");
                }, 300);
            }
        }, 200);
    } else {
        console.error("‚ùå Modal ASPE non trouv√©");
        alert('‚ùå Erreur\n\nLe modal ASPE n\'a pas pu √™tre trouv√©.');
    }
};

// Configuration de l'interface ASPE avec carte Leaflet
window.setupAspeInterface = function() {
    console.log("üîß Configuration interface ASPE...");
    
    // Interface pr√™te pour la carte
    const mapContainer = document.getElementById('aspeMap');
    if (mapContainer) {
        mapContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: linear-gradient(135deg, #3b82f6, #1e40af); border-radius: 8px; color: white; text-align: center; flex-direction: column;">' +
            '<div style="font-size: 48px; margin-bottom: 15px;">üó∫Ô∏è</div>' +
            '<h4 style="margin: 0 0 8px 0; font-size: 16px; font-weight: bold;">Carte ASPE</h4>' +
            '<p style="margin: 0; font-size: 14px; opacity: 0.9;">Cliquez sur "Charger Stations" pour voir la carte interactive</p>' +
            '</div>';
    }
    
    // Mettre √† jour les d√©tails
    const stationDetails = document.getElementById('stationDetails');
    if (stationDetails) {
        stationDetails.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 60px 20px;">' +
            '<div style="font-size: 48px; margin-bottom: 15px;">üé£</div>' +
            '<h4 style="font-size: 16px; margin-bottom: 10px; color: #374151;">Analyse Piscicole ASPE</h4>' +
            '<p style="font-size: 14px; line-height: 1.5;">Chargez les stations puis cliquez sur une station de la carte pour voir les d√©tails</p>' +
            '</div>';
    }
    
    console.log("‚úÖ Interface ASPE configur√©e");
};

// Fonction pour fermer le modal ASPE
window.closeAspeModal = function() {
    const modal = document.getElementById('aspeModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto'; // Restaurer scroll
        console.log("Modal ASPE ferm√©");
    }
};

// Fonction pour initialiser la carte ASPE
window.initAspeMap = function() {
    console.log("üîÑ Tentative d'initialisation carte ASPE...");
    
    // V√©rifier que Leaflet est disponible
    if (typeof L === 'undefined') {
        console.error("‚ùå Leaflet non disponible, chargement depuis CDN...");
        // Charger Leaflet si pas disponible
        const leafletCSS = document.createElement('link');
        leafletCSS.rel = 'stylesheet';
        leafletCSS.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
        document.head.appendChild(leafletCSS);
        
        const leafletJS = document.createElement('script');
        leafletJS.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
        leafletJS.onload = function() {
            console.log("‚úÖ Leaflet charg√©, nouvelle tentative...");
            setTimeout(function() {
                initAspeMap();
            }, 500);
        };
        document.head.appendChild(leafletJS);
        return;
    }
    
    try {
        const mapContainer = document.getElementById('aspeMap');
        if (!mapContainer) {
            console.error("‚ùå Container carte ASPE non trouv√©");
            return;
        }
        
        console.log("üìç Container trouv√©, dimensions:", mapContainer.offsetWidth, "x", mapContainer.offsetHeight);
        
        // D√©truire la carte existante si elle existe
        if (window.aspeMap) {
            try {
                window.aspeMap.remove();
                console.log("üóëÔ∏è Carte existante supprim√©e");
            } catch (e) {
                console.log("‚ö†Ô∏è Erreur suppression carte:", e);
            }
            window.aspeMap = null;
        }
        
        // S'assurer que le container a des dimensions
        mapContainer.style.height = '100%';
        mapContainer.style.width = '100%';
        
        // Cr√©er la carte avec un d√©lai pour s'assurer que le container est visible
        setTimeout(function() {
            try {
                console.log("üó∫Ô∏è Cr√©ation de la carte Leaflet...");
                window.aspeMap = L.map('aspeMap', {
                    center: [44.5, 1.0],
                    zoom: 6,
                    zoomControl: true
                });
                
                // Ajouter les tuiles
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 18
                }).addTo(window.aspeMap);
                
                // Forcer le redimensionnement multiple pour assurer la taille correcte
                setTimeout(function() {
                    // Premi√®re tentative de redimensionnement
                    window.aspeMap.invalidateSize();
                    console.log("üîÑ Carte redimensionn√©e - Tentative 1");
                    
                    // Deuxi√®me tentative apr√®s un d√©lai suppl√©mentaire
                    setTimeout(function() {
                        window.aspeMap.invalidateSize(true);
                        console.log("üîÑ Carte redimensionn√©e - Tentative 2 (force reset)");
                        
                        // S'assurer que le conteneur de la carte prend toute la place
                        const mapDiv = document.querySelector('#aspeMap .leaflet-container');
                        if (mapDiv) {
                            mapDiv.style.height = '100%';
                            mapDiv.style.width = '100%';
                            console.log("üìê Dimensions Leaflet container forc√©es");
                        }
                    }, 300);
                }, 200);
                
                console.log("‚úÖ Carte ASPE initialis√©e avec succ√®s");
            } catch (error) {
                console.error("‚ùå Erreur cr√©ation carte ASPE:", error);
                // Fallback sans carte
                const mapContainer = document.getElementById('aspeMap');
                if (mapContainer) {
                    mapContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f3f4f6; border: 2px dashed #d1d5db; border-radius: 8px; color: #6b7280; text-align: center; flex-direction: column;"><div style="font-size: 48px; margin-bottom: 15px;">üó∫Ô∏è</div><h4 style="margin: 0 0 8px 0; font-size: 16px; color: #374151;">Carte indisponible</h4><p style="margin: 0; font-size: 14px;">La carte ne peut pas se charger.<br>Les stations seront affich√©es en liste.</p></div>';
                }
            }
        }, 300);
        
    } catch (error) {
        console.error("‚ùå Erreur initialisation carte ASPE:", error);
    }
};

// Fonction pour charger les stations ASPE
window.loadAspeStations = function() {
    console.log("üîÑ Chargement des stations ASPE...");
    
    // Affichage du loading
    const mapContainer = document.getElementById('aspeMap');
    const stationDetails = document.getElementById('stationDetails');
    
    if (mapContainer) {
        mapContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f3f4f6; border-radius: 6px; color: #3b82f6;"><div style="text-align: center;"><div style="font-size: 36px; margin-bottom: 10px;">‚è≥</div><p style="font-size: 14px;">Chargement des stations ASPE...</p></div></div>';
    }
    
    if (stationDetails) {
        stationDetails.innerHTML = '<div style="text-align: center; padding: 40px;"><div style="font-size: 36px; color: #3b82f6;">‚è≥</div><p style="color: #6b7280;">R√©cup√©ration des donn√©es authentiques...</p></div>';
    }
    
    // Utiliser l'endpoint serveur local qui r√©cup√®re les donn√©es Hub'Eau
    fetch('/api/aspe/stations')
        .then(response => {
            console.log('API ASPE - Statut:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(response => {
            console.log('üîç R√©ponse ASPE serveur:', response);
            
            // V√©rifier et traiter les donn√©es AUTHENTIQUES UNIQUEMENT
            if (!response.success || !response.data || !Array.isArray(response.data)) {
                throw new Error(response.error || 'Aucune donn√©e ASPE authentique disponible');
            }
            
            const stations = response.data;
            
            // Stocker les stations authentiques
            window.aspeStationsData = stations;
            
            console.log('‚úÖ Donn√©es ASPE AUTHENTIQUES re√ßues:', stations.length, 'stations depuis', response.source);
            
            // R√©cup√©rer le d√©partement s√©lectionn√© et filtrer imm√©diatement
            const selector = document.getElementById('departmentSelector');
            const selectedDept = selector ? selector.value : '40';
            
            console.log('üèõÔ∏è D√©partement s√©lectionn√© au chargement:', selectedDept || 'Tous');
            
            // Filtrer les stations selon le d√©partement
            let filteredStations;
            if (selectedDept === '') {
                // Tous les d√©partements
                filteredStations = stations;
            } else {
                // Le serveur nous envoie directement le code_departement dans les donn√©es
                // On filtre directement par ce champ au lieu d'utiliser les codes de station
                console.log('üîç Filtrage par code_departement direct:', selectedDept);
                
                // Filtrer directement par code_departement
                filteredStations = stations.filter(function(station) {
                    const stationDept = station.code_departement || station.departement || '';
                    const matches = stationDept.toString() === selectedDept;
                    if (matches) {
                        console.log('‚úÖ Station retenue:', station.code_station, station.libelle_station || station.nom, 'd√©partement:', stationDept);
                    }
                    return matches;
                });
            }
            
            window.aspeFilteredStationsData = filteredStations;
            
            console.log('üîç Stations filtr√©es:', filteredStations.length, 'sur', stations.length, 'pour d√©partement', selectedDept);
            
            // Mettre √† jour le compteur avec les stations filtr√©es
            const countElement = document.getElementById('aspeStationsCount');
            if (countElement) {
                countElement.textContent = filteredStations.length;
            }
            
            // Initialiser carte avec stations filtr√©es
            initializeAspeMapLikeMain(filteredStations);
        })
        .catch(error => {
            console.error('‚ùå Erreur d√©taill√©e ASPE:', error);
            showAspeError('Impossible de r√©cup√©rer les stations authentiques Hub\'Eau: ' + error.message);
        });
};

// Fonction pour initialiser carte ASPE identique √† la carte principale
window.initializeAspeMapLikeMain = function(stations) {
    console.log('üó∫Ô∏è Initialisation carte ASPE identique √† principale avec', stations.length, 'stations');
    
    const mapContainer = document.getElementById('aspeMap');
    if (!mapContainer) {
        console.error('‚ùå Container carte ASPE non trouv√©');
        return;
    }
    
    // Pr√©parer container comme carte principale
    mapContainer.innerHTML = '';
    mapContainer.style.height = '100%';
    mapContainer.style.width = '100%';
    mapContainer.style.position = 'relative';
    
    // Attendre stabilit√© du modal
    setTimeout(function() {
        try {
            // Nettoyer ancienne instance
            if (window.aspeMap) {
                window.aspeMap.remove();
                delete window.aspeMap;
            }
            
            // R√©cup√©rer le d√©partement actuellement s√©lectionn√©
            const selector = document.getElementById('departmentSelector');
            const currentDept = selector ? selector.value : '40';
            const defaultCoords = window.departmentCoordinates[currentDept] || [44.0, -0.8];
            
            console.log('üéØ Centrage carte ASPE sur d√©partement', currentDept, ':', defaultCoords);
            
            // Cr√©er carte centr√©e sur le d√©partement s√©lectionn√©
            window.aspeMap = L.map(mapContainer, {
                center: defaultCoords,
                zoom: 10,
                zoomControl: true,
                scrollWheelZoom: true,
                doubleClickZoom: true,
                dragging: true
            });
            
            // M√™mes tuiles que carte principale
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(window.aspeMap);
            
            console.log('‚úÖ Carte ASPE cr√©√©e (style principal)');
            
            // Redimensionner proprement avec v√©rifications multiples
            setTimeout(function() {
                // Premi√®re tentative de redimensionnement
                window.aspeMap.invalidateSize();
                console.log('‚úÖ Carte ASPE redimensionn√©e - Tentative 1');
                
                // Forcer les dimensions CSS du conteneur Leaflet
                const leafletContainer = mapContainer.querySelector('.leaflet-container');
                if (leafletContainer) {
                    leafletContainer.style.height = '100%';
                    leafletContainer.style.width = '100%';
                    console.log('üìê Dimensions Leaflet container forc√©es √† 100%');
                }
                
                // Deuxi√®me redimensionnement apr√®s ajustement CSS
                setTimeout(function() {
                    window.aspeMap.invalidateSize(true);
                    console.log('‚úÖ Carte ASPE redimensionn√©e - Tentative 2 (force)');
                    
                    // Ajouter marqueurs des stations re√ßues (d√©j√† filtr√©es)
                    addAspeStationsToMap(stations);
                }, 200);
                
            }, 200);
            
        } catch (error) {
            console.error('‚ùå Erreur carte ASPE:', error);
            showAspeMapError(error.message);
        }
    }, 800);
};

// SUPPRESSION DES DONN√âES SIMUL√âES - UTILISATION EXCLUSIVE DES DONN√âES AUTHENTIQUES
// Les donn√©es de test ont √©t√© supprim√©es pour respecter l'exigence d'authenticit√©

// Fonction pour ajouter stations √† la carte ASPE
window.addAspeStationsToMap = function(stations) {
    if (!window.aspeMap || !stations || !Array.isArray(stations)) {
        console.error('‚ùå Carte ou stations manquantes/invalides');
        return;
    }
    
    console.log('üìç Ajout de', stations.length, 'stations ASPE √† la carte');
    
    // Supprimer couche existante
    if (window.aspeStationsLayer) {
        window.aspeMap.removeLayer(window.aspeStationsLayer);
    }
    
    // Cr√©er groupe de marqueurs
    window.aspeStationsLayer = L.layerGroup();
    
    stations.forEach(function(station) {
        // Utiliser les coordonn√©es Hub'Eau (coordonnee_x = longitude, coordonnee_y = latitude)
        const lat = parseFloat(station.coordonnee_y) || parseFloat(station.latitude) || parseFloat(station.lat);
        const lon = parseFloat(station.coordonnee_x) || parseFloat(station.longitude) || parseFloat(station.lon);
        
        if (lat && lon && !isNaN(lat) && !isNaN(lon)) {
            console.log(`üìç Station ${station.code_station}: lat=${lat}, lon=${lon}`);
            
            // Marqueur style identique aux stations principales
            const marker = L.marker([lat, lon], {
                icon: L.divIcon({
                    className: 'custom-div-icon',
                    html: '<div style="background: #3b82f6; color: white; border-radius: 50%; width: 12px; height: 12px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                })
            });
            
            // Popup d√©taill√© avec donn√©es authentiques compl√®tes
            const stationName = station.libelle_station || station.libelle || station.nom || 'Station ASPE';
            const popupContent = '<div style="min-width: 280px; font-family: Arial, sans-serif;">' +
                '<div style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; padding: 12px; border-radius: 8px 8px 0 0; margin: -10px -10px 10px -10px;">' +
                '<h4 style="margin: 0; font-weight: bold; font-size: 15px; line-height: 1.3;">üé£ ' + stationName + '</h4>' +
                '<p style="margin: 4px 0 0 0; font-size: 11px; opacity: 0.9;">Station ASPE Authentique Hub\'Eau</p>' +
                '</div>' +
                
                '<div style="background: #f8fafc; padding: 10px; border-radius: 6px; margin-bottom: 10px; border: 1px solid #e2e8f0;">' +
                '<h5 style="margin: 0 0 6px 0; color: #1e40af; font-size: 12px; font-weight: bold;">üìç LOCALISATION</h5>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>Rivi√®re:</strong> ' + (station.libelle_cours_eau || station.riviere || station.cours_eau || 'Non sp√©cifi√©') + '</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>Commune:</strong> ' + (station.libelle_commune || station.commune || 'Non sp√©cifi√©e') + '</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>D√©partement:</strong> ' + (station.libelle_departement || station.departement || station.code_departement || 'Non sp√©cifi√©') + '</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>Bassin:</strong> ' + (station.libelle_bassin || station.bassin || station.bassin_hydrographique || 'Non sp√©cifi√©') + '</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>Coordonn√©es:</strong> ' + lat.toFixed(4) + ', ' + lon.toFixed(4) + '</p>' +
                '</div>' +
                
                '<div style="background: #f0fdf4; padding: 10px; border-radius: 6px; margin-bottom: 10px; border: 1px solid #bbf7d0;">' +
                '<h5 style="margin: 0 0 6px 0; color: #16a34a; font-size: 12px; font-weight: bold;">üî¨ DONN√âES TECHNIQUES</h5>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>Code Station:</strong> ' + (station.code_station || station.id) + '</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>Type Surveillance:</strong> Peuplement Piscicole</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>R√©seau:</strong> ASPE (Suivi des Peuplements)</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>Source:</strong> Hub\'Eau - OFB Authentique</p>' +
                (station.altitude ? '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;"><strong>Altitude:</strong> ' + station.altitude + 'm</p>' : '') +
                '</div>' +
                
                '<div style="background: #fefbf3; padding: 10px; border-radius: 6px; margin-bottom: 12px; border: 1px solid #fed7aa;">' +
                '<h5 style="margin: 0 0 6px 0; color: #ea580c; font-size: 12px; font-weight: bold;">üìä ANALYSES DISPONIBLES</h5>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;">‚Ä¢ √âvolution IPR (Indice Poisson Rivi√®re)</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;">‚Ä¢ √âvolution des esp√®ces piscicoles</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;">‚Ä¢ Param√®tres physico-chimiques</p>' +
                '<p style="margin: 2px 0; font-size: 11px; color: #4b5563;">‚Ä¢ Indices de biodiversit√©</p>' +
                '</div>' +
                
                '<button onclick="selectAspeStation(\'' + station.code_station + '\', \'' + (station.libelle_station || station.nom || 'Station ASPE').replace(/'/g, "\\'") + '\', \'' + (station.libelle_cours_eau || station.riviere || station.cours_eau || 'Cours d\'eau').replace(/'/g, "\\'") + '\')" ' +
                'style="width: 100%; padding: 10px 12px; background: linear-gradient(135deg, #16a34a, #15803d); color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">' +
                'üöÄ S√©lectionner et Analyser</button>' +
                '</div>';
            
            marker.bindPopup(popupContent);
            
            // √âv√©nement clic
            marker.on('click', function() {
                selectAspeStation(station.code_station, station.libelle_station, station.libelle_cours_eau);
            });
            
            window.aspeStationsLayer.addLayer(marker);
        } else {
            console.warn(`‚ö†Ô∏è Station ${station.code_station} sans coordonn√©es valides:`, {
                coordonnee_x: station.coordonnee_x,
                coordonnee_y: station.coordonnee_y,
                lat: station.lat,
                lon: station.lon
            });
        }
    });
    
    // Ajouter √† la carte
    window.aspeStationsLayer.addTo(window.aspeMap);
    
    // Ajuster vue pour voir toutes les stations
    if (stations.length > 0) {
        const bounds = [];
        stations.forEach(function(station) {
            const lat = parseFloat(station.coordonnee_y) || parseFloat(station.latitude) || parseFloat(station.lat);
            const lon = parseFloat(station.coordonnee_x) || parseFloat(station.longitude) || parseFloat(station.lon);
            
            if (lat && lon && !isNaN(lat) && !isNaN(lon)) {
                bounds.push([lat, lon]);
            }
        });
        
        if (bounds.length > 0) {
            window.aspeMap.fitBounds(bounds, { padding: [20, 20] });
        }
    }
    
    // Afficher message de succ√®s dans la console
    console.log('‚úÖ ' + stations.length + ' stations ASPE ajout√©es √† la carte avec succ√®s');
};

// Fonction d'erreur pour carte ASPE
window.showAspeMapError = function(message) {
    const mapContainer = document.getElementById('aspeMap');
    if (mapContainer) {
        mapContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #fee2e2; border-radius: 8px; color: #dc2626; text-align: center; flex-direction: column;">' +
            '<div style="font-size: 32px; margin-bottom: 10px;">‚ùå</div>' +
            '<h4 style="margin: 0 0 8px 0; font-size: 16px;">Erreur Carte ASPE</h4>' +
            '<p style="margin: 0; font-size: 14px;">' + message + '</p>' +
            '</div>';
    }
};

// Fonction pour traiter les stations ASPE
window.processAspeStations = function(stations) {
    console.log('üîç Traitement de', stations.length, 'stations ASPE authentiques');
    
    window.aspeStationsData = stations;
    
    // Appliquer le filtre d√©partemental actuel
    filterByDepartment();
    
    // Si pas de carte, afficher en liste  
    if (!window.aspeMap) {
        console.log('üìã Affichage en liste (pas de carte)');
        displayStationsAsList(window.aspeFilteredStationsData || stations);
        return;
    }
    
    console.log('‚úÖ ' + stations.length + ' stations ASPE authentiques trait√©es avec succ√®s');

};

// Fonction pour afficher en liste si pas de carte
window.displayStationsAsList = function(stations) {
    const mapContainer = document.getElementById('aspeMap');
    if (!mapContainer) return;
    
    let html = '<div style="padding: 15px; max-height: 400px; overflow-y: auto; background: white; border-radius: 8px;">';
    html += '<h4 style="margin: 0 0 15px 0; color: #374151; font-size: 16px; font-weight: bold;">üìã Stations ASPE Disponibles</h4>';
    
    stations.forEach(function(station, index) {
        html += '<div style="padding: 10px; margin-bottom: 8px; border: 1px solid #e5e7eb; border-radius: 6px; background: #f9fafb;">' +
            '<div style="font-weight: bold; color: #1f2937; margin-bottom: 4px; font-size: 14px;">' + station.nom + '</div>' +
            '<div style="font-size: 12px; color: #6b7280; margin-bottom: 6px;">' + station.riviere + ' - ' + station.commune + '</div>' +
            '<button onclick="selectAspeStation(\'' + station.id + '\', \'' + station.nom.replace(/'/g, "\\'") + '\', \'' + station.riviere.replace(/'/g, "\\'") + '\')" ' +
            'style="padding: 6px 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; font-size: 11px; cursor: pointer;">üìä S√©lectionner</button>' +
            '</div>';
    });
    
    html += '</div>';
    mapContainer.innerHTML = html;
    
    console.log('‚úÖ ' + stations.length + ' stations ASPE affich√©es en liste');
};

// Fonction pour s√©lectionner une station
window.selectAspeStation = function(stationId, stationName, riviere) {
    console.log('üéØ Station ASPE s√©lectionn√©e:', stationName);
    console.log('üîç Recherche station ID:', stationId);
    console.log('üìä Stations disponibles:', window.aspeStationsData ? window.aspeStationsData.length : 0);
    
    if (!window.aspeStationsData || !Array.isArray(window.aspeStationsData)) {
        console.error('‚ùå Donn√©es stations ASPE non disponibles');
        return;
    }
    
    // Recherche flexible par ID, code_station ou nom
    const stationData = window.aspeStationsData.find(function(s) {
        return s.id === stationId || 
               s.code_station === stationId || 
               s.nom === stationName ||
               s.libelle === stationName;
    });
    
    console.log('üéØ Station trouv√©e:', stationData ? 'OUI' : 'NON');
    
    if (!stationData) {
        console.error('Station non trouv√©e:', stationId);
        console.log('üîç Premi√®re station disponible:', window.aspeStationsData[0]);
        // Utiliser la premi√®re station disponible comme fallback
        if (window.aspeStationsData.length > 0) {
            const fallbackStation = window.aspeStationsData[0];
            console.log('‚ö° Utilisation station fallback:', fallbackStation.nom || fallbackStation.libelle);
            window.selectedAspeStation = {
                id: fallbackStation.id || fallbackStation.code_station,
                nom: fallbackStation.nom || fallbackStation.libelle || 'Station Hub\'Eau',
                riviere: fallbackStation.riviere || fallbackStation.cours_eau || 'Cours d\'eau',
                data: fallbackStation
            };
        }
        return;
    }
    
    window.selectedAspeStation = {
        id: stationId,
        nom: stationName,
        riviere: riviere,
        data: stationData
    };
    
    // Station s√©lectionn√©e - maintenant les d√©tails sont dans le popup de la carte
    console.log('‚úÖ Station ASPE s√©lectionn√©e:', stationName, 'sur', riviere);
};



// Fonction pour filtrer par d√©partement
window.filterByDepartment = function() {
    const selector = document.getElementById('departmentSelector');
    const selectedDept = selector.value;
    
    console.log('üèõÔ∏è Filtrage par d√©partement:', selectedDept || 'Tous');
    
    window.currentDepartment = selectedDept;
    
    if (!window.aspeStationsData || window.aspeStationsData.length === 0) {
        console.log('‚ö†Ô∏è Aucune station charg√©e - filtrage diff√©r√©');
        return;
    }
    
    // Filtrer les stations selon le d√©partement
    if (selectedDept === '') {
        // Tous les d√©partements
        window.aspeFilteredStationsData = [...window.aspeStationsData];
    } else {
        console.log('üîç Filtrage par code_departement direct:', selectedDept);
        
        // Filtrer directement par code_departement des stations
        window.aspeFilteredStationsData = window.aspeStationsData.filter(function(station) {
            const stationDept = station.code_departement || station.departement || '';
            const matches = stationDept.toString() === selectedDept;
            if (matches) {
                console.log('‚úÖ Station retenue:', station.code_station, station.libelle_station || station.nom, 'd√©partement:', stationDept);
            }
            return matches;
        });
    }
    
    console.log('üîç Stations filtr√©es:', window.aspeFilteredStationsData.length, 'sur', window.aspeStationsData.length);
    
    // Mettre √† jour le compteur
    const counter = document.getElementById('aspeStationsCount');
    if (counter) {
        counter.textContent = window.aspeFilteredStationsData.length;
    }
    
    // Recharger la carte avec les stations filtr√©es
    if (window.aspeMap) {
        displayFilteredStations();
        centerMapOnDepartment(selectedDept);
    }
};

// Fonction pour centrer la carte sur un d√©partement
window.centerMapOnDepartment = function(deptCode) {
    if (!window.aspeMap || !deptCode) return;
    
    const coords = window.departmentCoordinates[deptCode];
    if (coords) {
        console.log('üéØ Centrage carte sur d√©partement', deptCode, ':', coords);
        window.aspeMap.setView(coords, 10);
    } else {
        console.log('‚ö†Ô∏è Coordonn√©es non trouv√©es pour d√©partement:', deptCode);
    }
};

// Fonction pour afficher les stations filtr√©es
window.displayFilteredStations = function() {
    if (!window.aspeMap || !window.aspeFilteredStationsData) return;
    
    // Supprimer la couche existante
    if (window.aspeStationsLayer) {
        window.aspeMap.removeLayer(window.aspeStationsLayer);
    }
    
    // Afficher les stations filtr√©es
    addAspeStationsToMap(window.aspeFilteredStationsData);
    
    // Ajuster la vue si il y a des stations
    if (window.aspeFilteredStationsData.length > 0) {
        try {
            const bounds = [];
            window.aspeFilteredStationsData.forEach(function(station) {
                const lat = parseFloat(station.coordonnee_y) || parseFloat(station.latitude) || parseFloat(station.lat);
                const lon = parseFloat(station.coordonnee_x) || parseFloat(station.longitude) || parseFloat(station.lon);
                
                if (lat && lon && !isNaN(lat) && !isNaN(lon)) {
                    bounds.push([lat, lon]);
                }
            });
            
            if (bounds.length > 0) {
                window.aspeMap.fitBounds(bounds, { padding: [20, 20] });
            }
        } catch (e) {
            console.log('‚ö†Ô∏è Erreur ajustement vue filtr√©e:', e);
        }
    }
};

// Fonction pour cr√©er le graphique d'√©volution IPR
window.createIprEvolutionChart = function(data, evolution) {
    console.log('üìä Cr√©ation graphique √©volution IPR avec', data.length, 'points de donn√©es');
    
    const ctx = document.getElementById('iprEvolutionChart');
    if (!ctx) {
        console.error('‚ùå Canvas iprEvolutionChart non trouv√©');
        return;
    }
    
    // D√©truire le graphique existant s'il y en a un
    if (window.iprChart) {
        window.iprChart.destroy();
    }
    
    // Pr√©parer les donn√©es pour Chart.js
    const chartData = data.map(point => ({
        x: new Date(point.date),
        y: point.ipr,
        classe: point.classe,
        station: point.station,
        coursEau: point.cours_eau,
        commune: point.commune
    })).sort((a, b) => a.x - b.x);
    
    // Couleurs selon la classe √©cologique
    const getPointColor = (classe) => {
        switch(classe) {
            case 'Tr√®s bonne': return '#22c55e';
            case 'Bonne': return '#3b82f6';
            case 'Moyenne': return '#f59e0b';
            case 'M√©diocre': return '#ef4444';
            case 'Mauvaise': return '#dc2626';
            default: return '#6b7280';
        }
    };
    
    window.iprChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: '√âvolution IPR',
                data: chartData,
                borderColor: '#059669',
                backgroundColor: 'rgba(5, 150, 105, 0.1)',
                borderWidth: 2,
                pointBackgroundColor: chartData.map(point => getPointColor(point.classe)),
                pointBorderColor: '#fff',
                pointBorderWidth: 2,
                pointRadius: 6,
                pointHoverRadius: 8,
                fill: true,
                tension: 0.3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'year',
                        displayFormats: {
                            year: 'yyyy'
                        }
                    },
                    title: {
                        display: true,
                        text: 'Ann√©e',
                        font: {
                            weight: 'bold'
                        }
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Valeur IPR',
                        font: {
                            weight: 'bold'
                        }
                    },
                    ticks: {
                        callback: function(value) {
                            return value.toFixed(1);
                        }
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            const point = context[0].raw;
                            return new Date(point.x).toLocaleDateString('fr-FR');
                        },
                        label: function(context) {
                            const point = context.raw;
                            return [
                                `IPR: ${point.y}`,
                                `Classe: ${point.classe}`,
                                `Station: ${point.station}`,
                                `Cours d'eau: ${point.coursEau}`,
                                `Commune: ${point.commune}`
                            ];
                        }
                    },
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#fff',
                    bodyColor: '#fff',
                    borderColor: '#059669',
                    borderWidth: 1
                }
            },
            elements: {
                point: {
                    hoverBorderWidth: 3
                }
            }
        }
    });
    
    console.log('‚úÖ Graphique √©volution IPR cr√©√© avec succ√®s');
};

// Fonction pour ex√©cuter les analyses ASPE - DONN√âES AUTHENTIQUES EXCLUSIVES
window.executeAspeAnalysis = function(type) {
    console.log('üî¨ ASPE: Lancement analyse authentique EXCLUSIVE:', type);
    
    // V√©rifier qu'une station ASPE est s√©lectionn√©e
    const stationData = window.selectedAspeStation;
    if (!stationData || !stationData.id) {
        showAspeAnalysisResult('‚ö†Ô∏è STATION REQUISE', 'Veuillez d\'abord s√©lectionner une station ASPE sur la carte pour obtenir des donn√©es authentiques sp√©cifiques.');
        return;
    }
    
    console.log(`üéØ Station s√©lectionn√©e: ${stationData.id} - ${stationData.nom}`);
    
    // Afficher indicateur de chargement avec station sp√©cifique
    showAspeAnalysisResult('üîÑ R√âCUP√âRATION DONN√âES AUTHENTIQUES', 
        `Station: <strong>${stationData.id}</strong><br>` +
        `Nom: ${stationData.nom}<br>` +
        `R√©cup√©ration exclusive depuis Hub'Eau ASPE...<br>` +
        `<div class="spinner" style="margin: 10px auto;"></div>`);
    
    // R√âCUP√âRATION DIRECTE DONN√âES AUTHENTIQUES HUB'EAU ASPE STATION SP√âCIFIQUE
    Promise.all([
        // TOUS les IPR sp√©cifiques √† cette station - VRAIS INDICES IPR CALCUL√âS
        fetch(`https://hubeau.eaufrance.fr/api/v1/etat_piscicole/indicateurs?code_station=${stationData.id}&fields=code_station,date_operation,ipr_note,ipr_code_classe,ipr_libelle_classe,iprplus_note,iprplus_code_classe,iprplus_libelle_classe&size=10000&date_operation_min=2010-01-01`, {
            headers: { 'User-Agent': 'OFB-Tool/1.0' }
        }).then(r => r.ok ? r.json() : null).catch(() => null),
        
        // TOUTES les observations sp√©cifiques √† cette station
        fetch(`https://hubeau.eaufrance.fr/api/v1/etat_piscicole/observations?code_station=${stationData.id}&date_operation_min=2010-01-01&size=10000`, {
            headers: { 'User-Agent': 'OFB-Tool/1.0' }
        }).then(r => r.ok ? r.json() : null).catch(() => null),
        
        // TOUTES les op√©rations sp√©cifiques √† cette station
        fetch(`https://hubeau.eaufrance.fr/api/v1/etat_piscicole/operations?code_station=${stationData.id}&date_operation_min=2010-01-01&size=10000`, {
            headers: { 'User-Agent': 'OFB-Tool/1.0' }
        }).then(r => r.ok ? r.json() : null).catch(() => null)
    ])
    .then(([iprData, obsData, opsData]) => {
        console.log('üìä Donn√©es Hub\'Eau r√©cup√©r√©es:', {
            ipr: iprData?.data?.length || 0,
            observations: obsData?.data?.length || 0,
            operations: opsData?.data?.length || 0
        });
        
        // V√âRIFICATION STRICTE - DONN√âES AUTHENTIQUES UNIQUEMENT
        const hasIPR = iprData && iprData.data && iprData.data.length > 0;
        const hasObs = obsData && obsData.data && obsData.data.length > 0;
        const hasOps = opsData && opsData.data && opsData.data.length > 0;
        
        console.log('üîç V√©rification donn√©es:', { hasIPR, hasObs, hasOps });
        console.log('üìä D√©tails IPR:', iprData?.data?.length || 0, 'observations:', obsData?.data?.length || 0);
        
        if (!hasIPR && !hasObs && !hasOps) {
            showAspeAnalysisResult('‚ùå AUCUNE DONN√âE AUTHENTIQUE', 
                `Station: <strong>${stationData.id}</strong><br>` +
                `<div style="background: #fef2f2; padding: 15px; border-radius: 8px; border: 1px solid #ef4444; margin: 10px 0;">` +
                `<strong>Z√âRO TOL√âRANCE DONN√âES FACTICES</strong><br>` +
                `Cette station ne poss√®de aucune donn√©e authentique dans Hub'Eau ASPE.<br>` +
                `Veuillez s√©lectionner une autre station avec des donn√©es disponibles.` +
                `</div>`);
            return;
        }
        
        // G√âN√âRATION ANALYSE SELON TYPE AVEC DONN√âES AUTHENTIQUES EXCLUSIVES
        let result = { success: true, authentique: true, station: stationData.id };
        
        if (type === 'ipr') {
            console.log('üî¨ Type IPR demand√©, hasIPR:', hasIPR);
            if (hasIPR) {
                console.log('üìä Analyse IPR avec donn√©es indicateurs officiels');
                result = analyseIPRAuthentique(iprData.data, stationData);
            } else {
                console.log('‚ùå Aucune donn√©e IPR officielle disponible');
                result = {
                    success: false,
                    error: `Station ${stationData.id} - Aucune donn√©e IPR officielle disponible dans Hub'Eau`,
                    authentique: true
                };
            }
        } else if (type === 'species' && hasObs) {
            result = analyseEspecesAuthentique(obsData.data, stationData);
        } else if (type === 'geolocation') {
            // G√©olocalisation par esp√®ce pour le d√©partement
            const selector = document.getElementById('departmentSelector');
            const selectedDept = selector ? selector.value : '40';
            
            // Afficher le chargement imm√©diatement
            showAspeAnalysisResult('üîÑ R√âCUP√âRATION ESP√àCES', 
                `D√©partement: <strong>${selectedDept}</strong><br>` +
                `R√©cup√©ration liste des esp√®ces authentiques depuis Hub'Eau...<br>` +
                `<div class="spinner" style="margin: 10px auto;"></div>`);
            
            // G√©rer l'asynchrone sans await dans la fonction principale
            analyseGeolocalisationEspeces(selectedDept)
                .then(geoResult => {
                    afficherResultatsAspeAuthentique(geoResult, type);
                })
                .catch(error => {
                    console.error('‚ùå Erreur g√©olocalisation:', error);
                    showAspeAnalysisResult('‚ùå ERREUR G√âOLOCALISATION', 
                        `Impossible de r√©cup√©rer les esp√®ces pour le d√©partement ${selectedDept}: ${error.message}`);
                });
            return;
        } else {
            // Synth√®se g√©n√©rale des donn√©es disponibles - DONN√âES R√âELLES UNIQUEMENT
            result = {
                success: true,
                title: `üî¨ SYNTH√àSE DONN√âES ASPE AUTHENTIQUES`,
                description: `Station ${stationData.id} - Donn√©es exclusivement authentiques Hub'Eau`,
                data: {
                    indicateurs: hasIPR ? iprData.data : [],
                    observations: hasObs ? obsData.data : [],
                    operations: hasOps ? opsData.data : []
                },
                summary: `${(hasIPR ? iprData.data.length : 0) + (hasObs ? obsData.data.length : 0) + (hasOps ? opsData.data.length : 0)} enregistrements authentiques`,
                source: 'Hub\'Eau API ASPE - Donn√©es authentiques station sp√©cifique',
                authentique: true
            };
        }
        
        // Afficher les r√©sultats avec donn√©es authentiques exclusives
        afficherResultatsAspeAuthentique(result, type);
    })
    .catch(error => {
        console.error('‚ùå Erreur r√©cup√©ration Hub\'Eau ASPE:', error);
        showAspeAnalysisResult('‚ùå ERREUR AUTHENTIQUE', 
            `Station: <strong>${stationData.id}</strong><br>` +
            `<div style="background: #fef2f2; padding: 15px; border-radius: 8px; border: 1px solid #ef4444; margin: 10px 0;">` +
            `Impossible de r√©cup√©rer les donn√©es authentiques Hub'Eau.<br>` +
            `Erreur: ${error.message}<br>` +
            `Veuillez v√©rifier votre connexion internet ou essayer une autre station.` +
            `</div>`);
    });
};

// FONCTIONS D'ANALYSE AUTHENTIQUES EXCLUSIVES

function analyseIPRAuthentique(donneesIPR, stationData) {
    console.log(`üî¨ Analyse IPR authentique pour ${donneesIPR.length} mesures station ${stationData.id}`);
    
    // Conversion et nettoyage des donn√©es Hub'Eau IPR officielles
    const donneesAnalyse = donneesIPR.map(d => {
        console.log('üîç Donn√©e IPR officielle:', d);
        const iprValue = parseFloat(d.ipr_note) || 0;
        console.log('üí° Valeur IPR note extraite:', iprValue, 'Classe:', d.ipr_libelle_classe);
        return {
            date: d.date_operation,
            ipr: iprValue,
            classe: d.ipr_libelle_classe || classifierIPR(iprValue),
            code_classe: d.ipr_code_classe,
            station: d.code_station,
            annee: new Date(d.date_operation || '2020-01-01').getFullYear(),
            iprplus_note: parseFloat(d.iprplus_note) || null,
            iprplus_classe: d.iprplus_libelle_classe || null
        };
    }).filter(d => d.ipr > 0); // Exclure les valeurs nulles
    
    console.log('üìä Donn√©es analys√©es filtr√©es:', donneesAnalyse.length, 'sur', donneesIPR.length);
    
    if (donneesAnalyse.length === 0) {
        console.error('‚ùå Aucune donn√©e IPR valide trouv√©e');
        return {
            success: false,
            error: `Station ${stationData.id} - Donn√©es IPR invalides ou manquantes dans Hub'Eau`,
            authentique: false
        };
    }
    
    // Calculs statistiques authentiques
    const valeursIPR = donneesAnalyse.map(d => d.ipr);
    const moyenne = valeursIPR.reduce((a, b) => a + b, 0) / valeursIPR.length;
    const min = Math.min(...valeursIPR);
    const max = Math.max(...valeursIPR);
    
    // Tendance temporelle
    const tendance = calculerTendanceIPR(donneesAnalyse);
    
    // Distribution par classes
    const distribution = {};
    donneesAnalyse.forEach(d => {
        distribution[d.classe] = (distribution[d.classe] || 0) + 1;
    });
    
    // √âvaluation qualit√© √©cologique
    const qualiteEcologique = classifierIPR(moyenne);
    
    // Tri chronologique pour analyse temporelle
    donneesAnalyse.sort((a, b) => new Date(a.date) - new Date(b.date));
    
    // Calcul √©cart-type
    const ecartType = Math.sqrt(valeursIPR.reduce((sum, val) => sum + Math.pow(val - moyenne, 2), 0) / valeursIPR.length);
    
    // Dernier IPR (plus r√©cent)
    const dernierIPR = donneesAnalyse[donneesAnalyse.length - 1];
    
    return {
        success: true,
        title: `üî¨ ANALYSE IPR AUTHENTIQUE - Station ${stationData.id}`,
        description: `√âvolution IPR bas√©e sur ${donneesAnalyse.length} mesures AUTHENTIQUES Hub'Eau`,
        donnees: donneesAnalyse,
        tendance,
        distribution,
        statistiques: {
            dernier: {
                ipr: parseFloat(dernierIPR.ipr.toFixed(2)),
                date: dernierIPR.date,
                classe: dernierIPR.classe,
                annee: dernierIPR.annee
            },
            moyenne: parseFloat(moyenne.toFixed(2)),
            ecart_type: parseFloat(ecartType.toFixed(2)),
            min: parseFloat(min.toFixed(2)),
            max: parseFloat(max.toFixed(2)),
            nombre_mesures: donneesAnalyse.length,
            periode: `${donneesAnalyse[0].annee} - ${donneesAnalyse[donneesAnalyse.length - 1].annee}`,
            classe_moyenne: qualiteEcologique
        },
        source: `Hub'Eau API ASPE - Station ${stationData.id} - ${donneesAnalyse.length} mesures authentiques`,
        authentique: true,
        station: stationData.id
    };
}

function analyseEspecesAuthentique(donneesObs, stationData) {
    console.log(`üêü Analyse esp√®ces authentique pour ${donneesObs.length} observations COMPL√àTES station ${stationData.id}`);
    
    // Filtrer les observations valides avec nom latin ou commun
    const observationsValides = donneesObs.filter(obs => 
        (obs.nom_latin_taxon && obs.nom_latin_taxon.trim() !== '') ||
        (obs.nom_commun_taxon && obs.nom_commun_taxon.trim() !== '') ||
        (obs.libelle_taxon && obs.libelle_taxon.trim() !== '')
    );
    
    if (observationsValides.length === 0) {
        return {
            success: false,
            error: `Station ${stationData.id} - Aucune observation d'esp√®ces valide`,
            authentique: true
        };
    }
    
    // Synth√®se √©cologique avec noms corrects
    const getEspeceName = (obs) => obs.nom_latin_taxon || obs.nom_commun_taxon || obs.libelle_taxon;
    const especesUniques = new Set(observationsValides.map(obs => getEspeceName(obs)));
    
    // Debug : examiner les dates disponibles
    console.log('üîç Dates d\'observation disponibles:', observationsValides.map(obs => obs.date_operation).slice(0, 10));
    
    // Analyser la r√©partition des ann√©es
    const anneesPresentes = [...new Set(observationsValides.map(obs => new Date(obs.date_operation).getFullYear()))].sort();
    console.log('üìÖ Ann√©es pr√©sentes dans les donn√©es:', anneesPresentes);
    console.log('üìä Nombre d\'ann√©es de donn√©es:', anneesPresentes.length);
    
    // Analyse temporelle par esp√®ce
    const evolutionParEspece = {};
    observationsValides.forEach(obs => {
        const espece = getEspeceName(obs);
        const dateOp = obs.date_operation;
        
        if (!dateOp) {
            console.warn('‚ö†Ô∏è Date manquante pour observation:', obs);
            return;
        }
        
        const annee = new Date(dateOp).getFullYear();
        const effectif = parseInt(obs.nombre_individu) || parseInt(obs.effectif_total) || 1;
        
        console.log(`üìÖ ${espece} - Ann√©e: ${annee}, Effectif: ${effectif}`);
        
        if (!evolutionParEspece[espece]) {
            evolutionParEspece[espece] = {};
        }
        
        if (!evolutionParEspece[espece][annee]) {
            evolutionParEspece[espece][annee] = {
                effectif_total: 0,
                biomasse_totale: 0,
                observations: 0
            };
        }
        
        evolutionParEspece[espece][annee].effectif_total += effectif;
        evolutionParEspece[espece][annee].biomasse_totale += parseFloat(obs.biomasse_individu) || parseFloat(obs.poids_total) || 0;
        evolutionParEspece[espece][annee].observations += 1;
    });
    
    console.log('üìä √âvolution par esp√®ce calcul√©e:', Object.keys(evolutionParEspece).map(esp => ({
        espece: esp,
        annees: Object.keys(evolutionParEspece[esp]).sort()
    })));
    
    // Conversion en format pour graphiques temporels - DONN√âES R√âELLES UNIQUEMENT
    const donneesTemporelles = Object.keys(evolutionParEspece).map(espece => {
        const annees = Object.keys(evolutionParEspece[espece]).sort((a, b) => parseInt(a) - parseInt(b));
        
        // Utiliser UNIQUEMENT les ann√©es avec des donn√©es r√©elles
        const series = annees.map(annee => ({
            annee: parseInt(annee),
            effectif: evolutionParEspece[espece][annee].effectif_total,
            biomasse: parseFloat(evolutionParEspece[espece][annee].biomasse_totale.toFixed(2)),
            observations: evolutionParEspece[espece][annee].observations
        }));
        
        console.log(`üìä Donn√©es r√©elles pour ${espece}:`, series);
        
        return {
            espece,
            series,
            tendance: series.length > 1 ? calculerTendanceEspece(series) : 'Donn√©es insuffisantes',
            effectif_total: series.reduce((sum, s) => sum + s.effectif, 0),
            biomasse_totale: series.reduce((sum, s) => sum + s.biomasse, 0),
            periode: annees.length === 1 ? annees[0] : `${annees[0]} - ${annees[annees.length - 1]}`,
            nb_annees: annees.length,
            donnees_reelles: annees.length
        };
    }).sort((a, b) => b.effectif_total - a.effectif_total);
    
    const synthese = {
        nombreEspeces: especesUniques.size,
        nombreObservations: observationsValides.length,
        especesPatrimoniales: observationsValides.filter(esp => {
            const nom = getEspeceName(esp);
            return nom && (nom.includes('Salmo') || nom.includes('Cottus') || nom.includes('Thymallus'));
        }).length,
        biomasseTotale: observationsValides.reduce((sum, esp) => 
            sum + (parseFloat(esp.biomasse_individu) || parseFloat(esp.poids_total) || 0), 0),
        effectifTotal: observationsValides.reduce((sum, esp) => 
            sum + (parseInt(esp.nombre_individu) || parseInt(esp.effectif_total) || 1), 0)
    };
    
    // Esp√®ces dominantes (top 5)
    const dominantes = donneesTemporelles.slice(0, 5).map(esp => ({
        espece: esp.espece,
        effectif: esp.effectif_total,
        biomasse: esp.biomasse_totale,
        observations: esp.series.reduce((sum, s) => sum + s.observations, 0),
        tendance: esp.tendance
    }));
    
    return {
        success: true,
        title: `üêü ANALYSE ESP√àCES AUTHENTIQUE - Station ${stationData.id}`,
        description: `Composition peuplement piscicole bas√©e sur ${observationsValides.length} observations COMPL√àTES AUTHENTIQUES (${anneesPresentes.join(', ')})`,
        donnees: observationsValides,
        synthese,
        dominantes,
        evaluation: {
            statut: synthese.nombreEspeces > 10 ? 'Bon' : synthese.nombreEspeces > 5 ? 'Moyen' : 'D√©grad√©',
            commentaire: `Communaut√© bas√©e sur ${synthese.nombreEspeces} esp√®ces observ√©es`,
            diversite: synthese.nombreEspeces,
            biomasse_moyenne: synthese.biomasseTotale / synthese.nombreEspeces,
            densite: synthese.effectifTotal / synthese.nombreObservations
        },
        statistiques: {
            diversite: synthese.nombreEspeces,
            observations_totales: synthese.nombreObservations,
            biomasse_totale: parseFloat(synthese.biomasseTotale.toFixed(2)),
            effectif_total: synthese.effectifTotal,
            especes_patrimoniales: synthese.especesPatrimoniales,
            dominantes: dominantes.slice(0, 3)
        },
        evolution_temporelle: donneesTemporelles,
        source: `Hub'Eau API ASPE - Station ${stationData.id} - ${observationsValides.length} observations authentiques`,
        authentique: true,
        station: stationData.id
    };
}

function calculerTendanceEspece(series) {
    if (series.length < 2) return 'Insuffisant';
    
    const n = series.length;
    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
    
    series.forEach((point, i) => {
        const x = i + 1; // Position temporelle
        const y = point.effectif;
        sumX += x;
        sumY += y;
        sumXY += x * y;
        sumX2 += x * x;
    });
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    
    if (slope > 0.5) return 'Croissante';
    if (slope < -0.5) return 'D√©croissante';
    return 'Stable';
}

// Fonction de g√©olocalisation par esp√®ce pour le d√©partement
async function analyseGeolocalisationEspeces(departement) {
    console.log('üåç G√©olocalisation par esp√®ce pour d√©partement:', departement);
    
    try {
        // 1. R√©cup√©rer toutes les observations du d√©partement
        const observationsUrl = `https://hubeau.eaufrance.fr/api/v1/etat_piscicole/observations?code_departement=${departement}&size=10000&date_operation_min=2010-01-01`;
        const observationsResponse = await fetch(observationsUrl, {
            headers: { 'User-Agent': 'OFB-Tool/1.0' }
        });
        
        if (!observationsResponse.ok) {
            throw new Error('Impossible de r√©cup√©rer les observations');
        }
        
        const observationsData = await observationsResponse.json();
        
        if (!observationsData.data || observationsData.data.length === 0) {
            return {
                success: false,
                error: `Aucune observation d'esp√®ces trouv√©e pour le d√©partement ${departement}`
            };
        }
        
        // 2. Extraire la liste unique des esp√®ces avec leurs informations - DONN√âES R√âELLES UNIQUEMENT
        const especesMap = new Map();
        observationsData.data.forEach(obs => {
            // VALIDATION STRICTE - EXCLURE TOUTE DONN√âE POTENTIELLEMENT FACTICE
            const nomEspece = obs.nom_latin_taxon || obs.nom_commun_taxon || obs.libelle_taxon;
            
            // V√©rifier que l'observation a une date valide et r√©cente
            const dateObs = new Date(obs.date_operation);
            const isValidDate = dateObs && dateObs > new Date('2000-01-01') && dateObs <= new Date();
            
            // V√©rifier que la station existe r√©ellement
            const hasValidStation = obs.code_station && obs.code_station.trim() !== '';
            
            // EXCLUSION STRICTE des donn√©es suspectes ou factices
            if (nomEspece && nomEspece.trim() !== '' && isValidDate && hasValidStation) {
                if (!especesMap.has(nomEspece)) {
                    especesMap.set(nomEspece, {
                        nom: nomEspece,
                        nom_latin: obs.nom_latin_taxon,
                        nom_commun: obs.nom_commun_taxon,
                        code_taxon: obs.code_alternatif_taxon,
                        stations: new Set(),
                        derniere_observation: null,
                        total_observations: 0
                    });
                }
                
                const espece = especesMap.get(nomEspece);
                espece.stations.add(obs.code_station);
                espece.total_observations++;
                
                // Mettre √† jour la derni√®re observation
                const dateObs = new Date(obs.date_operation);
                if (!espece.derniere_observation || dateObs > new Date(espece.derniere_observation)) {
                    espece.derniere_observation = obs.date_operation;
                }
            }
        });
        
        // 3. Convertir en tableau et trier par nombre de stations
        const especesList = Array.from(especesMap.values())
            .map(esp => ({
                ...esp,
                nb_stations: esp.stations.size,
                stations: Array.from(esp.stations)
            }))
            .sort((a, b) => b.nb_stations - a.nb_stations);
        
        console.log(`üêü ${especesList.length} esp√®ces trouv√©es dans le d√©partement ${departement}`);
        
        return {
            success: true,
            title: `üåç G√âOLOCALISATION PAR ESP√àCE - D√©partement ${departement}`,
            description: `${especesList.length} esp√®ces observ√©es dans ${new Set(observationsData.data.map(obs => obs.code_station)).size} stations`,
            especes: especesList,
            departement: departement,
            total_observations: observationsData.data.length,
            authentique: true
        };
        
    } catch (error) {
        console.error('‚ùå Erreur g√©olocalisation esp√®ces:', error);
        return {
            success: false,
            error: `Erreur lors de la r√©cup√©ration des esp√®ces: ${error.message}`
        };
    }
}

// Fonction pour cr√©er l'interface de g√©olocalisation par esp√®ce
function creerInterfaceGeolocalisationEspeces(result) {
    console.log('üåç Cr√©ation interface g√©olocalisation avec', result.especes.length, 'esp√®ces');
    
    const content = `
    <div style="background: #dcfce7; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #16a34a;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span style="font-size: 24px;">üåç</span>
            <strong style="color: #15803d; font-size: 18px;">${result.title}</strong>
        </div>
        <div style="font-size: 14px; color: #374151;">
            ${result.description}<br>
            <strong>Total observations:</strong> ${result.total_observations} authentiques
        </div>
    </div>
    
    <div style="background: #f8fafc; padding: 20px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #cbd5e1;">
        <h4 style="color: #1e40af; margin: 0 0 15px 0; font-size: 16px; font-weight: bold;">üêü S√©lectionnez une esp√®ce pour voir sa g√©olocalisation</h4>
        
        <div style="margin-bottom: 15px;">
            <label for="especeSelector" style="display: block; font-weight: bold; margin-bottom: 8px; color: #374151;">
                Esp√®ce √† localiser:
            </label>
            <select id="especeSelector" style="width: 100%; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; background: white; font-size: 14px;" onchange="filtrerCarteParEspece()">
                <option value="">-- Choisir une esp√®ce --</option>
                ${result.especes.map(esp => `
                    <option value="${esp.nom}" data-stations='${JSON.stringify(esp.stations)}' data-derniere="${esp.derniere_observation}">
                        ${esp.nom} (${esp.nb_stations} stations, ${esp.total_observations} obs.)
                    </option>
                `).join('')}
            </select>
        </div>
        
        <div id="especeInfo" style="display: none; background: white; padding: 15px; border-radius: 6px; border: 1px solid #e5e7eb;">
            <h5 style="margin: 0 0 10px 0; color: #1f2937; font-size: 14px; font-weight: bold;">Informations de l'esp√®ce s√©lectionn√©e:</h5>
            <div id="especeDetails"></div>
        </div>
        
        <div style="margin-top: 15px; padding: 10px; background: #fef3c7; border-radius: 6px; border: 1px solid #f59e0b;">
            <p style="margin: 0; font-size: 12px; color: #92400e;">
                üí° <strong>Instructions:</strong> S√©lectionnez une esp√®ce dans la liste pour filtrer la carte et afficher uniquement les stations o√π elle a √©t√© observ√©e. Cliquez sur une station pour voir les d√©tails avec un mini-graphique d'√©volution temporelle.
            </p>
        </div>
    </div>`;
    
    showAspeAnalysisResult(result.title, content);
    
    // Stocker les donn√©es d'esp√®ces pour utilisation ult√©rieure
    window.especesData = result.especes;
    window.departementEspeces = result.departement;
}

// Fonction pour filtrer la carte par esp√®ce s√©lectionn√©e
function filtrerCarteParEspece() {
    const selector = document.getElementById('especeSelector');
    const especeInfo = document.getElementById('especeInfo');
    const especeDetails = document.getElementById('especeDetails');
    
    if (!selector || !selector.value) {
        // R√©initialiser la carte avec toutes les stations
        if (window.aspeFilteredStationsData) {
            addAspeStationsToMap(window.aspeFilteredStationsData);
        }
        especeInfo.style.display = 'none';
        return;
    }
    
    const selectedOption = selector.selectedOptions[0];
    const nomEspece = selectedOption.value;
    const stationsEspece = JSON.parse(selectedOption.dataset.stations);
    const derniereObs = selectedOption.dataset.derniere;
    
    console.log(`üîç Filtrage carte pour esp√®ce: ${nomEspece}`, stationsEspece);
    
    // Afficher les informations de l'esp√®ce
    especeDetails.innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
            <div style="text-align: center; padding: 8px; background: #f3f4f6; border-radius: 4px;">
                <div style="font-weight: bold; color: #1f2937;">${stationsEspece.length}</div>
                <div style="font-size: 12px; color: #6b7280;">Stations</div>
            </div>
            <div style="text-align: center; padding: 8px; background: #f3f4f6; border-radius: 4px;">
                <div style="font-weight: bold; color: #059669;">${new Date(derniereObs).toLocaleDateString('fr-FR')}</div>
                <div style="font-size: 12px; color: #6b7280;">Derni√®re obs.</div>
            </div>
        </div>
    `;
    especeInfo.style.display = 'block';
    
    // Filtrer les stations ASPE pour n'afficher que celles o√π l'esp√®ce est pr√©sente
    if (window.aspeFilteredStationsData && window.aspeMap) {
        const stationsFiltered = window.aspeFilteredStationsData.filter(station => 
            stationsEspece.includes(station.id)
        );
        
        console.log(`üéØ ${stationsFiltered.length} stations trouv√©es avec l'esp√®ce ${nomEspece}`);
        
        // Mettre √† jour la carte avec les stations filtr√©es
        addAspeStationsToMapWithSpeciesInfo(stationsFiltered, nomEspece);
    }
}

// Fonction pour ajouter les stations avec informations d'esp√®ce
function addAspeStationsToMapWithSpeciesInfo(stations, nomEspece) {
    if (!window.aspeMap || !stations || !Array.isArray(stations)) {
        console.error('‚ùå Carte ou stations manquantes pour filtrage esp√®ce');
        return;
    }
    
    console.log(`üìç Ajout de ${stations.length} stations avec info esp√®ce ${nomEspece}`);
    
    // Supprimer couche existante
    if (window.aspeStationsLayer) {
        window.aspeMap.removeLayer(window.aspeStationsLayer);
    }
    
    // Cr√©er nouvelle couche avec marqueurs sp√©cialis√©s
    window.aspeStationsLayer = L.layerGroup();
    
    stations.forEach(station => {
        const marker = L.marker([station.latitude, station.longitude], {
            icon: L.divIcon({
                className: 'custom-div-icon',
                html: `<div style="background: #059669; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">üêü</div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            })
        });
        
        // Popup enrichi avec informations d'esp√®ce
        const popupContent = `
            <div style="min-width: 250px;">
                <h4 style="margin: 0 0 10px 0; color: #1f2937; font-size: 14px;">
                    Station ${station.id}
                </h4>
                <div style="margin-bottom: 10px;">
                    <strong>Nom:</strong> ${station.nom}<br>
                    <strong>Cours d'eau:</strong> ${station.cours_eau || 'Non renseign√©'}<br>
                    <strong>Coordonn√©es:</strong> ${station.latitude.toFixed(4)}, ${station.longitude.toFixed(4)}
                </div>
                <div style="background: #dcfce7; padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                    <strong style="color: #059669;">üêü Esp√®ce observ√©e:</strong><br>
                    ${nomEspece}
                </div>
                <button onclick="afficherDetailsEspeceStation('${station.id}', '${nomEspece}')" 
                        style="width: 100%; padding: 8px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    üìä Voir d√©tails et √©volution temporelle
                </button>
            </div>
        `;
        
        marker.bindPopup(popupContent);
        window.aspeStationsLayer.addLayer(marker);
    });
    
    window.aspeStationsLayer.addTo(window.aspeMap);
    
    // Ajuster la vue sur les stations filtr√©es
    if (stations.length > 0) {
        const group = new L.featureGroup(Object.values(window.aspeStationsLayer._layers));
        window.aspeMap.fitBounds(group.getBounds().pad(0.1));
    }
}

function afficherDetailsEspeceStation(stationId, nomEspece) {
    console.log(`üìä R√©cup√©ration d√©tails esp√®ce ${nomEspece} pour station ${stationId}`);
    
    // Afficher un indicateur de chargement
    const loadingContent = `
        <div style="text-align: center; padding: 20px;">
            <div style="font-size: 36px; margin-bottom: 10px;">‚è≥</div>
            <p>R√©cup√©ration des donn√©es d'√©volution temporelle...</p>
        </div>
    `;
    
    // Cr√©er un modal ou utiliser la zone d'analyse existante
    showAspeAnalysisResult(`üêü √âvolution ${nomEspece} - Station ${stationId}`, loadingContent);
    
    // R√©cup√©rer les observations de cette esp√®ce pour cette station
    const observationsUrl = `https://hubeau.eaufrance.fr/api/v1/etat_piscicole/observations?code_station=${stationId}&size=1000&date_operation_min=2010-01-01`;
    
    fetch(observationsUrl, {
        headers: { 'User-Agent': 'OFB-Tool/1.0' }
    })
    .then(response => response.json())
    .then(data => {
        if (data.data && data.data.length > 0) {
            // Filtrer les observations pour l'esp√®ce s√©lectionn√©e
            const observationsEspece = data.data.filter(obs => {
                const nomObservation = obs.nom_latin_taxon || obs.nom_commun_taxon || obs.libelle_taxon;
                return nomObservation === nomEspece;
            });
            
            if (observationsEspece.length > 0) {
                creerGraphiqueEvolutionEspece(observationsEspece, nomEspece, stationId);
            } else {
                showAspeAnalysisResult(`‚ùå Aucune donn√©e trouv√©e`, `Aucune observation de ${nomEspece} trouv√©e pour la station ${stationId}`);
            }
        } else {
            showAspeAnalysisResult(`‚ùå Erreur`, `Impossible de r√©cup√©rer les donn√©es pour la station ${stationId}`);
        }
    })
    .catch(error => {
        console.error('‚ùå Erreur r√©cup√©ration observations:', error);
        showAspeAnalysisResult(`‚ùå Erreur`, `Erreur lors de la r√©cup√©ration: ${error.message}`);
    });
}

function creerGraphiqueEvolutionEspece(observations, nomEspece, stationId) {
    console.log(`üìà Cr√©ation graphique √©volution pour ${observations.length} observations AUTHENTIQUES`);
    
    // VALIDATION STRICTE - AUCUNE EXTRAPOLATION, DONN√âES R√âELLES UNIQUEMENT
    const observationsValides = observations.filter(obs => {
        const dateValid = obs.date_operation && new Date(obs.date_operation) > new Date('2000-01-01');
        const effectifValid = (obs.nombre_individu && parseInt(obs.nombre_individu) > 0) || 
                             (obs.effectif_total && parseInt(obs.effectif_total) > 0);
        const stationValid = obs.code_station === stationId;
        
        return dateValid && effectifValid && stationValid;
    });
    
    console.log(`üîç ${observationsValides.length} observations valides sur ${observations.length} (exclusion donn√©es factices)`);
    
    if (observationsValides.length === 0) {
        showAspeAnalysisResult(`‚ùå AUCUNE DONN√âE R√âELLE`, 
            `Aucune observation authentique de ${nomEspece} trouv√©e pour la station ${stationId}. 
            Toutes les donn√©es potentiellement factices ont √©t√© exclues.`);
        return;
    }
    
    // Analyser les donn√©es temporelles - DONN√âES R√âELLES EXCLUSIVEMENT
    const donneesParAnnee = {};
    observationsValides.forEach(obs => {
        const annee = new Date(obs.date_operation).getFullYear();
        const effectif = parseInt(obs.nombre_individu) || parseInt(obs.effectif_total);
        
        if (!donneesParAnnee[annee]) {
            donneesParAnnee[annee] = {
                effectif_total: 0,
                observations: 0,
                biomasse: 0,
                derniere_date: obs.date_operation
            };
        }
        
        donneesParAnnee[annee].effectif_total += effectif;
        donneesParAnnee[annee].observations += 1;
        donneesParAnnee[annee].biomasse += parseFloat(obs.biomasse_individu) || 0;
        
        // Garder la date la plus r√©cente
        if (new Date(obs.date_operation) > new Date(donneesParAnnee[annee].derniere_date)) {
            donneesParAnnee[annee].derniere_date = obs.date_operation;
        }
    });
    
    // Trier par ann√©e - DONN√âES R√âELLES UNIQUEMENT
    const annees = Object.keys(donneesParAnnee).sort();
    const derniereObservation = observationsValides
        .sort((a, b) => new Date(b.date_operation) - new Date(a.date_operation))[0];
        
    console.log(`üìÖ Ann√©es avec donn√©es r√©elles: ${annees.join(', ')}`);
    console.log(`üîç Derni√®re observation authentique: ${derniereObservation.date_operation}`);
    
    const content = `
        <div style="background: #dcfce7; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #16a34a;">
            <h3 style="margin: 0 0 10px 0; color: #15803d;">üêü ${nomEspece}</h3>
            <p style="margin: 0; color: #374151;">Station ${stationId} - √âvolution temporelle authentique</p>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 15px;">
            <div style="background: #f3f4f6; padding: 10px; border-radius: 6px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold; color: #1f2937;">${observations.length}</div>
                <div style="font-size: 12px; color: #6b7280;">Observations</div>
            </div>
            <div style="background: #f3f4f6; padding: 10px; border-radius: 6px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold; color: #059669;">${annees.length}</div>
                <div style="font-size: 12px; color: #6b7280;">Ann√©es</div>
            </div>
            <div style="background: #f3f4f6; padding: 10px; border-radius: 6px; text-align: center;">
                <div style="font-size: 14px; font-weight: bold; color: #3b82f6;">${new Date(derniereObservation.date_operation).toLocaleDateString('fr-FR')}</div>
                <div style="font-size: 12px; color: #6b7280;">Derni√®re obs.</div>
            </div>
            <div style="background: #f3f4f6; padding: 10px; border-radius: 6px; text-align: center;">
                <div style="font-size: 18px; font-weight: bold; color: #f59e0b;">${parseInt(derniereObservation.nombre_individu) || parseInt(derniereObservation.effectif_total) || 1}</div>
                <div style="font-size: 12px; color: #6b7280;">Dernier effectif</div>
            </div>
        </div>
        
        <div style="background: white; padding: 15px; border-radius: 8px; border: 1px solid #e5e7eb;">
            <h4 style="margin: 0 0 15px 0; color: #1f2937;">üìà √âvolution des effectifs par ann√©e (DONN√âES R√âELLES UNIQUEMENT)</h4>
            <div style="background: #fef3c7; padding: 8px; border-radius: 4px; margin-bottom: 10px; border: 1px solid #f59e0b;">
                <p style="margin: 0; font-size: 12px; color: #92400e;">
                    ‚ö†Ô∏è <strong>Aucune extrapolation:</strong> Ce graphique affiche uniquement les ann√©es avec des observations r√©elles. Les ann√©es sans donn√©es ne sont pas repr√©sent√©es.
                </p>
            </div>
            <canvas id="graphiqueEspeceEvolution" width="400" height="200"></canvas>
        </div>
        
        <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-top: 15px; border: 1px solid #cbd5e1;">
            <h5 style="margin: 0 0 10px 0; color: #374151;">üìä D√©tail par ann√©e:</h5>
            ${annees.map(annee => `
                <div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #e5e7eb;">
                    <span><strong>${annee}:</strong></span>
                    <span>${donneesParAnnee[annee].effectif_total} individus (${donneesParAnnee[annee].observations} obs.)</span>
                </div>
            `).join('')}
        </div>
    `;
    
    showAspeAnalysisResult(`üêü ${nomEspece} - Station ${stationId}`, content);
    
    // Dessiner le graphique apr√®s insertion dans le DOM
    setTimeout(() => {
        dessinerGraphiqueEvolutionEspece(annees, donneesParAnnee);
    }, 100);
}

function dessinerGraphiqueEvolutionEspece(annees, donneesParAnnee) {
    const canvas = document.getElementById('graphiqueEspeceEvolution');
    if (!canvas) {
        console.error('‚ùå Canvas graphique non trouv√©');
        return;
    }
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Effacer le canvas
    ctx.clearRect(0, 0, width, height);
    
    if (annees.length === 0) {
        ctx.font = '16px Arial';
        ctx.fillStyle = '#6b7280';
        ctx.textAlign = 'center';
        ctx.fillText('Aucune donn√©e √† afficher', width / 2, height / 2);
        return;
    }
    
    // Marges
    const margin = { top: 20, right: 30, bottom: 40, left: 50 };
    const graphWidth = width - margin.left - margin.right;
    const graphHeight = height - margin.top - margin.bottom;
    
    // Donn√©es pour le graphique
    const effectifs = annees.map(annee => donneesParAnnee[annee].effectif_total);
    const maxEffectif = Math.max(...effectifs);
    const minEffectif = Math.min(...effectifs);
    
    // √âchelles
    const xScale = graphWidth / (annees.length - 1 || 1);
    const yScale = graphHeight / (maxEffectif - minEffectif || 1);
    
    // Dessiner les axes
    ctx.strokeStyle = '#9ca3af';
    ctx.lineWidth = 1;
    
    // Axe X
    ctx.beginPath();
    ctx.moveTo(margin.left, height - margin.bottom);
    ctx.lineTo(width - margin.right, height - margin.bottom);
    ctx.stroke();
    
    // Axe Y
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, height - margin.bottom);
    ctx.stroke();
    
    // Labels ann√©es
    ctx.fillStyle = '#374151';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    annees.forEach((annee, i) => {
        const x = margin.left + i * xScale;
        ctx.fillText(annee, x, height - margin.bottom + 15);
    });
    
    // Labels effectifs
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const value = minEffectif + (maxEffectif - minEffectif) * (i / 5);
        const y = height - margin.bottom - (value - minEffectif) * yScale;
        ctx.fillText(Math.round(value), margin.left - 5, y + 3);
    }
    
    // Dessiner UNIQUEMENT des points pour les ann√©es avec donn√©es r√©elles - AUCUNE LIGNE CONTINUE
    // Ceci √©vite toute impression d'extrapolation ou d'interpolation entre les ann√©es
    ctx.fillStyle = '#3b82f6';
    ctx.strokeStyle = '#1e40af';
    ctx.lineWidth = 2;
    
    annees.forEach((annee, i) => {
        const x = margin.left + i * xScale;
        const y = height - margin.bottom - (effectifs[i] - minEffectif) * yScale;
        
        // Point principal
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        
        // Barre verticale pour montrer l'effectif (optionnel)
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, height - margin.bottom);
        ctx.lineTo(x, y);
        ctx.stroke();
        
        // Remettre le style pour le prochain point
        ctx.strokeStyle = '#1e40af';
        ctx.lineWidth = 2;
    });
    
    // Note explicative sur l'absence de lignes continues
    ctx.font = '11px Arial';
    ctx.fillStyle = '#6b7280';
    ctx.textAlign = 'center';
    ctx.fillText('Points isol√©s = Donn√©es r√©elles uniquement (pas d\'extrapolation)', width / 2, height - 5);
    
    console.log('‚úÖ Graphique √©volution esp√®ce cr√©√©');
}

function afficherResultatsAspeAuthentique(result, type) {
    if (!result.success) {
        showAspeAnalysisResult('‚ùå ERREUR ANALYSE', result.error || 'Donn√©es non disponibles');
        return;
    }
    
    // Pour l'analyse IPR ou esp√®ces, passer l'objet complet pour l'affichage avanc√©
    if ((type === 'ipr' || type === 'species') && result.statistiques) {
        showAspeAnalysisResult(result.title, result);
        return;
    }
    
    // Pour la g√©olocalisation par esp√®ce, cr√©er l'interface de s√©lection
    if (type === 'geolocation' && result.especes) {
        creerInterfaceGeolocalisationEspeces(result);
        return;
    }
    
    let content = `
    <div style="background: #dcfce7; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #16a34a;">
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span style="font-size: 24px;">‚úÖ</span>
            <strong style="color: #15803d; font-size: 18px;">DONN√âES 100% AUTHENTIQUES</strong>
        </div>
        <div style="font-size: 14px; color: #374151;">
            <strong>Station:</strong> ${result.station}<br>
            <strong>Source:</strong> ${result.source}<br>
            <strong>Type:</strong> ${result.title}
        </div>
    </div>`;
    
    if (type === 'ipr' && result.evaluation) {
        content += `
        <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #cbd5e1;">
            <h4 style="color: #1e40af; margin: 0 0 15px 0; font-size: 16px; font-weight: bold;">üéØ Statistiques IPR Authentiques</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                <div style="background: white; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 20px; font-weight: bold; color: #1e40af;">${result.evaluation.moyenne}</div>
                    <div style="font-size: 12px; color: #6b7280;">Moyenne IPR</div>
                </div>
                <div style="background: white; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 20px; font-weight: bold; color: #059669;">${result.evaluation.min}</div>
                    <div style="font-size: 12px; color: #6b7280;">Minimum</div>
                </div>
                <div style="background: white; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 20px; font-weight: bold; color: #dc2626;">${result.evaluation.max}</div>
                    <div style="font-size: 12px; color: #6b7280;">Maximum</div>
                </div>
                <div style="background: white; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold; color: #7c3aed;">${result.evaluation.classe}</div>
                    <div style="font-size: 12px; color: #6b7280;">Qualit√©</div>
                </div>
            </div>
        </div>`;
    }
    
    if (type === 'species' && result.synthese) {
        content += `
        <div style="background: #f0fdf4; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #22c55e;">
            <h4 style="color: #15803d; margin: 0 0 15px 0; font-size: 16px; font-weight: bold;">üêü Synth√®se √âcologique Authentique</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 15px;">
                <div style="background: white; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 20px; font-weight: bold; color: #15803d;">${result.synthese.nombreEspeces}</div>
                    <div style="font-size: 12px; color: #6b7280;">Esp√®ces</div>
                </div>
                <div style="background: white; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 20px; font-weight: bold; color: #3b82f6;">${result.synthese.nombreObservations}</div>
                    <div style="font-size: 12px; color: #6b7280;">Observations</div>
                </div>
                <div style="background: white; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 20px; font-weight: bold; color: #f59e0b;">${result.synthese.especesPatrimoniales}</div>
                    <div style="font-size: 12px; color: #6b7280;">Patrimoniales</div>
                </div>
                <div style="background: white; padding: 10px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 16px; font-weight: bold; color: #7c3aed;">${result.evaluation.statut}</div>
                    <div style="font-size: 12px; color: #6b7280;">Statut</div>
                </div>
            </div>
            
            <h5 style="color: #374151; margin: 15px 0 10px 0; font-size: 14px; font-weight: bold;">üèÜ Esp√®ces Dominantes</h5>
            <div style="background: white; padding: 10px; border-radius: 6px;">
                ${result.dominantes.map((esp, index) => `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 5px 0; border-bottom: ${index < result.dominantes.length - 1 ? '1px solid #e5e7eb' : 'none'};">
                        <span style="font-weight: 500; color: #374151;">${esp.espece}</span>
                        <div style="text-align: right; font-size: 12px; color: #6b7280;">
                            <div>Biomasse: ${esp.biomasse.toFixed(1)}g</div>
                            <div>Effectif: ${esp.effectif}</div>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>`;
    }
    
    showAspeAnalysisResult(result.title, content);
}

function classifierIPR(ipr) {
    if (ipr <= 7) return 'Excellente';
    if (ipr <= 16) return 'Bonne';
    if (ipr <= 25) return 'M√©diocre';
    if (ipr <= 36) return 'Mauvaise';
    return 'Tr√®s mauvaise';
}

function calculerTendanceIPR(donnees) {
    if (donnees.length < 2) return { direction: 'Donn√©es insuffisantes' };
    
    const valeursIPR = donnees.map(d => d.ipr);
    const premiere = valeursIPR[0];
    const derniere = valeursIPR[valeursIPR.length - 1];
    
    const evolution = derniere - premiere;
    const direction = Math.abs(evolution) < 1 ? 'Stable' : 
                     evolution > 0 ? 'D√©gradation' : 'Am√©lioration';
                     
    return { direction, evolution: parseFloat(evolution.toFixed(2)) };
}

function analyseObservationsPourIPR(observations, stationData) {
    console.log(`üêü Analyse observations pour estimation IPR - ${observations.length} observations station ${stationData.id}`);
    
    // Grouper par op√©ration pour calculer diversit√© et biomasse
    const operations = {};
    observations.forEach(obs => {
        const opId = obs.code_operation;
        if (!operations[opId]) {
            operations[opId] = {
                date: obs.date_operation,
                especes: new Set(),
                biomasse_totale: 0,
                effectif_total: 0,
                observations: []
            };
        }
        operations[opId].especes.add(obs.nom_latin_taxon || obs.nom_commun_taxon);
        operations[opId].biomasse_totale += parseFloat(obs.biomasse_individu) || 0;
        operations[opId].effectif_total += parseFloat(obs.nombre_individu) || 1;
        operations[opId].observations.push(obs);
    });
    
    const operationsArray = Object.values(operations);
    if (operationsArray.length === 0) {
        return {
            success: false,
            error: `Station ${stationData.id} - Observations invalides pour estimation IPR`,
            authentique: true
        };
    }
    
    // Calcul d'indices bas√©s sur les observations
    const diversiteMoyenne = operationsArray.reduce((sum, op) => sum + op.especes.size, 0) / operationsArray.length;
    const biomasseMoyenne = operationsArray.reduce((sum, op) => sum + op.biomasse_totale, 0) / operationsArray.length;
    
    // Estimation IPR simplifi√©e bas√©e sur diversit√© et biomasse
    let iprEstime = 20; // Base moyenne
    if (diversiteMoyenne >= 8) iprEstime -= 5; // Bonne diversit√©
    if (diversiteMoyenne <= 3) iprEstime += 5; // Faible diversit√©
    if (biomasseMoyenne >= 500) iprEstime -= 3; // Bonne biomasse
    if (biomasseMoyenne <= 100) iprEstime += 3; // Faible biomasse
    
    const qualiteEstimee = classifierIPR(iprEstime);
    
    return {
        success: true,
        title: `üêü ESTIMATION IPR - Station ${stationData.code}`,
        description: `Estimation bas√©e sur ${observations.length} observations authentiques Hub'Eau`,
        donnees: operationsArray,
        evaluation: {
            ipr_estime: parseFloat(iprEstime.toFixed(1)),
            classe: qualiteEstimee,
            diversite_moyenne: parseFloat(diversiteMoyenne.toFixed(1)),
            biomasse_moyenne: parseFloat(biomasseMoyenne.toFixed(1)),
            nombre_operations: operationsArray.length
        },
        authentique: true,
        estimation: true,
        source: 'Hub\'Eau API ASPE - Estimation bas√©e observations'
    };
}

function creerCourbeIPR(donnees) {
    const canvas = document.getElementById('ipr-chart');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    const donneesTriees = [...donnees].sort((a, b) => new Date(a.date) - new Date(b.date));
    const padding = 60;
    const plotWidth = width - 2 * padding;
    const plotHeight = height - 2 * padding;
    
    const valeursIPR = donneesTriees.map(d => d.ipr);
    const minIPR = Math.min(...valeursIPR);
    const maxIPR = Math.max(...valeursIPR);
    const rangeIPR = maxIPR - minIPR || 1;
    
    // Dessiner les axes
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, height - padding);
    ctx.lineTo(width - padding, height - padding);
    ctx.stroke();
    
    // Dessiner la courbe IPR
    ctx.strokeStyle = '#2563eb';
    ctx.lineWidth = 3;
    ctx.beginPath();
    
    donneesTriees.forEach((d, i) => {
        const x = padding + (i / (donneesTriees.length - 1)) * plotWidth;
        const y = height - padding - ((d.ipr - minIPR) / rangeIPR) * plotHeight;
        
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    });
    ctx.stroke();
    
    // Points sur la courbe
    ctx.fillStyle = '#1d4ed8';
    donneesTriees.forEach((d, i) => {
        const x = padding + (i / (donneesTriees.length - 1)) * plotWidth;
        const y = height - padding - ((d.ipr - minIPR) / rangeIPR) * plotHeight;
        
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, 2 * Math.PI);
        ctx.fill();
    });
    
    // √âtiquettes
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    
    // Ann√©es sur l'axe X
    donneesTriees.forEach((d, i) => {
        if (i % Math.ceil(donneesTriees.length / 6) === 0) {
            const x = padding + (i / (donneesTriees.length - 1)) * plotWidth;
            ctx.fillText(d.annee.toString(), x, height - padding + 20);
        }
    });
    
    // Valeurs IPR sur l'axe Y
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const value = minIPR + (rangeIPR * i / 5);
        const y = height - padding - (i / 5) * plotHeight;
        ctx.fillText(value.toFixed(1), padding - 10, y + 4);
    }
    
    // Titre
    ctx.textAlign = 'center';
    ctx.font = 'bold 16px Arial';
    ctx.fillStyle = '#1f2937';
    ctx.fillText('√âvolution temporelle IPR - Donn√©es authentiques Hub\'Eau', width / 2, 30);
}

function creerTableauRecapitulatifEspeces(evolutionData) {
    const container = document.getElementById('species-summary-table');
    if (!container) {
        console.error('‚ùå Container species-summary-table non trouv√©');
        return;
    }
    
    // Cr√©er le tableau
    let tableHTML = `
        <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
            <thead>
                <tr style="background: #f8fafc; border-bottom: 2px solid #e2e8f0;">
                    <th style="padding: 12px; text-align: left; border: 1px solid #e2e8f0; font-weight: bold; color: #1f2937;">Esp√®ce</th>
                    <th style="padding: 12px; text-align: center; border: 1px solid #e2e8f0; font-weight: bold; color: #1f2937;">Effectif Total</th>
                    <th style="padding: 12px; text-align: center; border: 1px solid #e2e8f0; font-weight: bold; color: #1f2937;">Biomasse (g)</th>
                    <th style="padding: 12px; text-align: center; border: 1px solid #e2e8f0; font-weight: bold; color: #1f2937;">Observations</th>
                    <th style="padding: 12px; text-align: center; border: 1px solid #e2e8f0; font-weight: bold; color: #1f2937;">Ann√©es</th>
                    <th style="padding: 12px; text-align: center; border: 1px solid #e2e8f0; font-weight: bold; color: #1f2937;">Tendance</th>
                    <th style="padding: 12px; text-align: center; border: 1px solid #e2e8f0; font-weight: bold; color: #1f2937;">Statut</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    evolutionData.forEach((espece, index) => {
        // D√©terminer le statut √©cologique (simplifi√©)
        const statut = getStatutEspece(espece.espece);
        const statutColor = getStatutColor(statut);
        const tendanceColor = getTendanceColor(espece.tendance);
        
        const rowColor = index % 2 === 0 ? '#ffffff' : '#f8fafc';
        
        tableHTML += `
            <tr style="background: ${rowColor}; border-bottom: 1px solid #e2e8f0;">
                <td style="padding: 10px; border: 1px solid #e2e8f0; font-weight: 500; color: #1f2937;">
                    <span style="font-style: italic; cursor: pointer; color: #0369a1; text-decoration: underline;" 
                          onclick="afficherCourbeEspece('${espece.espece.replace(/'/g, "\\'")}', ${JSON.stringify(espece.series).replace(/"/g, '&quot;')})"
                          title="Cliquer pour voir la courbe d'√©volution">
                        ${espece.espece}
                    </span>
                </td>
                <td style="padding: 10px; border: 1px solid #e2e8f0; text-align: center; font-weight: bold; color: #059669;">
                    ${espece.effectif_total}
                </td>
                <td style="padding: 10px; border: 1px solid #e2e8f0; text-align: center; color: #0369a1;">
                    ${espece.biomasse_totale.toFixed(1)}
                </td>
                <td style="padding: 10px; border: 1px solid #e2e8f0; text-align: center; color: #7c3aed;">
                    ${espece.series.reduce((sum, s) => sum + s.observations, 0)}
                </td>
                <td style="padding: 10px; border: 1px solid #e2e8f0; text-align: center; color: #dc2626;">
                    ${espece.nb_annees}
                </td>
                <td style="padding: 10px; border: 1px solid #e2e8f0; text-align: center;">
                    <span style="color: ${tendanceColor}; font-weight: bold;">
                        ${espece.tendance}
                    </span>
                </td>
                <td style="padding: 10px; border: 1px solid #e2e8f0; text-align: center;">
                    <span style="background: ${statutColor}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">
                        ${statut}
                    </span>
                </td>
            </tr>
        `;
    });
    
    tableHTML += `
            </tbody>
        </table>
        <div style="margin-top: 15px; font-size: 12px; color: #6b7280; text-align: center;">
            <strong>Total: ${evolutionData.length} esp√®ces observ√©es</strong> | 
            Effectif global: ${evolutionData.reduce((sum, esp) => sum + esp.effectif_total, 0)} individus |
            Biomasse totale: ${evolutionData.reduce((sum, esp) => sum + esp.biomasse_totale, 0).toFixed(1)} g
        </div>
    `;
    
    container.innerHTML = tableHTML;
}

function getStatutEspece(nomEspece) {
    const nomLower = nomEspece.toLowerCase();
    
    // Esp√®ces patrimoniales
    if (nomLower.includes('salmo') || nomLower.includes('thymallus') || nomLower.includes('cottus')) {
        return 'Patrimoniale';
    }
    
    // Esp√®ces invasives
    if (nomLower.includes('pseudorasbora') || nomLower.includes('lepomis') || nomLower.includes('procambarus')) {
        return 'Invasive';
    }
    
    // Esp√®ces migratrices
    if (nomLower.includes('anguilla') || nomLower.includes('petromyzon') || nomLower.includes('lampetra')) {
        return 'Migratrice';
    }
    
    return 'Commune';
}

function getStatutColor(statut) {
    switch (statut) {
        case 'Patrimoniale': return '#059669'; // vert
        case 'Invasive': return '#dc2626'; // rouge
        case 'Migratrice': return '#0369a1'; // bleu
        default: return '#6b7280'; // gris
    }
}

function getTendanceColor(tendance) {
    switch (tendance) {
        case 'Croissante': return '#059669'; // vert
        case 'D√©croissante': return '#dc2626'; // rouge
        case 'Stable': return '#0369a1'; // bleu
        default: return '#6b7280'; // gris
    }
}

// Fonction pour afficher la courbe d'√©volution d'une esp√®ce sp√©cifique
function afficherCourbeEspece(nomEspece, seriesData) {
    console.log('üìä Affichage courbe pour:', nomEspece);
    
    const container = document.getElementById('species-individual-chart');
    const infoDiv = document.getElementById('species-selection-info');
    
    if (!container) {
        console.error('‚ùå Container species-individual-chart non trouv√©');
        return;
    }
    
    // Afficher le container et masquer le message d'info
    container.style.display = 'block';
    if (infoDiv) {
        infoDiv.style.display = 'none';
    }
    
    // Trouver l'esp√®ce dans les donn√©es compl√®tes
    const especeData = window.especesEvolutionData?.find(e => e.espece === nomEspece);
    if (!especeData) {
        console.error('‚ùå Donn√©es non trouv√©es pour esp√®ce:', nomEspece);
        return;
    }
    
    // R√©cup√©rer le canvas et ajuster sa taille
    const canvas = document.getElementById('individualSpeciesChart');
    if (canvas) {
        canvas.width = 800;
        canvas.height = 400;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        
        // Cr√©er le graphique individuel large
        dessinerGraphiqueEspece(canvas, especeData, true);
    }
}

function creerGraphiquesEspecesEvolution(evolutionData) {
    const container = document.getElementById('species-evolution-charts');
    if (!container) {
        console.error('‚ùå Container species-evolution-charts non trouv√©');
        return;
    }
    
    container.innerHTML = '';
    
    // Prendre les 6 esp√®ces les plus importantes
    const especesTop = evolutionData.slice(0, 6);
    
    especesTop.forEach((especeData, index) => {
        const chartDiv = document.createElement('div');
        chartDiv.style.cssText = `
            background: white; 
            padding: 15px; 
            border-radius: 8px; 
            border: 1px solid #e5e7eb;
            margin-bottom: 15px;
        `;
        
        const title = document.createElement('h5');
        title.style.cssText = `
            margin: 0 0 15px 0; 
            color: #1f2937; 
            font-size: 16px; 
            font-weight: bold;
            text-align: center;
        `;
        const periodeText = especeData.donnees_reelles === 1 ? 
            `${especeData.espece} - ${especeData.donnees_reelles} ann√©e de donn√©es (${especeData.periode})` :
            `${especeData.espece} - ${especeData.donnees_reelles} ann√©es - Tendance: ${especeData.tendance}`;
        title.textContent = periodeText;
        
        const canvas = document.createElement('canvas');
        canvas.width = 600;
        canvas.height = 200;
        canvas.style.cssText = `
            border: 1px solid #d1d5db; 
            border-radius: 6px; 
            background: white;
            display: block;
            margin: 0 auto;
        `;
        
        chartDiv.appendChild(title);
        chartDiv.appendChild(canvas);
        container.appendChild(chartDiv);
        
        // Dessiner le graphique
        dessinerGraphiqueEspece(canvas, especeData);
    });
}

function dessinerGraphiqueEspece(canvas, especeData, isLarge = false) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const padding = isLarge ? 80 : 60;
    const plotWidth = width - 2 * padding;
    const plotHeight = height - 2 * padding;
    
    // Fond blanc
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);
    
    // Titre pour graphique individuel
    if (isLarge) {
        ctx.fillStyle = '#1f2937';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`üìà ${especeData.espece}`, width / 2, 35);
        
        ctx.fillStyle = '#6b7280';
        ctx.font = '14px Arial';
        ctx.fillText(`${especeData.effectif_total} individus - ${especeData.nb_annees} ann√©e(s) - Tendance: ${especeData.tendance}`, width / 2, 55);
    }
    
    const series = especeData.series;
    if (series.length === 0) return;
    
    // Calculer les √©chelles
    const annees = series.map(s => s.annee);
    const effectifs = series.map(s => s.effectif);
    const minAnnee = Math.min(...annees);
    const maxAnnee = Math.max(...annees);
    const minEffectif = Math.min(...effectifs);
    const maxEffectif = Math.max(...effectifs);
    const rangeEffectif = maxEffectif - minEffectif || 1;
    
    // Grille et axes
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;
    
    // Lignes horizontales
    for (let i = 0; i <= 5; i++) {
        const y = padding + (i / 5) * plotHeight;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
    }
    
    // Lignes verticales (seulement si plus d'un point)
    if (series.length > 1) {
        for (let i = 0; i < series.length; i++) {
            const x = padding + (i / (series.length - 1)) * plotWidth;
            ctx.beginPath();
            ctx.moveTo(x, padding);
            ctx.lineTo(x, height - padding);
            ctx.stroke();
        }
    }
    
    // Dessiner la courbe d'effectifs (seulement si plus d'un point)
    if (series.length > 1) {
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        series.forEach((point, i) => {
            const x = padding + (i / (series.length - 1)) * plotWidth;
            const y = height - padding - ((point.effectif - minEffectif) / rangeEffectif) * plotHeight;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        ctx.stroke();
    }
    
    // Points de donn√©es
    ctx.fillStyle = '#3b82f6';
    series.forEach((point, i) => {
        const x = series.length === 1 ? width / 2 : padding + (i / (series.length - 1)) * plotWidth;
        const y = height - padding - ((point.effectif - minEffectif) / rangeEffectif) * plotHeight;
        
        ctx.beginPath();
        ctx.arc(x, y, series.length === 1 ? 8 : 4, 0, 2 * Math.PI);
        ctx.fill();
        
        // √âtiquette effectif
        ctx.fillStyle = '#1f2937';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(point.effectif.toString(), x, y - 15);
    });
    
    // √âtiquettes des axes
    ctx.fillStyle = '#6b7280';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    
    // Ann√©es (axe X)
    series.forEach((point, i) => {
        const x = series.length === 1 ? width / 2 : padding + (i / (series.length - 1)) * plotWidth;
        ctx.fillText(point.annee.toString(), x, height - padding + 20);
    });
    
    // Effectifs (axe Y)
    ctx.textAlign = 'right';
    for (let i = 0; i <= 5; i++) {
        const value = minEffectif + (rangeEffectif * i / 5);
        const y = height - padding - (i / 5) * plotHeight;
        ctx.fillText(Math.round(value).toString(), padding - 10, y + 4);
    }
    
    // Titre axe Y
    ctx.save();
    ctx.translate(20, height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillStyle = '#374151';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Nombre d\'individus', 0, 0);
    ctx.restore();
}

function showAspeAnalysisResult(title, content) {
    console.log('üéØ showAspeAnalysisResult appel√©e avec:', title);
    const resultDiv = document.getElementById('aspeAnalysisResult');
    console.log('üìç Element aspeAnalysisResult trouv√©:', !!resultDiv);
    
    if (!resultDiv) {
        console.error('‚ùå Element aspeAnalysisResult NON TROUV√â');
        return;
    }

    // Si c'est un objet result complexe (analyse IPR ou esp√®ces)
    if (typeof content === 'object' && content.statistiques) {
        const stats = content.statistiques;
        let html = `
            <h3 style="color: #1f2937; margin-bottom: 20px; font-size: 20px; font-weight: bold; text-align: center;">${title}</h3>
        `;
        
        // Affichage sp√©cialis√© pour IPR
        if (title.includes('IPR')) {
            html += `
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin: 20px 0;">
                    <div style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0 0 10px 0; font-size: 16px;">üéØ Dernier IPR</h4>
                        <div style="font-size: 32px; font-weight: bold; margin: 10px 0;">${stats.dernier.ipr}</div>
                        <div style="font-size: 14px; opacity: 0.9;">${stats.dernier.classe} (${stats.dernier.annee})</div>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0 0 10px 0; font-size: 16px;">üìä Moyenne</h4>
                        <div style="font-size: 32px; font-weight: bold; margin: 10px 0;">${stats.moyenne}</div>
                        <div style="font-size: 14px; opacity: 0.9;">${stats.classe_moyenne}</div>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0 0 10px 0; font-size: 16px;">üìè √âcart-type</h4>
                        <div style="font-size: 32px; font-weight: bold; margin: 10px 0;">${stats.ecart_type}</div>
                        <div style="font-size: 14px; opacity: 0.9;">Variabilit√©</div>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white; padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0 0 10px 0; font-size: 16px;">üìà Amplitude</h4>
                        <div style="font-size: 24px; font-weight: bold; margin: 10px 0;">${stats.min} - ${stats.max}</div>
                        <div style="font-size: 14px; opacity: 0.9;">${stats.nombre_mesures} mesures (${stats.periode})</div>
                    </div>
                </div>
                
                <div style="margin: 30px 0; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 1px solid #e5e7eb;">
                    <h4 style="margin: 0 0 20px 0; color: #1f2937; font-size: 18px; text-align: center;">üìà Courbe d'√©volution temporelle IPR</h4>
                    <div style="text-align: center;">
                        <canvas id="ipr-chart" width="700" height="350" style="border: 1px solid #d1d5db; border-radius: 8px; background: white;"></canvas>
                    </div>
                </div>
            `;
        }
        // Affichage sp√©cialis√© pour analyse d'esp√®ces
        else if (title.includes('ESP√àCES')) {
            html += `
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin: 20px 0;">
                    <div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0 0 10px 0; font-size: 16px;">üê† Diversit√©</h4>
                        <div style="font-size: 32px; font-weight: bold; margin: 10px 0;">${stats.diversite}</div>
                        <div style="font-size: 14px; opacity: 0.9;">esp√®ces observ√©es</div>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0 0 10px 0; font-size: 16px;">üìä Observations</h4>
                        <div style="font-size: 32px; font-weight: bold; margin: 10px 0;">${stats.observations_totales}</div>
                        <div style="font-size: 14px; opacity: 0.9;">poissons captur√©s</div>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0 0 10px 0; font-size: 16px;">‚öñÔ∏è Biomasse</h4>
                        <div style="font-size: 28px; font-weight: bold; margin: 10px 0;">${stats.biomasse_totale}g</div>
                        <div style="font-size: 14px; opacity: 0.9;">biomasse totale</div>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white; padding: 20px; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <h4 style="margin: 0 0 10px 0; font-size: 16px;">üåü Patrimoniales</h4>
                        <div style="font-size: 32px; font-weight: bold; margin: 10px 0;">${stats.especes_patrimoniales}</div>
                        <div style="font-size: 14px; opacity: 0.9;">esp√®ces prot√©g√©es</div>
                    </div>
                </div>
                
                <div style="margin: 30px 0; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 1px solid #e5e7eb;">
                    <h4 style="margin: 0 0 20px 0; color: #1f2937; font-size: 18px; text-align: center;">üêü Esp√®ces dominantes</h4>
                    <div style="display: grid; gap: 10px;">
            `;
            
            if (stats.dominantes && stats.dominantes.length > 0) {
                stats.dominantes.forEach((esp, i) => {
                    const colors = ['#10b981', '#3b82f6', '#8b5cf6'];
                    html += `
                        <div style="background: ${colors[i] || '#6b7280'}; color: white; padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: bold; font-size: 16px;">${esp.espece}</div>
                                <div style="font-size: 14px; opacity: 0.9;">${esp.observations} observations</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 18px; font-weight: bold;">${esp.effectif}</div>
                                <div style="font-size: 12px; opacity: 0.8;">${esp.biomasse.toFixed(1)}g</div>
                            </div>
                        </div>
                    `;
                });
            }
            
            html += `
                    </div>
                </div>
                
                <div style="margin: 30px 0; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 1px solid #e5e7eb;">
                    <h4 style="margin: 0 0 20px 0; color: #1f2937; font-size: 18px; text-align: center;">üìã Tableau r√©capitulatif des esp√®ces</h4>
                    <div id="species-summary-table" style="overflow-x: auto;"></div>
                </div>
                
                <div style="margin: 30px 0; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border: 1px solid #e5e7eb;">
                    <h4 style="margin: 0 0 20px 0; color: #1f2937; font-size: 18px; text-align: center;">üìà √âvolution temporelle par esp√®ce</h4>
                    <div id="species-selection-info" style="text-align: center; margin-bottom: 15px; padding: 10px; background: #f8fafc; border-radius: 8px; color: #6b7280; font-size: 14px;">
                        Cliquez sur le nom d'une esp√®ce dans le tableau ci-dessus pour afficher sa courbe d'√©volution
                    </div>
                    <div id="species-individual-chart" style="height: 400px; display: none;">
                        <canvas id="individualSpeciesChart" style="width: 100%; height: 100%;"></canvas>
                    </div>
                </div>
            `;
        }
        
        html += `
            <div style="background: #f8fafc; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3b82f6;">
                <small style="color: #6b7280;">üîó ${content.source}</small>
            </div>
        `;
        
        resultDiv.innerHTML = html;
        
        // Cr√©er les graphiques apr√®s insertion HTML
        if (content.donnees && content.donnees.length > 0 && title.includes('IPR')) {
            setTimeout(() => creerCourbeIPR(content.donnees), 150);
        } else if (content.evolution_temporelle && title.includes('ESP√àCES')) {
            setTimeout(() => {
                // Stocker les donn√©es pour utilisation interactive
                window.especesEvolutionData = content.evolution_temporelle;
                creerTableauRecapitulatifEspeces(content.evolution_temporelle);
            }, 150);
        }
    } else {
        // Affichage simple pour autres contenus
        resultDiv.innerHTML = `
            <h3 style="color: #1f2937; margin-bottom: 15px; font-size: 18px; font-weight: bold;">${title}</h3>
            ${content}
        `;
    }
    
    resultDiv.style.display = 'block';
    console.log('‚úÖ Contenu affich√©:', title);
    console.log('üîç Type de contenu:', typeof content);
    console.log('üîç Structure contenu:', content);
}

</script>
</body>
</html>
